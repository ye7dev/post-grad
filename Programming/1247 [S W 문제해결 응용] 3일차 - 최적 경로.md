# 1247. [S/W 문제해결 응용] 3일차 - 최적 경로

Created time: April 8, 2024 10:31 AM
Last edited time: April 8, 2024 2:40 PM

- [x]  한 원소가 리스트이고, 이 리스트 길이가 2 이상일 때, 바깥 list.sort() 하면 Inner list의 첫번째 원소 기준으로 정렬하는게 맞지?
- [x]  MST 찾는 문제인가? 그러면 prim이나 kruskal 써야 하는데 kruskal 어제 썼는데 좀 비효율이었음. prim으로?
- [x]  prim 자료구조 뭐쓰더라…deque인가
- [x]  office → first customer to visit에서 늘 둘 사이의 거리가 가장 짧은 집부터 방문하는게 맞나?
    - 근데 그러면 그 집에서 늘 방문을 시작해야 하는데, 다른 집에서 방문 시작하는 경로가 더 짧을 수도 있지 않나?
- [x]  왜 MST 구할 때 제일 outer for loop이 N번 도는 거지?
- Trial - 아휴 길다 ;;
    - first shot
        
        ```python
        from collections import deque
        def get_optim_route(N, info):
            office = info[0:2]  # 0
            home = info[2:4]  # N+1
            customers = []  # 1~N
            for i in range(4, len(info), 2):
                customers.append(info[i:i+2])
            assert len(customers) == N
            # office to the first customer
            graph = {}
            graph[0] = {}
            for i in range(N):
                cust_x, cust_y = customers[i]
                distance = abs(office[0]-cust_x) + abs(office[1]-cust_y)
                graph[0][i+1] = distance
        
            # in between customers
        
            for i in range(N):
                from_x, from_y = customers[i]
                if i + 1 not in graph:
                    graph[i + 1] = {}
                home_distance = abs(from_x-home[0]) + abs(from_y-home[1])
                graph[i+1][N+1] = home_distance
                for j in range(i+1, N):
                    to_x, to_y = customers[j]
                    distance = abs(from_x-to_x) + abs(from_y-to_y)
                    if j+1 not in graph:
                        graph[j+1] = {}
                    graph[i+1][j+1] = distance
        
                    graph[j+1][i+1] = distance
        
            all_dist = [float('inf')] * (N+11)
            all_dist[0] = 0
            mst = [False] * (N+2)
            cur_node = 0
            mst[0] = True
            for _ in range(N):
                min_dist = float('inf')
                new = -1 # what for?
                for dest in range(1, N+1):
                    if not mst[dest]:
                        dist = graph[cur_node][dest]
                        if dist < all_dist[dest]:
                            all_dist[dest] = dist
                        if all_dist[dest] < min_dist:
                            min_dist = all_dist[dest]
                            new = dest
                mst[new] = True # mst[-1] = True?
                cur_node = new
        
            total_dist = sum(all_dist)
            total_dist += graph[cur_node][N+1]
            return total_dist
        
        T = int(input())
        for t in range(1, T+1):
            N = int(input())
            info = list(map(int, input().split()))
            ans = get_optim_route(N, info)
            print(f'#{t} {ans}')
        ```
        
    - second shot - MST 적용했는데 틀림
        
        ```python
        import heapq
        def get_optim_route(N, info):
            office = info[0:2]  # 0
            home = info[2:4]  # N+1
            customers = []  # 1~N
            for i in range(4, len(info), 2):
                customers.append(info[i:i+2])
            assert len(customers) == N
        
            cust_dist = [float('inf')] * N
            visited = [False] * N
            graph = {}
            # build graph
            for i in range(N):
                if i not in graph:
                    graph[i] = []
                for j in range(N):
                    dist = abs(customers[i][0]-customers[j][0]) + abs(customers[i][1]-customers[j][1])
                    if j not in graph:
                        graph[j] = []
                    graph[i].append((dist, j))
                    graph[j].append((dist, i))
        
            # get MST among 1~N node
            rand_start = 0
            edges = [(0, rand_start)]
        
            while edges:
                cur_dist, cur_node = heapq.heappop(edges)
                if not visited[cur_node]:
                    visited[cur_node] = True
                    cust_dist[cur_node] = cur_dist
        
                for next_dist, next_node in graph[cur_node]:
                    if not visited[next_node]:
                        heapq.heappush(edges, (next_dist, next_node))
        
            total_dist = sum(cust_dist)
            # plus dist between min(office_to_some_cust), min(some_cust_to_home)
            min_start_dist, min_end_dist = float('inf'), float('inf')
            for i in range(N):
                cust_x, cust_y = customers[i]
                office_dist = abs(office[0]-cust_x) + abs(office[1]-cust_y)
                min_start_dist = min(min_start_dist, office_dist)
                home_dist = abs(home[0]-cust_x) + abs(home[1]-cust_y)
                min_end_dist = min(min_end_dist, home_dist)
        
            total_dist += (min_start_dist + min_end_dist)
            return total_dist
        
        T = int(input())
        for t in range(1, T+1):
            N = int(input())
            info = list(map(int, input().split()))
            ans = get_optim_route(N, info)
            print(f'#{t} {ans}')
        ```
        
- AC 코드
    - open TSP with fixed destination
    
    ```python
    from itertools import permutations
    
    def distance(point1, point2):
        return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])
    
    def total_distance(route):
        # route: start + permutation of rest of the nodes + end
        total_dist = 0
        for i in range(len(route) - 1):
            total_dist += distance(route[i], route[i + 1])
        return total_dist
    
    def solve_open_tsp_with_fixed_destination(intermediate_points, start_point, end_point):
        min_dist = float('inf')
    
        for perm in permutations(intermediate_points):
            # 경로: 시작점 -> 중간 노드들 -> 종료점
            route = [start_point] + list(perm) + [end_point]
            current_dist = total_distance(route)
            if current_dist < min_dist:
                min_dist = current_dist
    
        return min_dist
    
    T = int(input())
    for t in range(1, T+1):
        N = int(input())
        info = list(map(int, input().split()))
        start = info[0:2]
        end = info[2:4]
        points = []
        for i in range(4, len(info), 2):
            points.append((info[i], info[i+1]))
        print(f'#{t} {solve_open_tsp_with_fixed_destination(points, start, end)}')
    ```