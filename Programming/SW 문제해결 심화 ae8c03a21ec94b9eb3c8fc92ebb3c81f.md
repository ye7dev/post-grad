# SW 문제해결 심화

Created time: April 18, 2024 4:13 PM
Last edited time: April 23, 2024 1:10 PM

1. **Ad Hoc Algorithms**
    - 8차시 최대 subarray 찾기
        
        **Kadane’s Algorithm**
        
        - 솔직히 설명이 잘 이해가 안가고 이상하다
            - array의 각 위치에서 끝나는 범위들 중 합이 제일 큰 것을 찾자
            - A[i]에서 끝나는 가장 큰 합을 안다면, A[i+1]에서 끝나는 가장 큰 합을 알 수 있다
            - 단, 합이 음수이면 잘 정리가 안된다
                - 크기가 0인 배열을 생각하자
                    - A[i]에서 끝나는 가장 큰 합 (노란 부분) + A[i+1] (붉은 값)이 음수라면, 노란 부분의 시작점을 어떻게 변화시켜도 음수를 피할 수 없음
                    
                    → 붉은 값 바로 뒤에 있는 크기 0인 배열의 합이 가능한 가장 큰 값. 0 
                    
            - 알고리즘
                - S[i]: A[i]에서 끝나는 가장 큰 합. S[0] = 0
                - A[i]에 도달했을 때 할 일
                    - S[i-1] + A[i] ≤ 0 → S[i] = 0
                    - S[i-1] + A[i] > 0 → S[i] = S[i-1] + A[i]
        - 맞는 코드는 이거임
            
            ```python
            def maxSubArray(self, nums: List[int]) -> int:
                max_ending_here = max_so_far = nums[0]
                for x in nums[1:]:
                    max_ending_here = max(x, max_ending_here + x)
                    max_so_far = max(max_so_far, max_ending_here)
                return max_so_far      
            ```
            
    - 9차시 Game (IOI 2014)
        - union-find로 그룹의 대표 노드 빠르게 찾기
        - 뭔소린지 몰루
2. **증명의 중요성** 
    - 1차시 인접한 값을 Delete하면서 Insert
        - BST에서 insert & delete next smallest라는 메서드 구현하기
            - next smallest: insert 하는 값보다 바로 하나 작은 값
                - 존재하지 않는 경우는 단순히 insert
            - 이미 존재하는 값이 insert 되는 경우는 없다고 가정
            - BST가 정확히 동작한다는 증명을 알면 쉬운 문제
        - delete 알고리즘과 증명
            - 제거하려는 노드의 child 개수에 따라 경우가 갈림
            - 0개 → 제거하려는 노드가 leaf 노드 → 단순 노드 제거
            - 1개 → 제거하려는 노드의 유일한 child를 parent(child 입장에는 grand parent)에 붙인다
            - 2개
                - next largest 값을 찾는다
                - 제거될 값과 next largest의 값을 교환하고 제거될 값을 제거
                - 이렇게 해도 되는 이유는 BST를 일렬로 나열했을 때 제거될 값(x)과 next largest 값(y)은 딱 붙어 있음 → x보다 작은 값은 y보다도 작고, x보다 큰 값은 아무리 작아도 y보다 크게 됨 → 두 값을 바꾸어도 트리의 나머지 부분의 모든 값이 제대로 search 된다
        - 아이디어
            - A라는 값을 insert한 후, next smallest로 찾은 값이 x
                
                → x의 next largest는 A 
                
                → x를 delete 하는 과정에서 next largest를 찾는다면 A가 나옴 
                
            - x → next largest = A 찾는 과정
                - x에서 시작해서 오른쪽 child로 한 번 이동
                - 그 이후로는 더 이상 못 갈 때까지 왼쪽 child로 이동
            - A → next smallest = x 찾는 과정
                - 자기 자신이 parent의 왼쪽 child인 한 parent로 이동하는 것을 반복
                - 거슬러 올라가다가 지금 있는 노드가 최초로 어떤 parent의 오른쪽 child가 될 때 그 parent가 x
                - 예
                    
                    ![Untitled](Untitled%20121.png)
                    
                    - 13의 next smallest를 찾는다고 할 때,
                        - 13은 14의 왼쪽 child 이므로 14로 이동
                        
                        → 14는 처음으로 10의 오른쪽 child가 된다
                        
                        → 그 parent인 10이 13의 next smallest가 된다 
                        
                        ⇒ 10을 제거한다고 하면 10과 13의 자리를 바꾼 다음, 리프가 된 10을 제거하면 된다는 의미 
                        
                        ⇒ 사실 더 간단하게 생각하면 13을 추가하고, 10이랑 자리를 바꾼 다음 10을 제거하는 과정을 다 거치지 말고, 그냥 10 자리에 13을 가져다가 쓰면 insert and delete the next smallest를 만족하게 되는 것 
                        
                    
    - 2차시 임의의 하노이 타워 상태 🤷‍♀️
        
        뭐라고 하는지 몰루?
        
        - 큰 원반이 작은 원반 아래쪽에 있는 규칙은 만족하면서, N개의 원반이 아무렇게나 3개 기둥에 나누어져있음
            - 한 기둥 내에서 원반 간의 순서는 정해져 있음 = 저절로 정해짐
            - → 이 상태에서 제일 왼쪽 기둥에 모든 원반이 있는 상태로 갈 수 있는 방법이 있는가? 있다면 최소 원반 이동 횟수는?
        - 하노이 타워의 모든 상태 (입력으로 주어질 수 있는 임의의 상태) 수는?
            - N개의 원반이 3개의 기둥 중 어디든 갈 수 있으므로 3**N개
            - 보통의 하노이 타워를 푸는 과정에서는 2**N-1번 이동 → 초기 상태까지 합치면 총 2**N개의 상태가 등장
            - 3 ** N > 2 ** N이라 입력 상태는 정상적인 하노이 타워 푸는 과정에 등장하지 않는 경우도 있을 것
        - 입력으로 주어진 상태가 보통의 하노이 타워를 푸는 과정에 등장하는 것이라면, 답은 당연히 yes,
            - 그리고 최소 이동 횟수는 보통의 하노이 푸는 과정에서 몇 번째에 등장하는 것을 알면된다 → why?
                - 보통의 하노이 푸는 과정은 유일한 최적이라는 증명이 있기 때문. 여기서 몇 번째 등장하는지 알면 최소 거리
        - 하노이 알고리즘
            
            ```python
            def Honoi(N, A, B, C): 
            	# N개의 원반을 A->B로 이동하되, C를 거칠 수 있음 
            	if N > 0:
            			Hanoi(N-1, A, C, B) # N-1개를 A->C로 
            			Move Nth 원반 from A to B # 제일 큰 원반을 A->B로 
            			Hanoi(N-1, C, B, A) # N-1개를 C->B로 
            	
            ```
            
        - 최적 증명
            - 증명은 잘 모르겠고;; 최적의 알고리즘은 2**N-1번 이동하는 거라고 함
        - 알고리즘
            - 제일 큰 원반이 목적지 A에 있는 경우
                - 나머지 원반을 모두 A로 모은다 (problem X)
            - 제일 큰 원반이 B에 있는 경우
                - 나머지 원반을 모두 C로 모은다 (problem X)
                - 제일 큰 원반을 A로 옮긴다
                - C에 모아뒀던 원반을 모두 A로 옮긴다 (problem Y)
            - 제일 큰 원반이 C에 있는 경우
                - B에 있는 경우와 대칭
            
            → problem X: 원래 풀려던 문제와 같은 문제. 입력만 다르고. → 재귀호출로 계산해야 
            
            → problem Y: 기본 하노이 타워 문제와 같은 문제 → 2 **M-1로 바로 계산
            
            ⇒ 재귀호출은 한번만 하면 되기 때문에 전체 시간은 O(N)에 가능
            
        - 주어진 상태가 원래 하노이 타워의 풀이 과정의 중간에 나오는 상태인지 알아볼 방법이 있는가?
            - 원래 하노이 시작 상태로 갈 수 있는 최단 거리 계산
            - 주어진 상태에서 정상 하노이 최종 상태로 갈 수 있는 최단 거리 계산
            - 두 거리의 합이 2**N-1이면 정상적인 풀이 과정의 중간에 나오는 상태임
            - 그보다 크다면 정상적인 풀이 과정에 있는 것이 아님
            - 정상적인 풀이 과정이 유일한 최단 거리를 내기 때문
    - 3차시 물통
        - 두 개의 물통이 있다. 각각 용량은 a, b 리터. 초기에 두 물통은 비어 있다. 물을 추가하거나 버리거나 두 물통 사이에서 옮길 수 있다. 두 물통에 각각 x리터, y 리터가 들어 있도록 할 수 있는가?
            - 원래 문제는 x,y 들의 sequence를 주고, transition이 가능한 가장 긴 subsequence를 찾으라는 것
        - 가능한 x, y 쌍들
            - (a, 0), (0, b), (a, b), (a-b, b), (a-b, 0), (a-2b, b)
            - 패턴: 양쪽 물통에서 더하기 빼기만 가능
            
            → g : a,b의 최대 공약수
            
            - x가 g의 배수이고, y도 g의 배수이고 x = 0 or x =a or y = b or y =0이 성립하는 경우는 모두 가능
            - 예) 6l, 9l
                - 최대 공약수는 3 → 4l는 만들 수 없다
        - 증명
            - x= a or x = 0 or y = b or y = 0 네 가지중 하나가 반드시 성립해야
                - 물을 채운다고 하면 가득 차야지 멈출 수 있음
                - 물을 버리기로 했다면 0리터가 될때까지 전부 다 버려야
                - 한쪽을 반대쪽으로 옮기는 경우, 목적지가 가득 차거나, 출발지가 텅 비어야 멈출 수 있음
            - x % g = 0 and y % g = 0
                - 초기 상태에서는 둘다 0이라 성립. 어떤 상태에서 저 조건이 만족이 되고 있다고 하면 물을 채우든 버리든 옮기든 간에 g의 배수만큼의 변화만 가능
                - x + y = 0, g, 2g, … a+b인 경우를 모두 만들 수 있음
                - 물을 추가할 때는 항상 a리터만큼 추가하고, 버릴 때는 항상 b리터만큼 버리는 작업을 반복할 수 있음
                    - 물의 이동은 a → b 방향으로만 가능
                - 수학 - 정수론의 기본정리중 하나…
                    - am + bn = g가 되는 정수 양수 m, 음수 n이 존재한다는 증명을 이용
                    - a를 m번 더하고, b를 n번 빼면, 남은 양은 g
                    - 위의 과정을 k번 반복하면 남은 양은 kg
                        - 2g를 만든다고 하면 a를 m번 더하고, b를 n번 빼는 과정을 한 번 더 반복
                        - 예) 9l, 6l
                            - 9l 채움 → 왼쪽에 3l만 남기고 오른쪽으로 다 보냄 → 오른쪽 꽉 차서 비움 → 왼쪽에 3, 오른쪽 0
                            - 3l을 오른쪽으로 이동 → 왼쪽 0, 오른쪽 3
                            - 9l 채움 → 왼쪽에 6만 남기고 오른쪽으로 다 보냄 → 오른쪽 꽉 차서 비움 → 왼쪽에 6, 오른쪽 0
                    - x+y = kg가 되고 나면, x= a or x = 0 or y = b or y = 0  조건을 만족시키는 것은 쉬움
    - 4차시 Proximity 문제
        - 어떤 문서와 K개의 키워드에 대해서, K개의 키워드들이 등장하는 위치를 입력 받아서 모든 키워드를 포함하는 가장 작은 영역을 찾아라
        - 정답은 456(3,2,1)
            - 키워드반 보면 045도 될 것 같지만, offset 차이가 최대 5로 정답 2보다 훨씬 크기 때문에 영역도 더 넓다
            
            ![Untitled](Untitled%20122.png)
            
        - 상식적인 알고리즘
            - 각 범위에서 키워드 마다 등장하는 횟수를 세면 확인
                - 한 범위 확인하는 데 (최대) O(N)
                - 시작, 끝점 정하면 하나의 범위 만들어짐. 시작점이 N개, 끝점이 최악의 경우 N까지 될 수 있기 때문에 → O(N**2)
                
                ⇒ 전체 시간은 O(N**3) 
                
            - 동일한 위치에서 시작하고 한 칸만 더 큰 두 영역을 비교
                - 겹치는 영역은 두 번 셀 필요 없음
                - 추가되는 한 칸의 키워드 한 칸만 더 보면 됨. + 1
                
                ⇒ 전체 시간은 O(KN**2)
                
                - 칸이 하나 늘어났을 때, 새 범위에서 모든 단어가 다 등장하는지 확인해야 하는데, 모든 단어가 있는지 확인하기 위해서는 K개의 카운터 변수가 0인지 아닌지를 확인해야
        - O(N)짜리를 만들기 위해서는 증명이 필요
            - candidate range: 모든 키워드를 하나 이상 포함하는 범위
            - critical range: candidate range이면서 다른 candidate range를 내부에 포함하지 않은 것 - 더 이상 줄이면 모든 키워드를 포함하지 못하게 됨
                
                → 정답은 critical range 들 중 하나 
                
        - 증명
            - critical range는 최대 N개 밖에 없다
                - 서로 다른 critical range는 시작점이나 끝점을 공유할 수 없음 → 가능한 시작점의 수가 N개 밖에 없다
            - 모든 critical range를 어떻게 찾을 것인가?
                - r을 오른쪽으로 이동시키면서 l-r 범위가 candidate가 되는지 확인
                - 최초로 candidate 된 r의 지점은 왼쪽에서 첫번째 critical range의 오른쪽 끝
                    - r이 이보다 왼쪽이면 candidate가 아님. 최초로 candidate가 된 지점. 그리고 그 안에는 critical이 있다
                - 여기서 r은 고정한 채로 l을 이동 - 최초로 candidate가 아니게 되는 지점까지 이동했다가, 그 한 칸 앞이 critical range의 왼쪽 경계
                - 같은 과정 반복. r먼저 움직이고, l이 따라서 움직이고…
                - 이 과정에서 현재 범위가 candidate range이지 아닌지를 계속 확인해야 → 확인하는 과정에 k개의 카운터 필요
                    - 각 단어마다 하나씩의 counter가 있어서 현재 범위에 각 단어가 등장하는 횟수를 적어둠
                    - 현재 범위가 candidate인지 확인한다 == counter 값 중에 0이 있는지 없는지 확인한다
                        - 매 critical range에 대해 O(k) 실행하므로 전체 시간은 O(KN)
            - 여기서 K 떼는 방법?
                - 다른 카운터를 하나 둠 - zero
                    - K개의 counter 안에 0이 몇 개 들어 있는지 확인
                    - 어떤 값이 1 → 0으로 바뀌면 zero cnt += 1
                
                ⇒ O(N) 알고리즘 만들 수 있음 
                
        - 키워드가 최소 한번 이상 등장하는게 아니라 뭐 어떤 키워드는 3번 나와야 하고, 어떤 키워드는 2번 이상 나와야 한다 등 키워드 마다 다를 수 있는 경우
            - 비슷한 알고리즘 가능하다
            - zero counter의 의미가 달라져서 필요한 개수가 있냐 확인하는 counter
                - 예) 특정 변수에 대해 0이 될때가 아니라 2→3 or 3→2 변화가 있을 때 변수의 값이 달라지게 됨
    - 5차시 천정화
        - 이탈리아에서 개최된 문제라서 ㅋㅋ 레오나르도 다빈치가 천정화를 그리는 설정… → cache replacement 문제라고 함
            - 두 명의 조수 - a, b.
                - a가 더 똑똑. 내일 물감을 어떤 순서로 사용하는지 알고 있음
                - 비계 위에 없는 물감을 달라고 하면 그 물감을 들고 올라가야 하는데, 그걸 위에 놓고 사용해야 해서 다른 물감을 집어 내려야 함.
                    - 어떤 물감을 집어 내려야 하면, 그 중에 가장 나중에 사용 될 것을 골라야 한다  = 최초 사용 시점이 가장 먼 것
                - 이동 횟수를 최소화하기 위해 어떤 순서로 내리면 되는지 a는 다 계산한 상태
            - 그러나 조수 b가 와서 실제 작업을 한다
                
                ![Untitled](Untitled%20123.png)
                
        - 부분 문제
            1. log n bit로 표현할 수 있는 값의 개수는 n개 
                
                → 물감의 번호를 그냥 log 씌워서 보내면 됨 
                
            2. 비계 위에는 k개의 물감이 있음 
                - log k로 비계 위에 있는 물감을 모두 표현 가능
                - 다만 정확한 값을 주기 위해서는 인덱스로 주거나 소팅을 하거나 할 필요는 있음
                
                여기까지는 a가 만들어놓은 시나리오를 그대로 전달할 수 있었음 
                
            3. 1 bit로 표현할 방법이 있는가? 
                
                ![Untitled](Untitled%20124.png)
                
                - 최초 사용 시점이 가장 먼 것을 생각하면 5
                    - 2,3,5,8은 비계 위에 있는 물감들
                    - 10, 11, 12 순서로 다빈치가 달라고 함
                    - request 안에는 3,5,8이 등장하지 않음
                    - 그림이 좀 이상한 것 같은데 request 앞의 원소는 뭘 의미한는지 모르겠음 ;;
                        - 다만 request 뒤로 가장 멀리 있는 게 5이고, 그게 5의 최초 사용 시점이면 가장 나중에 사용됨을 의미
                    
                    → 5를 집어내리고 나면 2, 3, 5, 10이 있고 다음 request로 11이 들어오면,  최초 사용 시점이 가장 먼 것은 8 → … 
                    
                - 아래 쪽 그림
                    - 5번 대신 8번을 집어내렸음을 알 수 있음
                    - 우리는 물감이 교환되는 횟수를 측정하고 있음
                    - 5번 대신 8번을 내려도 최소 비용이 달라지지 않는다면…
                        - 10번 request 들어온 시점에 5번을 내려서 최소 비용이 되는 이유는 내려 갔다가 올라 올 것이기 때문
                        - 근데 8번도 다음 번 사용될 때 내려 갔다가 올라오면서 사용이 됨 → 8번을 지금 내리더라도 나중에 다시 올라오는 것은 원래 필요한 비용이기 때문에 비용을 증가시키지 않음
                        - 그 다음 11번 request가 들어왔을 때 여전히 5번은 내리지 않고, 8번 다음으로 최소 사용 시점이 멀었던 3번을 집어내려도 3번은 다음 번에 사용될 때 다시 올라오면서 사용될 것이기 때문에 5번을 내리는 것과 비교해서 비용이 더 늘어나지는 않음
                - 해답 for 부분문제 3
                    
                    ![Untitled](Untitled%20125.png)
                    
                    - 2번은 지금 시점에 사용되지 않지만, 나중에 사용되는데, 제자리에서 사용되어야 함 - 사용될 때까지 자리에 유지가 되어야 함
                    - 3, 5, 8은 사용 시점에 다시 올라오면서 사용됨- 지금 내려도 괜찮음
                    
                    ⇒ 0 1 1 1 로 표현 가능. 1bit로 표현 가능. 10 request가 왔을 때 3, 5, 8 중 아무거나 가지고 내려가도 OK 
                    
                    ⇒ 이 4개의 bit를 다 전달할 필요도 없음. 다음번에 11번에 대한 요청이 왔을 때도 2는 나중에 제자리에서 사용된다는 게 불변→ 2의 bit는 달라지지 않음 
                    
                    - bit의 의미
                        - 지금 시점에 1이 써있다는 것은 다음번 사용 시점 사이에 내려갔다가 올라오는 게 있다는 뜻
                        - 지금 사용되는 물감에 대해서만 다음번 시점을 지정하면 됨
                        - 2가 0인 상태로 최초 사용 되고, 그 다음 사용전까지는 한번 내려갔다가 올라와야 하면 bit가 1로 바뀌어야 함
                        - 실제로 사용이 되는 물감에 대해서 다음 번 사용되는 시점 사이에 내려갔다-올라오는 일이 있는지 없는지를 표시해주면 됨 → 1 bit면 가능하다
                - A가 계산하는 특정한 전략 - 이것이 최적이라는 증명이 있다고 문제에서 제시, 그러나 그것만 가지고 문제를 다 풀 수는 없음 -
                    
                    ![Untitled](Untitled%20126.png)
                    
                    - 여러개의 서로 다른 최적 전략이 증명 과정에서 등장하고, 그 전략들이 갖는 공통 특징이 뭔지 파악
                - MST에 대한 사례
                    - 여러 개일 수 있는 정답 중 아무거나 하나 세팅 → 프림 알고리즘이 추가하는 edge를 계속 비교
                        - 그러나 입력 그래프의 edge weight가 전부 다르면, 답이 유일하다
                    - 갑자기 알고리즘이 정답에 없는 edge를 추가해버리면, 알고리즘이 정답을 찾는다는 것을 증명해야 함
                        - 정답과 알고리즘이 추가한 edge를 겹쳐놓으면 cycle이 생김 → 지금 알고리즘이 추가한 edge와 추가하지 않은 edge를 찾을 수 있음 → 두 edge의 weight가 같다는 것을 증명할 수 있음
    - 6차시 뜬금없는 greedy 알고리즘
        
        ![Untitled](Untitled%20127.png)
        
        - shortest path 하나를 구할 때는 다익스트라 쓰면 되지만
        
        ![Untitled](Untitled%20128.png)
        
        -