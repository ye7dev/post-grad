# 나무 자르기 예제

- 어쨌든 생각하면 이진 코드 제대로 짜본건 처음이네
- Trial
    
    ```python
    def binary_search():
        max_height = max(heights)
        # 0 -> gain: sum(heights) (>= M) -> always True
        # max_height -> gain = 0 (< 1 <= M) -> always False
        low, high = 0, max_height
        while low + 1 < high:
            mid = (low + high) // 2
            cur_gain = sum([max(0, h-mid) for h in heights])
            print(cur_gain, mid)
            if cur_gain < M: # mid에서의 결정값이 False -> 더 낮게 자른다
                high = mid - 1
            else: # mid에서 결정값이 True -> 더 높게 자른다
                low = mid + 1
        return low
    
    N, M = map(int, input().split())
    heights = list(map(int, input().split()))
    print(heights)
    ans = binary_search()
    print(ans)
    
    ```
    
- 시간 초과 간신히 피한 AC 코드
    
    ```python
    import sys
    def binary_search():
        max_height = max(heights)
        # 0 -> gain: sum(heights) (>= M) -> always True
        # max_height -> gain = 0 (< 1 <= M) -> always False
        low, high = 0, max_height
        while low + 1 < high:
            mid = (low + high) // 2
            # time save
            cur_gain = sum([h - mid for h in heights if h > mid])
            if cur_gain < M: # mid에서의 결정값이 False(high랑 같음) -> 더 낮게 자른다
                high = mid
            else: # mid에서 결정값이 True(low랑 같음) -> 더 높게 자른다
                low = mid
        return low
    
    input = sys.stdin.readline
    N, M = map(int, input().split())
    heights = list(map(int, input().split()))
    ans = binary_search()
    print(ans)
    
    ```
    
    - 시간을 줄이는 각종 꿀팁
        - 함수를 따로 빼지말고 바로 구한다
        - 높이의 한계가 이미 정해져있기에 연산이 O(N)인 max대신 하드코딩한다 → 글쎄…득실이 있는 것 같다