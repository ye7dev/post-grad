# 1258. [S/W 문제해결 응용] 7일차 - 행렬찾기

Created time: May 2, 2024 10:03 AM
Last edited time: May 2, 2024 3:00 PM

- 문제 이해
    - 하나의 용기에 담긴 화학 물질의 종료가 모두 같은 것은 아니다
    - 부분 행렬이 총 몇 개인지, 각 행렬의 행, 열 개수 나열
        - 크기가 작은 순서대로 출력
        - 크기가 같을 경우 행이 작은 순으로 출력
- scratch
    - 방문 처리를 어디서 해줘야 할지 늘 고민
        - backtracking 해야 하는가? 아니 그냥 0이면 바로 나가면 되지
        - 그럼 방문 처리를 안에서 해줘도 될 듯?
    - visited 따로 안쓰고 matrix 내에서 해결하면 공간복잡도 더 줄일 수 있겠지만 우선은 생각이 안남으로 그냥 넘어간다
- Trial
    
    ```python
    def find_submatrix(cell_val, x, y):
        # base case
        if matrix[x][y] == 0:
            return
    
        matrix[x][y] = -1
    
        if x == num_row-1 and y == num_row-1:
            start_x, start_y = start_dict[cell_val]
            ans.append((x - start_x, y - start_y))
            return
    
        if x < num_row-1 and y < num_row-1:
            if matrix[x+1][y] == 0 and matrix[x][y+1] == 0:
                start_x, start_y = start_dict[cell_val]
                ans.append((x - start_x, y - start_y))
                return
    
        if y < num_row-1:
            find_submatrix(cell_val, x, y+1)
        if x < num_row-1:
            find_submatrix(cell_val, x+1, y)
    
    T = int(input())
    for t in range(1, T+1):
        N = int(input())
        matrix = []
        for _ in range(N):
            row = list(map(int, input().split()))
            matrix.append(row)
        num_row, num_col = len(matrix), len(matrix[0])
        #visited = [[-1] * num_col for _ in range(num_row)]
        ans = []
        start_dict = {}
        count = 0
        for i in range(num_row):
            for j in range(num_col):
                if matrix[i][j] > 0:
                    start_dict[count] = (i, j)
                    find_submatrix(count, i, j)
                    count += 1
        ans.sort(key=lambda x: x[0]*x[1], reverse=True)
    
        rc_info = []
        for a in ans:
            r, c = a
            rc_info.append(str(r))
            rc_info.append(str(c))
    
        print(f'#{t} {len(ans)} {" ".join(rc_info)}')
    
    ```
    
- DFS vs. while loop
    - 우선 DFS로 제대로 구현을 못했지만…차차 하기로 하고…
    - 문제에서 보면 submatrix는 늘 직사각형이다 → 이러면 가로로 쭉 탐색하고, 세로로 쭉 탐색한 뒤 0이 되자마자 멈추면 된다
    - 그러나 직사각형이 아니고 섬 같이 경계가 구불구불한 경우 → DFS 써야 한다
    - [x]  DFS로 짜보기
    - [x]  while loop으로 짜보기
- AC 코드
    - while loop이 확실히 빠르고, 공간도 덜 차지 한다
    - DFS
        
        ```python
        def find_submatrix(start_key, x, y):
            # base case
            if x >= num_row or y >= num_col:
                return 0, 0
            if matrix[x][y] == 0 or visited[x][y]:
                return 0, 0
        
            visited[x][y] = 1
        
            # recursive call
            next_valid_row, _ = find_submatrix(start_key, x+1, y)
            _, next_valid_col = find_submatrix(start_key, x, y+1)
        
            # plus current row, col
            cur_row = 1 + next_valid_row
            cur_col = 1 + next_valid_col
        
            # sort of backtracking...?
            start_x, start_y = start_dict[start_key]
            if x == start_x and y == start_y:
                ans.append([cur_row, cur_col])
        
            return cur_row, cur_col
        
        T = int(input())
        for t in range(1, T+1):
            N = int(input())
            matrix = []
            for _ in range(N):
                row = list(map(int, input().split()))
                matrix.append(row)
            num_row, num_col = len(matrix), len(matrix[0])
            visited = [[0] * num_col for _ in range(num_row)]
            ans = []
            start_dict = {}
            count = 0
            for i in range(num_row):
                for j in range(num_col):
                    if visited[i][j] == 0:
                        start_dict[count] = (i, j)
                        find_submatrix(count, i, j)
                        count += 1
            ans.sort(key=lambda x: (x[0]*x[1], x[0]))
            rc_info = []
            for a in ans:
                r, c = a
                rc_info.append(str(r))
                rc_info.append(str(c))
        
            print(f'#{t} {len(ans)} {" ".join(rc_info)}')
        
        ```
        
           
        
    - While loop
        
        ```python
        def find_submatrix(x, y):
            # x, y는 늘 유효한 input만 들어온다
            cur_row, cur_col = 0, 0
        
            while x + cur_row < num_row:
                if not visited[x + cur_row][y] and matrix[x + cur_row][y] != 0:
                    cur_row += 1
                else:
                    break
        
            while y + cur_col < num_col:
                if not visited[x][y + cur_col] and matrix[x][y + cur_col] != 0:
                    cur_col += 1
                else:
                    break
        
            for i in range(x, x + cur_row):
                for j in range(y, y + cur_col):
                    visited[i][j] = 1
        
            ans.append((cur_row, cur_col))
        
        T = int(input())
        for t in range(1, T+1):
            N = int(input())
            matrix = []
            for _ in range(N):
                row = list(map(int, input().split()))
                matrix.append(row)
            num_row, num_col = len(matrix), len(matrix[0])
            visited = [[0] * num_col for _ in range(num_row)]
            ans = []
            for i in range(num_row):
                for j in range(num_col):
                    if not visited[i][j] and matrix[i][j] != 0:
                        find_submatrix(i, j)
            ans.sort(key=lambda x: (x[0]*x[1], x[0]))
            rc_info = []
            for a in ans:
                r, c = a
                rc_info.append(str(r))
                rc_info.append(str(c))
        
            print(f'#{t} {len(ans)} {" ".join(rc_info)}')
        
        ```
        
- While loop으로 제대로 안 짜진 이유
    
    ```python
    cur_row, cur_col = 0, 0
    
    while x + cur_row < num_row:
        if not visited[x + cur_row][y] and matrix[x + cur_row][y] != 0:
            cur_row += 1
        else:
            break 
    ```
    
    - cur_row가 0이고 if 조건 만족 안하면 cur_row는 그대로 0
    - cur_row가 1이고 if 조건 만족 안하면 cur_row는 그대로 1
    - cur_row가 num_row-1이고 조건 만족하면 cur_row는 num_row
        
        → while loop break 
        
    
    ⇒ 늘 마지막으로 유효한 값보다 1크다