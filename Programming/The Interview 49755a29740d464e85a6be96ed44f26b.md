# The Interview

- final cram! 하루 3-4시간씩 하면 한 주 안에 책 끝낼 수 있다고 함
- class project, thesis 포함한 github 만들기
- 자료 구조 요약
    - primitive types: 서로 다른 자료형이 메모리에 어떻게 표현되는지, primitive operation(O(1) 걸리는 연산-사칙연산, 대입, indexing, function call, return)이 어떻게 적용되는지
    - array: indexing 빠름, 정렬 안되어 있으면 값으로 lookup 하는 거랑 삽입 느림, partitioning, merging 개념 익숙해져야
    - strings: string이 메모리에 어떻게 표현되는지
    - (linked) lists: array와 달리 데이터가 비연속적으로 저장. singly, double linked list. array → list 구현, dynamic allocation 구현 학습
    - stack & queue: stack은 LIFO, queue는 FIFO. array, linked list 각 버전의 구현, monotonic stack & queue
    - binary trees: 위계적인 데이터 표현에 사용, depth, height, leaves, search path, traversal sequence, successor/predecessor operations
    - heaps: O(1) max lookup, O(log n) 삽입, 삭제. node & array representations, min heap 변형
    - hash tables: O(1) 삽입, 삭제, 탐색. 약점: order-related queries에 부적합. Resizing 필요, worst-case performance, bucket array와 collision chain 사용한 구현, int, str, objects에 대한 hash function 학습
    - binary search trees: height balanced tree인 경우 O(log n) 삽입, 삭제, 탐색, find-max, successor, predecessor. node fields, pointer implementation 이해. balance 개념 및 balance 유지하는 연산 학습
    
- 알고리즘 요약
    - sorting: input을 정렬하면서 특정 구조를 uncover
    - recursion: input의 구조가 재귀적인 방식으로 정의되면, 그에 따른 재귀 알고리즘 설계
    - divide-and-conquer: 문제를 두 개 이상의 독립적인 하위 문제로 분할 → 하위 문제들의 solution을 가지고 원래 문제를 해결
    - dynamic programming: 주어진 문제의 더 작은 instances에 대한 solution 계산한 뒤, 이 solution을 가지고 원래 문제에 대한 solution construct. performance 위에 캐싱
    - greedy: 단계적으로 하나의 solution을 계산. 각 단계에서 최적의 선택. 각 선택은 절대 undone 될 수 없음
    - invariants: invariant(알고리즘의 실행 과정에서 항상 참으로 유지되는 조건이나 속성)을 찾고, 다른 solution들의 지배를 받거나 그보다 suboptimal한 잠재적 solution은 제외해나간다
    - graph modeling: graph를 사용해서 문제를 서술하고, 그래프 알고리즘을 이용해서 문제 해결
- complexity
    - 알고리즘 실행 시간은 input 사이즈에 비례. input size에 대한 실행시간의 의존성을 나타내기 위한 방식
    - input size를 파라미터로 하는 함수로 최악의 경우 실행 시간을 asymptotic bounds로 표현
        - O(f(n)) → n이 충분히 클 때 이 실행시간은 f(n) * 어떤 상수를 넘지 않을 것
    - 공간의 경우
        - O(1) 의 공간복잡도를 가진 알고리즘은 dynamic memory allocation을 수행하지 않아야
        - function call stack의 maximum depth도 input의 크기에 상관 없이 상수가 되어야
        - dynamic allocation을 수행하지 않는 알고리즘의 예시- DFS search of a graph
            - implicit storage로 function call stack 사용. 이 때 공간복잡도 ≠ O(1)
    - Streaming 알고리즘
        - input data: a sequence of items
        - 입력 데이터를 순차적으로 한 번에 한 요소씩 제한된 메모리를 사용하여 제한된 시간 안에 처리
        - 로그 파일 데이터에 대해 aggregation query를 수행할 때 유용
- 인터뷰 팁
    - 어떤 시간/공간복잡도로 풀길 원하는지 물어보기
    - brute-force solution이 보통 있는 문제이고, 가능한 모든 조합을 먼저 시도해보는 게 좋음
        - 최적화 단계로 넘어가는 과정을 보여줄 수 있음. 그러나 너무 많은 시간 쏟으면 노노
    - Thinking out loud: stay engaged. solution 찾을 확률도 높아지고, 면접관이 도움을 줄 수도 있음
    - 문제가 특정 알고리즘이나 자료 구조에 맞을지 pattern 파악
        - divide-and-conquer, recursion, dp, mapping problem to a graph
- solution 발표 팁
    - 라이브러리 사용은 좋은 것 - do not reinvent the wheel
    - top-level algorithm에 집중 - 세부 함수 구현은 나중에 해도 된다
        - todo comment 같은 것을 추가
    - 화이트보드 사용 관리 - 함수나 변수 이름 짧게, 왼쪽 구석부터 써라
    - valid input을 가정
    - 코너 케이스 테스트 - 빈 array, overflow,
    - 메모리 관리 - linked list 문제들은 O(1) 공간복잡도로 풀리기도
    - 코드가 50줄보다 길면 잘못된 방향일수도