# 1248. [S/W 문제해결 응용] 3일차 - 공통조상

Created time: April 11, 2024 5:27 PM
Last edited time: April 12, 2024 12:09 AM

- Trial
    - Binary Lifting 끙끙거렸으나 예제 3개만 맞음 ;;
        
        ```python
        import math
        import sys
        sys.stdin = open("input.txt", "r")
        
        def recur(cur_node, cur_parent, cur_depth):
            parent[cur_node] = cur_parent
            depth[cur_node] = cur_depth
            subtree_size[cur_node] = 1
            for next_node in graph[cur_node]:
                if next_node != cur_parent:
                    subtree_size[cur_node] += recur(next_node, cur_node, cur_depth + 1)
            return subtree_size[cur_node]
        
        def get_lca(a, b):
            if depth[a] < depth[b]:
                a, b = b, a
            # 깊이 맞추기
            while depth[a] != depth[b]:
                diff = depth[a] - depth[b]
                for i in range(max_depth, -1, -1):
                    if (1 << i) <= diff:
                        a = dp[a][i]
                        break
            if a == b:
                return a
            for i in range(max_depth, -1, -1):
                if dp[a][i] != -1 and dp[a][i] != dp[b][i]:
                    a = dp[a][i]
                    b = dp[b][i]
            return parent[a]
        
        T = int(input())
        for t in range(1, T+1):
            V, E, A, B = map(int, input().split())
            edges = list(map(int, input().split()))
        
            depth = [0] * (V + 1)
            parent = [-1] * (V + 1)
            subtree_size = [0] * (V + 1)
            graph = {i: [] for i in range(1, V+1)}
        
            for i in range(0, E*2, 2):
                p, c = edges[i], edges[i+1]
                graph[p].append(c)
                graph[c].append(p)
        
            # populate depth, parent, subtree_size
            subtree_size[1] = recur(1, -1, 0)
        
            max_depth = math.floor(math.log2(V)) + 1
            dp = [[-1] * (max_depth + 1) for _ in range(V+1)]
            # base case
            for i in range(1, V+1):
                dp[i][0] = parent[i]
            # iterative case
            for i in range(1, V+1):
                for j in range(1, max_depth+1):
                    if dp[i][j-1] != -1:
                        dp[i][j] = dp[dp[i][j-1]][j-1]
        
            lca = get_lca(A, B)
            print(f'#{t} {lca} {subtree_size[lca]}')
        
        ```
        
- AC 코드
    - 클라스만 하나 정의하면 되었던 것을…
    
    ```python
    import math
    class Node:
        def __init__(self, val):
            self.val = val
            self.left = None
            self.right = None
    
    def recur(cur_node, cur_parent):
        if not cur_node:
            return 0
        parent[cur_node.val] = cur_parent.val
        subtree_size[cur_node.val] = 1
        subtree_size[cur_node.val] += recur(cur_node.left, cur_node)
        subtree_size[cur_node.val] += recur(cur_node.right, cur_node)
        return subtree_size[cur_node.val]
    
    def find_LCA(root, p, q):
        if root in (p, q, None):
            return root
        left = find_LCA(root.left, p, q)
        right = find_LCA(root.right, p, q)
        return root if (left and right) else (left or right)
    
    T = int(input())
    for t in range(1, T+1):
        V, E, A, B = map(int, input().split())
        nodes = [Node(i) for i in range(0, V + 1)]
        edges = list(map(int, input().split()))
    
        parent = [-1] * (V + 1)
        subtree_size = [0] * (V + 1)
        graph = {i: [] for i in range(1, V+1)}
    
        for i in range(0, E*2, 2):
            p, c = nodes[edges[i]], nodes[edges[i+1]]
            if not p.left:
                p.left = c
            else:
                p.right = c
    
        # populate depth, parent, subtree_size
        subtree_size[1] = recur(nodes[1], nodes[0])
    
        lca = find_LCA(nodes[1], nodes[A], nodes[B])
        print(f'#{t} {lca.val} {subtree_size[lca.val]}')
    ```