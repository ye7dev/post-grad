# 1257. [S/W 문제해결 응용] 6일차 - K번째 문자열

Created time: May 5, 2024 11:07 AM
Last edited time: May 6, 2024 9:03 PM

- Lessons - 풀이 정리
    1. 모든 substring에 대해 root의 바로 자식으로 추가해준다 
        - 이렇게 하면 같은 start character로 시작하는 substring들은 하나의 branch에 속한다
    2. 한 번 이상 본 char에 대해서는 추가 count 하지 않는다 
        - 이게 가능하려면 lovelike에 나오는 두 개의 l이 하나의 node로만 표현이 되어야 한다
    3. 모든 child node들은 알파벳 순으로 정렬이 되어 있어야 한다 
        - 그때그때 정렬하면 시간 오래걸리니까 그냥 alphabet array를 만들어서 있으면 1, 없으면 0으로 표시
- 문제 이해
    - 부분 문자열 -start, end 모두 고정되어 있지 않음 ↔ prefix, suffix
    - 동일한 substring은 중복 제거
    - 부분 문자열을 사전 순서대로 나열했을 때 K번째 오는 문자열
- scratch
    
    진짜 Trie를 쓰는 문제인듯 
    
    아니다 set으로 unique char 구한 다음, 알파벳 순으로 제일 먼저 오는 char과 거기서 시작하는 모든 substring 훑는다 (그건 trie로)
    
    - 사전 조건 그 char에서 시작하는 suffix는 뒤가 다 살아있는 경우인데 char + suffix길이가 K보다 작으면 탐색. 아니면 그 다음 char로 넘어가야 할 듯?
    - 훑는 건 char 하나 늘어날 때마다 +1해서 K도달하면 끝
    - index = 1, len(x) = 8 → 8-1 = 7
        - start~len(x)-1까지 두 경계 모두 inclusive
            
            → len(x)-1-start + 1 = len(x)-start 개의 substring 가능 
            
- Trial
    - 예제랑 5/10까지 맞음
        - 해결 안된 부분: 예를 들어 r이 두 개 나온다고 할 때, 첫번째 r 자리에서 있을 수 있는 부분 string 모두 커버했는데, 두번째 r 자리의 경우의 수는 count가 안됨
        - r이 들어가는 인덱스를 모두 구해서 for loop을 두번 돌아야 하려나? 비효율적일 것 같은데 우선 그렇게 해보자
        
        ```python
        import sys
        sys.stdin = open('temp_input/input.txt', 'r')
        
        class TrieNode:
            def __init__(self, key=None, data=None):
                self.key = key
                self.data = data
                self.children = {}
        
        class Trie:
            def __init__(self):
                self.head = TrieNode()
        
            def insert(self, string):
                cur_head = self.head
                for char in string:
                    if char not in cur_head.children:
                        cur_head.children[char] = TrieNode(char)
                    cur_head = cur_head.children[char]
                if cur_head.data is None:
                    cur_head.data = string
        
            def search(self, string):
                cur_head = self.head
                for char in string:
                    if char not in cur_head.children:
                        return False
                    cur_head = cur_head.children[char]
                if cur_head.data is None:
                    return False
                return True
        
        def get_kth_substring():
            N = len(string)
            chars = list(set(string))
            chars.sort()
            cnt = 0
            for i, c in enumerate(chars):
                start = string.index(c)
                cnt += N - start
                if cnt > K:
                    break
                if cnt == K:
                    return string[start:]
        
            print(t, cnt, K)
            if cnt < K:
                return 'none'
            else:
                cnt -= (N - start)
        
            string_tree = Trie()
            string_tree.insert(string[start:])
            cur_head = string_tree.head
            res = ""
            while cnt < K:
                for key in cur_head.children:
                    cur_head = cur_head.children[key]
                cnt += 1
                res += cur_head.key
            return res
        
        T = int(input())
        for t in range(1, T+1):
            K = int(input())
            string = input()
            ans = get_kth_substring()
            print(f'#{t} {ans}')
        ```
        
    - 모든 시작점에 대해 다 구해봤는데 여전히 5개는 답이 안나옴
        
        ```python
        import sys
        sys.stdin = open('temp_input/input.txt', 'r')
        
        class TrieNode:
            def __init__(self, key=None, data=None):
                self.key = key
                self.data = data
                self.children = {}
        
        class Trie:
            def __init__(self):
                self.head = TrieNode()
        
            def insert(self, string):
                cur_head = self.head
                for char in string:
                    if char not in cur_head.children:
                        cur_head.children[char] = TrieNode(char)
                    cur_head = cur_head.children[char]
                if cur_head.data is None:
                    cur_head.data = string
        
            def search(self, string):
                cur_head = self.head
                for char in string:
                    if char not in cur_head.children:
                        return False
                    cur_head = cur_head.children[char]
                if cur_head.data is None:
                    return False
                return True
        
        def get_kth_substring():
            N = len(string)
            chars = list(set(string))
            chars.sort()
            start_dict = {c:[] for c in chars}
            for i in range(N):
                char = string[i]
                start_dict[char].append(i)
        
            cnt = 0
            for key in start_dict:
                for start_idx in start_dict[key]:
                    cnt += N - start_idx
                    if cnt > K:
                        break
                    elif cnt == K:
                        return string[start_idx:]
                if cnt > K:
                    break
        
            if cnt < K:
                return 'none'
            else:
                cnt -= (N - start_idx)
        
            string_tree = Trie()
            string_tree.insert(string[start_idx:])
            cur_head = string_tree.head
            res = ""
            while cnt < K:
                for key in cur_head.children:
                    cur_head = cur_head.children[key]
                cnt += 1
                res += cur_head.key
            return res
        
        T = int(input())
        for t in range(1, T+1):
            K = int(input())
            string = input()
            ans = get_kth_substring()
            print(f'#{t} {ans}')
        ```
        
    - [x]  동일한 문자열 o가 두번 나오지만, 중복을 제거한 것에 유의하자. 이 단서를 빼먹은 것 같다
    - 다른 코드 보고 이해해서 짰는데 답이 안나옴
        
        ```python
        # import sys
        # sys.stdin = open('temp_input/input.txt', 'r')
        
        class TrieNode:
            def __init__(self, key=None, data=None):
                self.key = key
                self.children = [0] * 26
                self.seen = False
        
        class Trie:
            def __init__(self):
                self.head = TrieNode()
            def insert(self, string):
                cur_node = self.head
                for char in string:
                    char_idx = ord(char) - ord('a')
                    if cur_node.children[char_idx] == 0:
                        cur_node.children[char_idx] = TrieNode(char)
                    cur_node = cur_node.children[char_idx]
        
        def recur(cur_node, substring):
            global total_cnt
            if cur_node.seen is False:
                total_cnt += 1
            if total_cnt == K:
                print(substring)
                return substring
        
            for i in range(26):
                if cur_node.children[i]:
                    cur_char = chr(i + ord('a'))
                    temp = recur(cur_node.children[i], substring + cur_char)
                    if temp:
                        break
        
            if total_cnt < K:
                return None
        
        T = int(input())
        for t in range(1, T+1):
            K = int(input())
            string = input()
            string_trie = Trie()
            total_cnt = 0
            ans = None
            for i in range(len(string)):
                string_trie.insert(string[i:])
            for i in range(26):
                if string_trie.head.children[i]:
                    ans = recur(string_trie.head.children[i], "")
                    if ans is not None:
                        break
            if ans is None:
                ans = 'none'
            print(total_cnt)
            print(f'#{t} {ans}')
        ```
        
- 남의 코드 이해하기
    - [x]  TRIE를 사용하는 이유는 입력과 동시에 자동으로 정렬하는 효과를 볼 수 있기 때문이다.
    - [x]  순회하며 순서대로 탐색하기 때문이다.
    
    ```python
    class TrieNode:
        def __init__(self):
            self.check = False # 중복된 문자 확인을 위해 
            self.next = [None] * 27 # children
    
    def make_node():
        return TrieNode()
    
    def insert(root, buff, st, ed): # buff: string, st: i, ed: N 
        if st == ed:
            return
        index = ord(buff[st]) - ord('a')
        if root.next[index] is None:
            root.next[index] = make_node()
        insert(root.next[index], buff, st + 1, ed)
    
    def find(root, result, cnt, K): # 초기 result: 빈 리스트 
        if cnt[0] == K:
            flag[0] = True
            return
        for i in range(27):
            if root.next[i]: # child 돌아가면서 
                result.append(chr(i + ord('a')))
                if not root.next[i].check:
                    cnt[0] += 1
                # 재귀함수 
                find(root.next[i], result, cnt, K)
                if flag[0]:
                    return
                result.pop() # backtracking - 답이 아닌 문자열이라서 빼고 다음 문자열 들어가도록? 
    
    def main():
        T = int(input("Enter number of test cases: "))
        for tc in range(1, T + 1):
            K = int(input("Enter K value: "))
            arr = input("Enter the characters: ")
            len_arr = len(arr)
            root = make_node()
            for i in range(len_arr):
                insert(root, arr, i, len_arr)
            result = []
            cnt = [0]
            flag[0] = False
            find(root, result, cnt, K)
            if result:
                print(f"#{tc} {''.join(result)}")
            else:
                print(f"#{tc} none")
    
    if __name__ == "__main__":
        main()
    
    ```
    
- 중복 문자가 있는 경우
    - 내 생각
        
        lovelove
        
        앞 love, 뒷 love는 하나로 쳐야 한다 
        
        trie가 어떻게 생기냐 하면 
        
        l-o-v-e
        
        e에서 다시 l로 넘어가려나? 
        
        → Trie 자료구조에서는 같은 문자가 반복되더라도 해당 문자의 위치가 다르면 별도의 노드를 생성합니다
        
    - 남의 코드에서는 이렇게 처리했다
        
        root - l - o - v- e 
        
        대신 e의 next[l의 index] = l 노드
        
        뒤의 love는 count에 영향을 주지 못한다. l, o, v, e가 처음 보는 그 순간에만 count를 하기 때문 
        
        lovelike의 경우
        
        root - l - o - v - e 
        
                   ➘ - i - k - ➚
        
        그리고 dfs를 통해 탐방 
        
        → 근데 이러면 단어가 어디서 끝나는지 알길이 없음 
        
        정확히 말하면 한 글자씩 추가한게 아니라 각 substring을 모두 추가했다 root에다가 
        
        root - l-ovelike
        
              -ike
        
        root - ovelike
        
        root - velike
        
        root - e - like
        
        root - ike
        
        root - ke
        
        → 이렇게 하면 중복 문자인 l 같은 것에 대해 두번 count 되지 않음 
        
        - 또 다른 예로 해보자 poooh
            - root-poooh
            - root-oooh
                
                             -h
                
                           -h
                
            - root-h
            
            → 이렇게 하면 oo도 두번 카운트 되지 않음 원래는 oo도 두번 나올 수 있지만…!  
            
    
- AC 코드
    - 놓쳤던 점
        1. 한 번 본 노드는 봤다고 marking 하는 것 
        2. 현재 노드 처리할 때, substring에 이번 노드의 key값 안 붙여준 것 
        3. for loop으로 재귀콜 다하고 나서도 답이 안나오면 None return 하는 것 
    
    ```python
    import sys
    sys.stdin = open('temp_input/input.txt', 'r')
    
    class TrieNode:
        def __init__(self, key=None, data=None):
            self.key = key
            self.children = [0] * 26
            self.seen = False
    
    class Trie:
        def __init__(self):
            self.head = TrieNode()
        def insert(self, string):
            cur_node = self.head
            for char in string:
                char_idx = ord(char) - ord('a')
                if cur_node.children[char_idx] == 0:
                    cur_node.children[char_idx] = TrieNode(char)
                cur_node = cur_node.children[char_idx]
    
    def recur(cur_node, substring):
        global total_cnt
        temp_string = substring + cur_node.key
        if cur_node.seen is False:
            cur_node.seen = True
            total_cnt += 1
    
        if total_cnt == K:
            return temp_string
    
        for i in range(26):
            if cur_node.children[i] != 0:
                temp = recur(cur_node.children[i], temp_string)
                if temp is not None:
                    return temp
    
        return None
    
    T = int(input())
    for t in range(1, T+1):
        K = int(input())
        string = input()
        string_trie = Trie()
        total_cnt = 0
        ans = None
        for i in range(len(string)):
            string_trie.insert(string[i:])
        for i in range(26):
            if string_trie.head.children[i] != 0:
                ans = recur(string_trie.head.children[i], "")
                if ans is not None:
                    break
        if ans is None:
            ans = 'none'
        print(f'#{t} {ans}')
    ```
    
- DFS를 재귀함수 안 쓰고 stack으로 구현하는 방법
    - 자식을 알파벳 순으로 노드 배치해서 정렬 안하고 바로 쓸 수 있음
    - 재귀함수 안쓰고 stack으로 바로 쓸 수 있음
        - 다만 index 역순으로 넣어야 함
        - lovelike라고 하면 lovelike까지 쭉 갔다가 그 다음 다시 i에서 시작. l은 이미 count되어서 중복 계산안됨
        - 사전 순으로 자식 추가하고 꺼내서 쭉 갔다가 돌아와서 다음 자식으로 가는 거라 backtrack 필요 없음
    
    ```python
    import sys
    sys.stdin = open('temp_input/input.txt', 'r')
    
    class TrieNode:
        def __init__(self, key=None, data=None):
            self.key = key
            self.children = [0] * 26
            self.seen = False
    
    class Trie:
        def __init__(self):
            self.head = TrieNode()
        def insert(self, string):
            cur_node = self.head
            for char in string:
                char_idx = ord(char) - ord('a')
                if cur_node.children[char_idx] == 0:
                    cur_node.children[char_idx] = TrieNode(char)
                cur_node = cur_node.children[char_idx]
    
    def dfs(root):
        total_cnt = 0
        stack = []
        for i in range(25, -1, -1):
            if root.children[i] != 0:
                stack.append((root.children[i], root.children[i].key))
    
        while stack and total_cnt < K:
            cur_node, cur_str = stack.pop()
            total_cnt += 1
            for i in range(25, -1, -1):
                if cur_node.children[i] != 0:
                    stack.append((cur_node.children[i], cur_str + cur_node.children[i].key))
    
        if not stack:
            return None
        else:
            return cur_str
    
    T = int(input())
    for t in range(1, T+1):
        K = int(input())
        string = input()
        string_trie = Trie()
        for i in range(len(string)):
            string_trie.insert(string[i:])
        ans = dfs(string_trie.head)
        if ans is None:
            ans = 'none'
        print(f'#{t} {ans}')
    ```