# 1494. 사랑의 카운슬러

Created time: May 1, 2024 5:19 PM
Last edited time: May 2, 2024 10:01 AM

- Lesson
    1. 모든 벡터의 합을 구한 뒤, 제곱을 한 값이 후보 return 값인 상황 
        - 점 a, b, c, d가 있을 때 (a, b) 사이의 벡터를 구하고, (c, d) 사이의 벡터를 구한 뒤 더하는 순차적인 방법도 있지만
        - 생각해보면 a-b + c-d = a + c - (b + d)
        - 점이 더 많은 상황을 생각해보면, a, b, c, d, e, f → a-f, b-e, c-d가 각 쌍을 이룰 때, 벡터 합은 (a-f) + (b-e) + (c-d) = (a + b + c) - (c + d + e)
        - 점이 더더 많은 상황을 생각해보면
            - (n//2 개)  - ( n//2 개)
            - 앞부분을 모두 더하고, 뒷부분을 모두 더한 걸 한 번에 빼도 결과는 같다
    2. n개에서 n//2개 뽑기 
        - itertools.combinations 모듈 쓰는 방법
        - 재귀함수-backtracking-으로 구하는 방법
            - parameter: visited, index, num_pairs
                - visited: 해당 인덱스를 이미 처리했는지 안했는지 알려줌
                - index: 이번에 처리하고 넘어갈 자리
                - num_pairs: 총 쌍을 몇 개를 지어줬는지
            - base case
                - pair 개수가 총 N//2개가 되면 현재 상태에서 작업 수행 → global 변수랑 비교해서 더 값이 작은지 확인
                - 작업 수행 부분은 별도 함수로 빼도 되고, 안에서 짜도 됨
                - 작업 수행 내용
                    - 좌표는 x, y로 구성되고, 벡터 크기 계산 전에는 앞부분 다 더한 좌표 - 그 짝꿍들 다 더한 좌표가 나와야 한다
                    - 앞부분 다 더한 좌표: visited array에서 값이 1인 index에 해당하는 좌표들만 다 더한다 (x,y 따로)
                    - 짝꿍들 다 더한 좌표: visited array에서 값이 0인 index에 해당하는 좌표들만 다 더한다 (x, y) 따로
                    - 두 좌표를 뺀다
                    - 최종적으로 얻은 하나의 좌표에서 x제곱 + y제곱 값을 계산한 다음 글로벌 변수랑 값을 비교해서 더 작은 쪽으로 update 한다
            - recursive case
                - 값을 변화시킬 수 있는 범위는 현재 index~마지막 index
                - valid indices에 대해 아래의 작업 수행
                    1. 방문 처리 → visited 상태 변경
                        - 잠시 해당 자리를 1로 만드는 것이고, 해당 자리 좌표를 앞부분으로 보내는 경로를 탐색
                    2. 재귀함수 콜: updated visited, index+1, num_pairs + 1
                        - num_pairs +1의 의미
                            - 방문 처리하는 index가 현재 index인 경우 → 1로 만들고 넘어가는 것
                            - 방문 처리하는 index가 현재 index 다음인 경우 → 현재 자리를 0으로 만들고 넘어가는 것
                            - 방문 처리하는 자리가 꼭 index가 아니더라도, 현재 index 자리를 앞부분 or 짝꿍 둘 중 한 역할로 pairing 하고 넘어가는 것
                            - 현재 index가 속하게 된 pair가 새로 생성되었으므로 +1 해주는 것을 의미한다
                    3. 방문 처리 다시 원상 복구 → visited 상태 변경 
- 문제 이해
    - 지렁이 위치는 x,y 두 점으로 주어진다
    - [동철이의 일 분배 ](https://www.notion.so/7dffaa065da6474eb6694dc980909e8d?pvs=21) 랑 비슷할 수도…?
    - 근데 한 번 처리당 pair로 방문 처리를 하게 되는데 이게 맞는지 모르겠다
    - 보아하니 벡터를 다 더한 다음에 크기는 마지막에 구하는 것 같은데, 프루닝은 어떻게 하는지 모르겠다
        - 프루닝 없이 하니까 3/100
- Trial
    - 프루닝 조건 1 추가하니까 11/100
        - `if abs(acc_x + next_x) < abs(acc_x) and abs(acc_y + next_y) < abs(acc_y):`
        
        ```python
        def recur(cur_worm, partner, acc_x, acc_y):
            global min_vector
            visited[cur_worm] = True
            visited[partner] = True
            x, y = worms[cur_worm][0] - worms[partner][0], worms[cur_worm][1] - worms[partner][1]
            acc_x += x
            acc_y += y
        
            # base case
            if sum(visited) == N:
                res = acc_x ** 2 + acc_y ** 2
                if res < min_vector:
                    min_vector = res
                visited[cur_worm] = False
                visited[partner] = False
                return
        
            for i in range(N):
                if visited[i]:
                    continue
                for j in range(N):
                    if visited[j] or i == j:
                        continue
                    # pruning?
                    next_x, next_y = worms[i][0] - worms[j][0], worms[i][1] - worms[j][1]
                    if abs(acc_x + next_x) < abs(acc_x) and abs(acc_y + next_y) < abs(acc_y):
                        #next_vector = next_x ** 2 + next_y ** 2
                        #if acc_vector + next_vector < min_vector:
                        recur(i, j, acc_x, acc_y)
        
            visited[cur_worm] = False
            visited[partner] = False
        
        T = int(input())
        for t in range(1, T+1):
            N = int(input())
            worms = []
            for _ in range(N):
                worms.append(list(map(int, input().split())))
            min_vector = float('inf')
            visited = [False] * N
            for i in range(1, N):
                recur(0, i, 0, 0)
            print(f'#{t} {min_vector}')
        
        ```
        
- 남의 힌트
    
    N마리의 지렁이가 있으면 이중 N/2마리를 출발지렁이, N/2를 도착지렁이로 구분짓는다.
    
    그리고 출발지렁이의 좌표값합과 도착지렁이의 좌표값합을 A, B라고 할 경우
    
    (Ax-Bx)^2+(Ay-By)^2가 최소가 되게하는 지렁이 조합의 경우의수를 찾으면 됨
    
    **한쌍, 한쌍 구해서 계산할 필요가 없다. 전체벡터합을 더해 벡터의크기를 구하기 때문!**
    
    제곱하고 난 뒤 더하므로 부호계산 할 필요 없음!
    
- scratch
    - 전체 N개에서 N//2개의 쌍을 만드는 서로 다른 방법의 개수를 모르겠음
- 남의 코드 이해하기
    - combination 만들기 ← 그냥 외우자
        
        ```python
        def comb(vi,idx,su):
            if su==N/2:
                print(vi)
                return
            for i in range(idx,N):
                vi[i]=1
                comb(vi,i+1,su+1)
                vi[i]=0
        ```
        
        - [0, 0, 0, 0], 0, 0에서 시작
            - i: 0~3
                - comb([1, 0, 0, 0], 1, 1)
                    - i: 1~3
                        
                        아래 세 경우는 모두 base case hit 
                        
                        - comb([1, 1, 0, 0], 2, 2)
                        - comb([1, 0, 1, 0], 2, 2)
                        - comb([1, 0, 0, 1], 2, 2)
                - comb([0, 1, 0, 0], 1, 1)
                    - i: 2~3
                    - comb([0, 1, 1, 0], 2, 2)
                    - comb([0, 1, 0, 1], 2, 2)
                - comb([0, 0, 1, 0], 1, 1)
                    - i = 3
                    - comb([0, 0, 1, 1])
                - comb([0, 0, 0, 1], 1, 1)
        - 사실 별거 아니고 그냥 NCN//2 였음 ;;