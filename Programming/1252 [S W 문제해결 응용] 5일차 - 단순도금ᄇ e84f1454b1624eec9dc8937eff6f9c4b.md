# 1252. [S/W 문제해결 응용] 5일차 - 단순도금비용

Created time: May 4, 2024 10:12 AM
Last edited time: May 5, 2024 9:53 AM

- 문제 이해
    - 구역 크기에 따라 금박 필름을 3가지 크기의 정사각형으로 규격을 정해 놓았고 크기가 클수록 단위 가격이 적다.
        - 위 수식에 의하면 범위 1도금 처리비용은 2, 범위 2의 비용은 4이며 범위 3은 7의 비용이 필요하다.
    - 총 금박 필름의 비용을 최소화하는 것이 목표이므로 하나의 금박 필름으로 손상된 부분이 밀집한 곳을 많이 덮을 수 있도록 금박 필름의 지점과 범위를 정하는 것이 중요하다.
    - 금박 필름은 금박 필름을 붙여 처리하는 좌측 상단을 기준으로 우측 및 하단으로 범위만큼의 정사각형 영역을 덮는다.
    - 즉 손상된 부분에 금박 필름이 겹쳐서 도금 처리되는 것은 아무런 문제가 없다.
- first thought
    
    1로 할 때 비용, 2로 할 때 비용, 3으로 할 때 비용을 돌아가면서 계산한다 
    
- 남의 코드 이해
    - [x]  5개로 붙어 있는 경우, 3by3짜리 하나로 하면 비용이 7인데, 2by2 하나 하고 1by1 추가로 하면 6이라 비용은 이쪽이 더 싸다. 아래 코드 대로 하면 결국 3by3 하나로 덮이게 될 것 → 그냥 내일 강의를 보자!
        - 그냥 감수하는 것 같다. 예제만 봐도 그런 경우에 그냥 3by3 하나 짜리로 덮으라고 한다 ;; greedy인데…
    
    ```python
    def makeZero(x, y, size):  # broken tile 고치기 
        global N
        for i in range(x, x + size):
            for j in range(y, y + size):
                if board[i][j]:
                    board[i][j] = 0
                    N -= 1 # 하나 고쳤으니까 남은 tile 수에서 하나 뺀다 
     
     
    def solve(n, min_size):
        global ans
        for max_size in range(n * n, min_size, -1):
    		    # 커버 타올이 위치할 수 있는 좌상단 좌표 범위 
            for i in range(1, S - n + 2):  
                for j in range(1, S - n + 2):
                    cnt = 0
                    # 이번 좌상단에서 시작하는 커버 타올로 커버할 수 있는 망가진 타일 개수 
                    for k in range(n):
                        for w in range(n):
                            if board[i + k][j + w]:
                                cnt += 1
                    if cnt >= max_size:
                        ans += 1 # size n 짜리 타일 1개를 추가로 사용한다는 의미 
                        # i, j: 좌상단 위치 
                        plate_list.append(i)
          ⁴             plate_list.append(j)
                        # 타일 크기 
                        plate_list.append(n)
                        # 커버한다 (1 -> 0)
                        makeZero(i, j, n)
     
     
    T = int(input())
    for test_case in range(1, T + 1):
        S = int(input()) # matrix size
        N = int(input()) # broken tile 개수
        tmp = list(map(int, input().split()))
     
        board = [[0] * (S + 1) for _ in range(S + 1)]
        for i in range(N):
            board[tmp[i * 2]][tmp[i * 2 + 1]] = 1
     
        ans = 0
        plate_list = []
        solve(3, 4) # 2*2면 2로 하는게 좋으니까? 
        if N: 
            solve(2, 1) # 1*1면 1로 하는게 더 좋지 
        if N:
            solve(1, 0) # 1개짜리는 어차피 1개일 때빼고 가격 효율이 다 안 좋음 - 여기까지 왔다는 건 위에서 해결 안되는 이상한 위치에 있는 broken tile이라는 뜻이므로 어쩔 수 없이 1짜리로 메꿔야 함 
     
        print(f'#{test_case} {ans}', *plate_list)
    ```
    
    - 비용 계산을 해보자
        - 타일 1개짜리는 1개당 2
        - 타일 2개짜리는 처리 비용이 4 → 2 by 2 = 4개 처리하기 위해 4가 들었음 → 1개당 1
        - 타일 3개짜리는 처리 비용이 7 → 3 by 3 = 9개 처리하기 7이 들었음 → 1개당 1이 안되는 비용
        
        → 더 큰 타일을 쓸 수록 개당 처리 비용이 적게 든다 그렇지만 
        
        | 타일 개수  | 1개짜리로 커버  | 2개짜리로 커버  | 3개짜리로 커버  |
        | --- | --- | --- | --- |
        | 1 | 2 | 4 | 7 |
        | 2 | 4 | 4 | 7 |
        | 3 | 6 | 4 | 7 |
        | 4 | 8 | 4 | 7 |
        | 5 | 10 | 8 | 7 |
        | 6 | 12 | 8 | 7 |
        | 7 | 14 | 8 | 7 |
        | 8 | 16 | 8 | 7 |
        | 9 | 18 | 12 | 7 |
        | 10 | 20 | 12 | 14 |
        
        → 1개까지는 1개짜리로 커버하는 게 좋고, 2개부터 4개까지는 2개짜리로 커버하는 게좋고, 5개부터 9개까지는 3개짜리로 커버하는 게좋다 
        
        - 근데 damaged tile이 하나의 커버 타일안에 들어 있는 개수가 많을 수록 좋음
        - 근데 10개같은 경우는 다시 2개짜리로 커버하는 게 가장 비용이 낮은데…?
            - 아니 정확히 말하면 9개를 3개짜리로 한번에 커버하고, 나머지 한 칸을 1짜리로 커버하는 게최소 비용임 7+2 = 9
        - 5개 같은 경우도 2개짜리로 4개 커버하고, 나머지 1개는 1개짜리로 커버하면 최소 비용이 4 + 2 = 6 < 7이다
    - 남의 코드 2
        
        ```python
        import sys
        
        class Location:
            def __init__(self, x, y, count):
                self.x = x
                self.y = y
                self.count = count
        
        Answer = []
        
        plate = []
        platingCost = [0, 2, 4, 7]
        
        S = 0
        N = 0
        
        def countDamagedMetal(row, col, size): # (row, col) 좌상단에서 size 크기 커버 타일 사용할 때 범위 안의 망가진 타올 개수 
            count = 0
            for i in range(row, row + size):
                for j in range(col, col + size):
                    count += 1 if plate[i][j] == 1 else 0
            return count
        
        def findDamagedMetalPlate(startX, startY, size, platingSize):
            maxRow, maxCol, maxCount = 0, 0, 0
            # 가능한 모든 좌상단: (i, j)
            for i in range(startX, startX + size - platingSize + 1):
                for j in range(startY, startY + size - platingSize + 1):
                    count = countDamagedMetal(i, j, platingSize)
                    if maxCount < count:
                        maxCount = count
                        maxRow, maxCol = i, j
            return Location(maxRow, maxCol, maxCount)
        
        def provisionalPlating(startX, startY, size, preValue, newValue):
            for row in range(startX, startX + size):
                for col in range(startY, startY + size):
                    if plate[row][col] == preValue:
                        plate[row][col] = newValue
        
        def simplePlatingCost(startX, startY, size, platingSize, flag):
            global Answer
            sumCost = 0
            while platingSize > 1:
                location = findDamagedMetalPlate(startX, startY, size, platingSize)
                if location.count == 0:
                    break
                cost1 = platingCost[platingSize]
                if flag and platingSize == 3 and location.count <= 6:
                    totalCost1 = simplePlatingCost(startX, startY, size, 3, False)
                    totalCost2 = simplePlatingCost(startX, startY, size, 2, False)
                    if totalCost2 < totalCost1:
                        platingSize = 2
                        continue
                cost2 = 0
                if platingSize > 2:
                    location2 = findDamagedMetalPlate(location.x, location.y, platingSize, platingSize - 1)
                    cost2 = platingCost[platingSize - 1]
                    provisionalPlating(location2.x, location2.y, platingSize - 1, 1, 2)
                    while True:
                        location3 = findDamagedMetalPlate(location.x, location.y, platingSize, 2)
                        if location3.count > 1:
                            cost2 += platingCost[2]
                            provisionalPlating(location3.x, location3.y, 2, 1, 2)
                        else:
                            break
                cost2 += platingCost[1] * countDamagedMetal(location.x, location.y, platingSize)
                provisionalPlating(location.x, location.y, platingSize, 2, 1)
                if cost1 <= cost2:
                    provisionalPlating(location.x, location.y, platingSize, 1, 3 if flag else 4)
                    sumCost += cost1
                    if flag:
                        Answer.append(Location(location.x + 1, location.y + 1, platingSize))
                else:
                    platingSize -= 1
            for i in range(startX, startX + size):
                for j in range(startY, startY + size):
                    if plate[i][j] == 1:
                        sumCost += platingCost[1]
                        if flag:
                            Answer.append(Location(i + 1, j + 1, platingSize))
            if not flag:
                provisionalPlating(startX, startY, size, 4, 1)
            return sumCost
        
        def main():
            global Answer, plate, S, N
            T = int(input())
            for test_case in range(T):
                S = int(input())
                N = int(input())
                plate = [[0] * S for _ in range(S)]
                for _ in range(N):
                    x, y = map(int, input().split())
                    plate[x - 1][y - 1] = 1
                simplePlatingCost(0, 0, S, 3, True)
                output = f'#{test_case + 1} {len(Answer)}'
                for location in Answer:
                    output += f' {location.x} {location.y} {location.count}'
                print(output)
                Answer = []
        
        if __name__ == "__main__":
            main()
        
        ```
        
- 풀이 코드
    - 강의에서는 특정 시작점을 좌상단으로 하고, 3by3 타일을 올렸을 때, 그 안에서 커버되는 손상된 타일 개수가 6개 이하면 2by2타일로 올리는 경우의 cost를 계산하도록 한다…
        - 근데 이런 댓글도 있다 - filter_size == 3 일때, 최소 탐색값을 5로 설정하면, 결과값이 더 최적화 된 값으로 나오는 것을 확인하였고, 이것을 제출하니 통과했습니다. test_case가 모두 통과하더라도, 특정 점수 이상이 되어야 pass가 나오는 것 같습니다.
    - 코드는 복잡하고 greedy는 늘 뭘 배워가는 건지 모르겠다 .
    
    ```python
    import sys
    
    S = N = 0
    Map = [[0] * 100 for _ in range(100)]
    Cost = [0] * 101
    AnsCnt = 0
    Answer = [[0, 0, 0] for _ in range(10000)]
    
    def count_damage(row, col, size): # 특정 시작점에서 특정 크기 타일 안에 들어오는 손상된 타일 수 
        cnt = 0
        for i in range(row, row + size):
            for j in range(col, col + size):
                if Map[i][j] == 1:
                    cnt += 1
        return cnt
    
    def find_optimal(row, col, size, glid_size):
        max_cnt, max_r, max_c = 0, -1, -1
        for i in range(row, row + size - glid_size + 1): # 모든 시작점을 돌면서
            for j in range(col, col + size - glid_size + 1):
                cnt = count_damage(i, j, glid_size) # 그 시작점에서의 손상된 타일 개수 센다 
                if cnt > max_cnt:
                    max_cnt, max_r, max_c = cnt, i, j
        return (max_r, max_c, max_cnt) # 특정 타일 안에 들어오는 손상된 타일 개수가 가장 많은 경우를 return 
    
    def set_mark(row, col, size, cur_value, new_value):
        for i in range(row, row + size):
            for j in range(col, col + size):
                if Map[i][j] == cur_value:
                    Map[i][j] = new_value
    
    def solve(row, col, size, glid_size, first):
        global AnsCnt
        sum_cost = 0
        while glid_size > 1:
            glid1 = find_optimal(row, col, size, glid_size)
            if glid1[2] == 0: # broken tile이 없다 
                break
    
            cost1 = Cost[glid_size] # 현재 타일 크기로 덮을 때 가격
            cost2 = 0
            
            
            **## 현재 타일 영역을 더 작은 타일로 덮었을 때 가격을 구하기** 
            # 여기서부터는 행렬이 현재 타일 사이즈로 범위가 변경 
            if glid_size > 2:
                glid2 = find_optimal(glid1[0], glid1[1], glid_size, glid_size - 1)
                cost2 = Cost[glid_size - 1]
                set_mark(glid2[0], glid2[1], glid_size - 1, 1, 2)
    
                while True: # 2by2로 해결할 수 있는 경우 다 찾아서 해준다 
                    glid3 = find_optimal(glid1[0], glid1[1], glid_size, 2)
                    if glid3[2] <= 1:
                        break
                    cost2 += Cost[2]
                    set_mark(glid3[0], glid3[1], 2, 1, 2)
    				
    				# 현재 타일 크기로 덮으려는 영역을 2,1 짜리로 덮었을 때 가격 
            cost2 += Cost[1] * count_damage(glid1[0], glid1[1], glid_size)
            
            # marking 원상 복구 
            set_mark(glid1[0], glid1[1], glid_size, 2, 1)
    				
    				
    				**## 다른 타일 사이즈로 재귀콜 -> 예상 비용 계산. 왜 타일 사이즈가 저렇게 줄어드는지는 몰?루**
            cost3 = cost4 = float('inf')
            if first and glid_size > 6:
                new_glid_size1 = (glid_size + 1) // 2 # 7+1 // 2 = 4
                cost3 = solve(row, col, size, new_glid_size1, False)
                new_glid_size2 = (glid_size + 1) // 4 # 7+1 // 4 = 2
                cost4 = solve(row, col, size, new_glid_size2, False)
    				
    				**## 각 경우의 수로 cost를 구했을 때 가장 작게 나오는 방향으로 glid_size 이동** 
            if min(cost1, cost2, cost3, cost4) == cost1:
    			       # 3: 진짜 호출, 4: 재귀 콜로 견적내기용 
                set_mark(glid1[0], glid1[1], glid_size, 1, 3 if first else 4)
                sum_cost += cost1
                if first:
                    Answer[AnsCnt] = [glid1[0] + 1, glid1[1] + 1, glid_size]
                    AnsCnt += 1
            elif min(cost1, cost2, cost3, cost4) == cost2:
                glid_size -= 1
            elif min(cost1, cost2, cost3, cost4) == cost3:
                glid_size = new_glid_size1
            else:
                glid_size = new_glid_size2
    		
    		
    		# 가능한 모든 glid size로 해보고 나서(?) 남은 1짤 ㅣ처리 
        for i in range(row, row + size):
            for j in range(col, col + size):
                if Map[i][j] == 1:
                    sum_cost += Cost[1]
                    if first:
                        Answer[AnsCnt] = [i + 1, j + 1, 1]
                        AnsCnt += 1
    		
    		# 재귀콜로 4로 임시처리된 칸은 모두 1로 원상 복구 
        if not first:
            set_mark(row, col, size, 4, 1)
            
        return sum_cost
    
    def main():
        global AnsCnt, S, N
        for i in range(1, 101):
            Cost[i] = int(i * i / 2.0 + 2 * i / 3.0 + 1.0)
        tc_cnt = int(input())
        for t in range(1, tc_cnt + 1):
            S, N = map(int, input().split())
            Map = [[0] * S for _ in range(S)]
            for _ in range(N):
                r, c = map(int, input().split())
                Map[r - 1][c - 1] = 1
            AnsCnt = 0
            solve(0, 0, S, S, True)
            result = f"#{t} {AnsCnt}"
            for i in range(AnsCnt):
                result += f" {Answer[i][0]} {Answer[i][1]} {Answer[i][2]}"
            print(result)
    
    if __name__ == "__main__":
        main()
    
    ```