# 1849. 영준이의 무게측정

Created time: April 26, 2024 10:45 AM
Last edited time: April 29, 2024 3:34 PM

- 문제 이해
    - 4 → 1로 연결이 되어 있느냐…
    - 3, 4
    - 2, 3
    - 1, 2
    - 면 연결이 되어 있음
- Lessons
    1. 입력 키는 문자, 사전 안에서 초기화한 키 값은 정수라서 형 변환 안하면 keyError 발생
    2. 큰 쪽-작은 쪽 차이만 사전에 기록하지 말고, 반대로도 - 작은 쪽-큰쪽 = -주어진 차 - 로 기록해둬야 함 
    3. BFS는 시간 초과 난다 
    4. Union-Find를 변형해서 사용한다
        - weight : 자기가 속한 그룹의 최상위리더로부터 자기 자신의 무게 차
            - 트리의 균형을 위해 나보다 무게는 더 작지만 rank가 높은 원소 밑으로 병합될 수도 있다
            - 이 경우 input으로 들어온 b-a 무게 차 w는 음수가 되어서 b와, a가 속한 그룹의 최상위리더 사이의 가중치를 계산하는 데 사용된다
    5. input에서 a, b 자체의 값은 a가 더 클 수도 있다 ← 얘네는 index. 그러나 b의 무게는 늘 a의 무게보다 크다 
- Trial
    - BFS (5/18 시간제한 초과)
        
        ```sql
        from collections import deque
        def get_diff(idx_a, idx_b, info):
            # base case
            if idx_a in info[idx_b]:
                return info[idx_b][idx_a]
        
            if len(info[idx_b]) == 0:
                return 'UNKNOWN'
        
            # iterative case
            visited = [False] * (N+1)
            for key in info[idx_b]:
                visited[key] = True
            dq = deque(info[idx_b].items())
            while dq:
                cur_node, cur_diff = dq.popleft()
                if cur_node == idx_a:
                    return cur_diff
                for next_node in info[cur_node]:
                    if visited[next_node]:
                        continue
                    visited[next_node] = True
                    next_diff = info[cur_node][next_node] + cur_diff
                    dq.append((next_node, next_diff))
            return 'UNKNOWN'
        
        T = int(input())
        for t in range(1, T+1):
            N, M = map(int, input().split())
            notes = {i:{} for i in range(1, N+1)}
            ans = []
            for _ in range(M):
                data = list(input().split())
                if len(data) == 4:
                    a, b, w = map(int, data[1:])
                    notes[b][a] = w
                    notes[a][b] = -w
                else:
                    a, b = map(int, data[1:])
                    ans.append(str(get_diff(a, b, notes)))
            print(f'#{t} {" ".join(ans)}')
        ```
        
- 남의 코드 이해하기
    - virgin union
        - 부모가 없으면 - union 된적 한번도 없으면- 자기 자신으로 나옴
        - 부모가 같으면 이미 union 된 상태라 pass
        - 처음에는 weight 기록 없으니까 0
        - 각자의 rank도 다 0이라 동일 - 조건문 부분 건너뜀
        - pa =a, pb = b인 상황에서 늘 b의 무게가 더 무겁다고 했으므로 pb(b)로 병합
            - pa=a 쪽 무게에 w를 더해준다
            - rank가 같은 상황이기 때문에 병합한 pb(b) 쪽의 rank를 1 더해준다
    - experienced union
        - ! 1 2 100
            - weight[1] = 100
            - parent[1] = 2
            - rank[2] = 1
            
            → ? 2 3 → unknown 
            
        - ! 2 3 100
            - find(2) = parent[2] = 0 → return 2
            - find(3) = parent[3] = 0 → return 3
            - diff는 아직 둘다 무게 없어서 0
            - rank 비교: rank[2] = 1 > rank[3] = 0
                
                → pa ↔ pb → pa = 3, pb = 2 
                
                w = -100 
                
                diff = 0 
                
            - weight[pa] = w + diff
                - weight[3] = -100
            - parent[pa] = parent[3] = pb = 2
            
            → ? 2 3 
            
            - find(2)
                - parent[2]  = 0 → return 2
            - find(3)
                - parent[3] = 2
            
            → 둘의 부모가 같음 → weight[a] - weight[b] = 0 - (-100) = 100 
            
        - ? 1 3
            - find(1)
                - 2 = parent[1]
            - find(3)
                - 2  = parent[3]
            - 둘의 부모가 같음 → weight[a] - weight[b] = 100 - (-100) = 200
        - ! 4 3 150
            - find(4)
                - parent[4] = 0 → return 4
            - find(3)
                - parent[3] = 2
            - diff = -100 - 0 = -100
            - rank의 경우
                - rank[4] = 0 < rank[2] = 1 → 조건문 skip
            - weight[4] = 150 - 100 = 50
                - 3에서 -100을 더해야 2의 무게가 되고
                - 4에서 150을 더해야 3의 무게가 됨
                
                → 4에서 150을 더해서 3의 무게가 된 다음에 다시 -100을 하면 2의 무게가 됨 
                
                → 4에서 50을 더하면 2의 무게가 됨 
                
            - parent[4] = 2
        - ? 4 1
            - find(4) = 2 = find(1)
            - 4에 50을 더하면 2가 되고, 1에 100을 더하면 2가 된다
            - weight[4] = 50
            - weight[1] = 100
            - 둘 사이의 차는 -50
    
    ```python
    from collections import defaultdict
    
    def find(a):
        if not parent[a]:
            return a
        pa = parent[a]
        parent[a] = find(pa)
        weight[a] += weight[pa]
        return parent[a]
    
    def union(a, b, w):
        pa = find(a)
        pb = find(b)
        # 부모가 없으면 - union 된적 한번도 없으면- 자기 자신으로 나옴 
        if pa == pb: # 부모가 같으면 이미 union 된 상태라 pass
            return
        diff = weight[b] - weight[a] # 처음에는 weight 기록 없으니까 0 
        if rank[pa] > rank[pb]: # 처음에는 rank도 다 0이라 아래 부분 pass 
            pa, pb = pb, pa 
            w = -w
            diff = -diff
        weight[pa] = w + diff # 0 + w = w
        parent[pa] = pb # union 된 적 없으면 pa = a, pb = b이고 b의 무게가 늘 더 무겁다 
        if rank[pa] == rank[pb]: # 처음엔 rank가 같기 때문에 
            rank[pb] += 1 # pb 쪽으로 합쳤으므로 rank 올려준다 
    
    T = int(input())
    for tc in range(1, T + 1):
        N, M = map(int, input().split())
        parent = defaultdict(int)
        weight = defaultdict(int)
        rank = defaultdict(int)
        ans = []
        for _ in range(M):
            work = input()
            if work[0] == '!':
                a, b, w = map(int, work.split()[1:])
                union(a, b, w)
            else:
                a, b = map(int, work.split()[1:])
                if find(a) == find(b):
                    ans.append(weight[a] - weight[b])
                else:
                    ans.append('UNKNOWN')
        print('#{} {}'.format(tc, ' '.join(map(str, ans))))
    ```
    
- [x]  처음부터 끝까지 다시 짜보기
- [x]  약식 UF 말고 class 사용하는 정식 UF에 적용해보기
- 헷갈리는 연산
    - find 하면 weight[x] = root_x - x
    - y - x = w_diff
    - find 하면 weight[y] = root_y - y
    - root_y를 root_x에 연결하는 것이므로 root_y의 가중치를 바꿔야 함
        - root_y와 y 사이는 그대로 유지되면서
        - self.weight[root_y] = w_diff + (self.weight[x] - self.weight[y])
        - y-x 차이: w_diff
        - root_x-x 차이: self.weight[x]
        - root_y-y 차이: self.weight[y]
        - 세 개를 다 더하면 root_x - root_y가 나와야 함
        - x-y + root_x-x = root_y + y = root_x - root_y
- 쭉 해보기
    
    **! 1 2 100**
    
    → root:1, weight[2] = -100
    
    rank[1] += 1 
    
    ? 2 3
    
    → unknown 
    
    **! 2 3 100**
    
    → root_y = find(3) = 3
    
    - root_x = find(2) = 1
        - 2 ≠ 1
        
        → weight[2] += weight[1] = -100 
        
    - rank[3] = 0 < rank[1] = 1
        - root[3] = 1
        - weight[root_y] : root_x - root_y
            - root_x - x - root_y + y = root_x - root_y + (y-x)
            - w_diff = y - x
        - weight[3] = -100 + weight[2] - weight[3] = -100 -100 = -200
    
    ? 2 3
    
    → weight[2] - weight[3] = -100 - (-200) = 100 
    
    ? 1 3
    
    → weight[1] = 0 - weight[3] = -200 = 200 
    
    **! 4 3 150**
    
    - find(3)
        - o.g.root = 1
        - find(1)= 1 → root[3]
            - 만약에서 여기서 find(1)이 아니라 15 같은 숫자라고 하면
            - weight[1] = weight[15]-weight[1]
            - weight[3] = weight[1] - weight[3]
                
                = weight[15]-weight[1] + weight[1] - weight[3]
                
                = weight[o.g.root] + weight[x] 
                
                = weight[15] - weight[3] 
                
            - weight[3] += weight[1]  = -200 + 0 = -200
        - find(4) = 4
    - union(4, 3)
        - rank[root_3] = 1 > rank[root_4] = 0
        - 1로 합친다
            - root[4] = 1
            - weight[4] = weight[1] - weight[4]
                - -weight[3] + weight[3] + weight[1] - weight[4]
                
                = (weight[1]-weight[3])-(weight[4]-weight[3]) 
                
                = weight[3] = -200 - (150) = -350 
                
    
    ? 4 1
    
    → 이상하다 했더니 union 부분에서 누구의 root를 바꿔야 하는지가 잘못되어 있었음 
    
- AC 코드 (🏋️‍♀️🪇)
    
    ```python
    class UnionFind:
        def __init__(self, size):
            self.size = size + 1
            self.weight = [0] * self.size  # weight difference from its root
            self.root = [i for i in range(self.size)]
            self.rank = [1] * self.size
    
        def find(self, x):
            if self.root[x] != x:
                original_root = self.root[x]  # check
                self.root[x] = self.find(self.root[x])
                self.weight[x] += self.weight[original_root]
            return self.root[x]
    
        def union(self, x, y, w_diff):
            # x is lighter
            root_x, root_y = self.find(x), self.find(y)
            if root_x != root_y:
                if self.rank[root_x] > self.rank[root_y]:  # root: root_x
                    self.root[root_y] = root_x
                    # x - y + root_x - x - root_y + y -> root_x - root_y + (x - y - x + y) = root_x - root_y
                    self.weight[root_y] = -w_diff + self.weight[x] - self.weight[y]
                elif self.rank[root_x] < self.rank[root_y]:  # root: root_y
                    self.root[root_x] = root_y
                    # y - x + root_y - y - root_x + x = root_y - root_x + (y - x - y + x) = root_y - root_x
                    self.weight[root_x] = w_diff + self.weight[y] - self.weight[x]
                else:  # root: root_x
                    self.root[root_y] = root_x
                    self.rank[root_x] += 1
                    self.weight[root_y] = -w_diff + self.weight[x] - self.weight[y]
    
        def is_connected(self, x, y):
            return self.find(x) == self.find(y)
    
    T = int(input())
    for t in range(1, T+1):
        N, M = map(int, input().split())
        UF = UnionFind(N)
        ans = []
        for _ in range(M):
            data = list(input().split())
            if len(data) == 4:
                a, b, w = map(int, data[1:])
                print(UF.root[a], UF.root[b], UF.weight[a], UF.weight[b])
                UF.union(a, b, w)
                print(a, b, w)
                print(UF.root[a], UF.root[b], UF.weight[a], UF.weight[b])
            else:
                a, b = map(int, data[1:])
                if UF.is_connected(a, b): # b가 a보다 얼마나 무거운지
                    #print(UF.root[a], UF.root[b], UF.weight[a], UF.weight[b])
                    ans.append(str(UF.weight[a]-UF.weight[b]))
                else:
                    ans.append('UNKNOWN')
    
        print(f'#{t} {" ".join(ans)}')
    
    ```