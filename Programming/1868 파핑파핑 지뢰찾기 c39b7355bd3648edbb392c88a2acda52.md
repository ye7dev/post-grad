# 1868. 파핑파핑 지뢰찾기

Created time: April 6, 2024 10:03 PM
Last edited time: April 7, 2024 3:58 PM

- Trial
    - 1차시
        - 최적의 점으로 어떻게 건너 뛰는지 모르겠음
        - 시작점을 다르게 줘도, 다른 점 탐색 순서는 같기 때문에…
        
        ```python
        from collections import deque
        import copy
        def start_explore(x, y, visited):
            num_click = 1
            visited[x][y] = True
        
            def explore(a, b):
                num_mine = 0
                candidates = []
                # check edge 8 cells
                for da in [-1, 0, 1]:
                    for db in [-1, 0, 1]:
                        if da == db == 0:
                            continue
                        na, nb = a + da, b + db
                        if 0 <= na < N and 0 <= nb < N:
                            if matrix[na][nb] == '*':
                                num_mine += 1
                            else:
                                if not visited[na][nb]:
                                    candidates.append((na, nb))
                # no mine around
                if num_mine == 0:
                    for na, nb in candidates:
                        visited[na][nb] = True
                        explore(na, nb)
        
            explore(x, y)
            for i in range(N):
                for j in range(N):
                    if matrix[i][j] == '.' and not visited[i][j]:
                        visited[i][j] = True
                        print(i, j)
                        num_click += 1
                        explore(i, j)
        
            return num_click
        
        T = int(input())
        for t in range(1, T+1):
            N = int(input())
            matrix = []
            mat_click = []
            for _ in range(N):
                row = input()
                matrix.append(row)
                click_row = []
                for i in range(N):
                    click_row.append(True if row[i] == '*' else False)
                mat_click.append(click_row)
        
            min_click = N * N
            for i in range(N):
                for j in range(N):
                    if matrix[i][j] == '.':
                        visited = copy.deepcopy(mat_click)
                        num_click = start_explore(i, j, visited)
                        print(num_click)
                        min_click = min(min_click, num_click)
            print(f'#{t} {min_click}')
        
        ```
        
- AC 코드
    
    ```python
    arr_dx = [-1, 0, 1]
    arr_dy = [-1, 0, 1]
    
    def is_mine_free(x, y):
        # check is there is a mine around the current cell
        for dx in arr_dx:
            for dy in arr_dy:
                if dx == dy == 0:
                    continue
                nx, ny = x + dx, y + dy
                if 0 <= nx < N and 0 <= ny < N:
                    if matrix[nx][ny] == '*':
                        return False
        return True
    
    def check_boundaries(x, y):
        # check if there is a cell 1) around (x, y) 2) having mine-free edge itself
        matrix[x][y] = 'checked'  # open itself
        for dx in arr_dx:
            for dy in arr_dy:
                if dx == dy == 0:
                    continue
                nx, ny = x + dx, y + dy
                if 0 <= nx < N and 0 <= ny < N:
                    if matrix[nx][ny] == '.':
                        if is_mine_free(nx, ny):  # cell with mine-free edge
                            check_boundaries(nx, ny)
                        else:  # opened but stop exploring
                            matrix[nx][ny] = 'checked'
    
    T = int(input())
    for t in range(1, T+1):
        N = int(input())
        matrix = []
        for _ in range(N):
            matrix.append(list(input()))
    
        num_click = 0
        for i in range(N):
            for j in range(N):
                if matrix[i][j] == '.' and is_mine_free(i, j):
                    num_click += 1
                    check_boundaries(i, j)
    
        # count still closed non-mine cells
        for i in range(N):
            for j in range(N):
                if matrix[i][j] == '.':
                    num_click += 1
    
        print(f'#{t} {num_click}')
    
    ```