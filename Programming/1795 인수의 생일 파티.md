# 1795. 인수의 생일 파티

Created time: May 25, 2024 2:40 PM
Last edited time: May 25, 2024 3:27 PM

- scratch
    
    플로이드 와셜 아니면 priority queue이용?
    
    bfs이용해서 모든 노드에 대해 다 도는 걸 두 번 반복하면 될 듯?
    
    cycle은 있는 듯
    
    방문 처리를 어떻게 해야 하려나 - at enqueing으로 했다 
    
    각 사람들은 자신의 집에서 X번 집으로 오고 가기 위해 최단 시간으로 이동한다.
    
- Trial
    - BFS 두 번
        - 돌아가지만 예제 1번만 맞았다. 답이 전반적으로 작게 나옴
        
        ```python
        import sys
        sys.stdin = open('temp_input/input.txt', 'r')
        
        from collections import deque
        def get_max_dist():
            total_dist = {i:0 for i in range(1, N+1)}
            # to X
            for i in range(1, N+1):
                visited = [0] * (N+1)
                if i == X:
                    continue
                going_out = deque([(0, i)])
                while going_out:
                    cur_dist, cur_node = going_out.popleft()
                    if cur_node == X:
                        total_dist[i] += cur_dist
                        break
                    for neighbor in graph[cur_node]:
                        if not visited[neighbor[1]]:
                            going_out.append(neighbor)
                            visited[neighbor[1]] = 1
            # from X
            for i in range(1, N+1):
                visited = [0] * (N + 1)
                if i == X:
                    continue
                coming_in = deque([(0, X)])
                while coming_in:
                    cur_dist, cur_node = coming_in.popleft()
                    if cur_node == i:
                        total_dist[i] += cur_dist
                        break
                    for neighbor in graph[cur_node]:
                        if not visited[neighbor[1]]:
                            coming_in.append(neighbor)
                            visited[neighbor[1]] = 1
        
            return max(total_dist.values())
        
        T = int(input())
        for t in range(1, T+1):
            N, M, X = map(int, input().split())
            graph = {i: [] for i in range(1, N+1)}
            for _ in range(M):
                x, y, c = map(int, input().split())
                graph[x].append((c, y))
            ans = get_max_dist()
            print(f'{t} {ans}')
        ```
        
    
- 놓친 점
    - bfs랑 다익스트라 차이점을 모름
        - **BFS**
            - 모든 간선의 가중치가 동일한 그래프(예: 무가중치 그래프)에서 최단 경로를 찾을 때 유용
            - 너비 우선 탐색 방식으로, 시작 노드에서 가까운 노드부터 탐색을 진행합니다. 큐를 사용하여 현재 탐색할 노드를 관리하며, 먼저 발견된 노드부터 탐색합니다.
            - 시간 복잡도는 O(V + E)
        - **다익스트라**
            - 가중치가 있는 그래프(간선의 가중치가 서로 다를 수 있음)에서 최단 경로를 찾을 때 사용
            - 우선순위 큐(또는 최소 힙)를 사용하여 현재까지 발견된 최단 경로를 기준으로 탐색을 진행합니다. 가장 짧은 경로를 먼저 확정하면서 탐색합니다.
            - 우선순위 큐를 사용하면 O((V + E) log V)
            - 가중치가 음수가 아닌 그래프에서 최적의 성능
                - 가중치가 음수이면 벨먼-포드 알고리즘 이용
    - print 할 때 # 표시 빼먹음 ;;
- AC 코드
    
    ```python
    import sys
    sys.stdin = open('temp_input/input.txt', 'r')
    
    import heapq
    def dijkstra(start, end):
        visited = [0] * (N+1)
        pq = [(0, start)]
        while pq:
            cur_dist, cur_node = heapq.heappop(pq)
            visited[cur_node] = 1
            if cur_node == end:
                return cur_dist
            for neighbor in graph[cur_node]:
                next_dist, next_node = neighbor
                if not visited[next_node]:
                    heapq.heappush(pq, (cur_dist+next_dist, next_node))
    
    T = int(input())
    for t in range(1, T+1):
        N, M, X = map(int, input().split())
        graph = {i: [] for i in range(1, N+1)}
        for _ in range(M):
            x, y, c = map(int, input().split())
            graph[x].append((c, y))
    
        ans = 0
        for i in range(1, N+1):
            if i == X: continue
            to_X = dijkstra(i, X)
            from_X = dijkstra(X, i)
            ans = max(to_X + from_X, ans)
        print(f'#{t} {ans}')
    ```