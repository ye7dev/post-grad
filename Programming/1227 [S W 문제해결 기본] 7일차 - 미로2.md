# 1227. [S/W 문제해결 기본] 7일차 - 미로2

Created time: April 23, 2024 4:39 PM
Last edited time: April 23, 2024 5:21 PM

- Trial
    - DFS
        - Maximum recursion error
        
        ```python
        import sys
        sys.stdin = open("input_maze2.txt", "r")
        def check_maze(mat, s_row, e_row):
            # 2: start, 3: end
            for j in range(100):
                if mat[s_row][j] == 2:
                    start = (s_row, j)
                    break
        
            # dfs?
            visited = [[False] * 100 for _ in range(100)]
            directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
            def explore(x, y):
                if mat[x][y] == 3:
                    return True
                if visited[x][y]:
                    return False
                visited[x][y] = True
                if mat[x][y] == 1:
                    return False
                for d in directions:
                    new_x, new_y = x+d[0], y+d[1]
                    if 0 <= new_x < 100 and 0 <= new_y < 100:
                        if visited[new_x][new_y]:
                            continue
                        if explore(new_x, new_y):
                            return True
                return False
        
            if explore(start[0], start[1]):
                return True
            return False
        
        for _ in range(10):
            t = int(input())
            matrix = []
            start_flag = -1
            finish_flag = -1
            for i in range(100):
                row = [int(char) for char in input()]
                if 2 in row:
                    start_flag = i
                if 3 in row:
                    finish_flag = i
                matrix.append(row)
            if start_flag < 0 or finish_flag < 0:
                print(f'#{t} {0}')
            else:
                ans = check_maze(matrix, start_flag, finish_flag)
                if ans:
                    print(f'#{t} {1}')
                else:
                    print(f'#{t} {0}')
        
        ```
        
- AC 코드
    - BFS
        
        ```python
        import sys
        sys.stdin = open("input_maze2.txt", "r")
        
        from collections import deque
        def check_maze(mat, s_row, e_row):
            # 2: start, 3: end
            j = 0
            while mat[s_row][j] != 2:
                j += 1
        
            # dfs?
            visited = [[False] * 100 for _ in range(100)]
            directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
            visited[s_row][j] = True
        
            dq = deque([(s_row, j)])
        
            while dq:
                cur_x, cur_y = dq.popleft()
                if mat[cur_x][cur_y] == 3:
                    return True
                for d in directions:
                    new_x, new_y = cur_x + d[0], cur_y + d[1]
                    if visited[new_x][new_y] or mat[new_x][new_y] == 1:
                        continue
                    visited[new_x][new_y] = True
                    dq.append((new_x, new_y))
            return False
        
        for _ in range(10):
            t = int(input())
            matrix = []
            start_flag = -1
            finish_flag = -1
            for i in range(100):
                row = [int(char) for char in input()]
                if 2 in row:
                    start_flag = i
                if 3 in row:
                    finish_flag = i
                matrix.append(row)
            if start_flag < 0 or finish_flag < 0:
                print(f'#{t} {0}')
            else:
                ans = check_maze(matrix, start_flag, finish_flag)
                if ans:
                    print(f'#{t} {1}')
                else:
                    print(f'#{t} {0}')
        
        ```
        
        - Lesson
            - input이 너무 크면 BFS로 가자