# 1861. 정사각형 방

Created time: April 7, 2024 11:04 AM
Last edited time: April 7, 2024 4:15 PM

- 여기는 어쨌든 시작점을 하나씩 다 돌아야 하지 않을까?
- 그래도 어떤 점 기준으로 사방에 자기보다 1 큰 방이 없으면 못 가니까 걔는 drop
- 시작점 하나 기준으로 dfs 돌아서 방을 총 몇 개 돌았는지 체크 해서 max 구하는 수순으로?
- Trial
    - 21/27, 이후로는 time out
        
        ```python
        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
        
        def valid_edge(x, y):
            cur_val = mat[x][y]
            for d in directions:
                nx, ny = x + d[0], y + d[1]
                if 0 <= nx < N and 0 <= ny < N:
                    if mat[nx][ny] == cur_val + 1:
                        return True
            return False
        
        def explore(x, y):
            if visited[x][y]:
                return 0
        
            visited[x][y] = True
            cur_visited = 1
            cur_val = mat[x][y]
            for d in directions:
                nx, ny = x + d[0], y + d[1]
                if 0 <= nx < N and 0 <= ny < N:
                    if mat[nx][ny] == cur_val + 1:
                        cur_visited += explore(nx, ny)
        
            return cur_visited
        
        T = int(input())
        for t in range(1, T+1):
            N = int(input())
            mat = []
            for _ in range(N):
                row = list(map(int, input().split()))
                mat.append(row)
        
            max_visited = 0
            max_start = N * N + 1
            for i in range(N):
                for j in range(N):
                    if valid_edge(i, j):
                        visited = [[False] * N for _ in range(N)]
                        num_visited = explore(i, j)
                        if num_visited > max_visited:
                            max_visited = num_visited
                            max_start = mat[i][j]
                        elif num_visited == max_visited:
                            if mat[i][j] < max_start:
                                max_start = mat[i][j]
        
            print(f'#{t} {max_start} {max_visited}')
        
        ```
        
- AC 코드
    
    visited는 하나만 쓰고, 함수 마지막에 return 하기 직전에 방문 상태 원상복구해두는 것이 포인트 
    
    ```python
    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    
    def valid_edge(x, y):
        cur_val = mat[x][y]
        for d in directions:
            nx, ny = x + d[0], y + d[1]
            if 0 <= nx < N and 0 <= ny < N:
                if mat[nx][ny] == cur_val + 1:
                    return True
        return False
    
    def explore(x, y):
        if visited[x][y]:
            return 0
    
        visited[x][y] = True
        cur_visited = 1
        cur_val = mat[x][y]
        for d in directions:
            nx, ny = x + d[0], y + d[1]
            if 0 <= nx < N and 0 <= ny < N:
                if mat[nx][ny] == cur_val + 1:
                    cur_visited += explore(nx, ny)
        visited[x][y] = False
        
        return cur_visited
    
    T = int(input())
    for t in range(1, T+1):
        N = int(input())
        mat = []
        for _ in range(N):
            row = list(map(int, input().split()))
            mat.append(row)
    
        max_visited = 0
        max_start = N * N + 1
        visited = [[False] * N for _ in range(N)]
        
        for i in range(N):
            for j in range(N):
                if not valid_edge(i, j):
                    continue 
                num_visited = explore(i, j)
                if num_visited > max_visited:
                    max_visited = num_visited
                    max_start = mat[i][j]
                elif num_visited == max_visited:
                    if mat[i][j] < max_start:
                        max_start = mat[i][j]
    
        print(f'#{t} {max_start} {max_visited}')
    ```
    
    - 효율적인 남의 코드
        
        ```python
        dx = [0, 0, -1, 1]
        dy = [1, -1, 0, 0]
         
        def dfs_memo(x,y):
            # global cnt
            #
            # cnt += 1
         
            if dp[y][x] != 1:
                return dp[y][x]
         
            for ii in range(4):
                nx = x + dx[ii]
                ny = y + dy[ii]
         
                if nx < 0 or nx >= n or ny < 0 or ny >= n:
                    continue
                if arr[ny][nx] == arr[y][x] + 1:
                    dp[y][x] = max(dp[y][x], dfs_memo(nx,ny) + 1)
         
            return dp[y][x]
         
        T = int(input())
         
        for tc in range(1, T + 1):
            n = int(input())
            arr = [list(map(int,input().split())) for _ in range(n)]
         
            dp = [[1]*n for _ in range(n)]
         
            final_ind = 0
            count = 0
         
            for i in range(n):
                for j in range(n):
         
                    #cnt = 0
         
                    cnt = dfs_memo(j,i)
                    #dfs(j, i)
         
                    if cnt > count:
                        final_ind = arr[i][j]
                        count = cnt
                    elif cnt == count:
                        final_ind = min(final_ind,arr[i][j])
         
            print('#{} {} {}'.format(tc, final_ind, count))
        ```