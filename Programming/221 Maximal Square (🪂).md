# 221. Maximal Square (ü™Ç)

Status: done, in progress, with help, üíé
Theme: DP
Created time: January 5, 2024 3:42 PM
Last edited time: January 6, 2024 10:03 AM

- Editorial
    - Brute Force
        - Algorithm
            1. early exit: if input matrix is None return 0
            2. iterate over all the cell 
                1. check if the current cell is 1 ‚Üí if not continue 
                2. offset of next row/col to explore from the current position (start from 1)
                    
                    ‚Ü≥ Ï†ïÏÇ¨Í∞ÅÌòïÏùÑ ÎÑìÌûê Îïå ÌÉêÏÉâ Î≤îÏúÑÎäî Îí§ÏßëÏñ¥ÏßÑ ÎãàÏùÄÏûê Î™®ÏñëÏúºÎ°ú Ï∂îÍ∞ÄÎê® 
                    
                    ‚Ü≥ Ï§ëÏ†êÏùÄ Ïö∞ÌïòÌñ• ÎåÄÍ∞ÅÏÑ†ÏùÑ Í∑∏Î¶¨Î©∞ Ïù¥Îèô. (0, 0) ‚Üí (n, n)
                    
                    ‚Ü≥ ÌÉêÏÉâ Î≤îÏúÑÎäî (n,0)~(n,n-1) for the bottom row & (0, n)~(n-1, n) for the rightmost column 
                    
                3. set flag as True 
                    
                    ‚Ü≥ ÌÉêÏÉâ Î≤îÏúÑÏóêÏÑú 0Ïù¥ ÌïòÎÇòÎùºÎèÑ ÎÇòÏò§Îäî ÏàúÍ∞Ñ FalseÍ∞Ä ÎêòÎ©¥ÏÑú 
                    
        - TLE but correct solution
            
            ```python
            class Solution:
                def maximalSquare(self, matrix: List[List[str]]) -> int:
                    num_rows, num_cols = len(matrix), len(matrix[0])
                    
                    # edge case
                    if num_rows == 1 and num_cols == 1:
                        return 1 if matrix[0][0] == '1' else 0
            
                    max_side_length = 0
            
                    for i in range(num_rows):
                        for j in range(num_cols):
                            # check current cell 
                            if matrix[i][j] != '1': 
                                continue 
                            # current cell = top-left cell in the current square
                            valid_square = True                 
                            side_length = 1                
                            # check boundary validity 
                            while valid_square and i + side_length < num_rows and j + side_length < num_cols:               
                                # check bottom-right cell validity 
                                bottom = i + side_length
                                rightmost = j + side_length 
                                # check bottom row validity 
                                for c in range(j, rightmost+1):
                                    if matrix[bottom][c] != '1': 
                                        valid_square = False
                                        break 
                                # check rightmost column validity
                                for r in range(i, bottom+1):
                                    if matrix[r][rightmost] != '1':
                                        valid_square = False
                                        break 
            
                                # prize en finale!
                                if valid_square:       
                                    side_length += 1 
                            
                            # aggregate the result from the current cell
                            max_side_length = max(max_side_length, side_length) 
            
                    return max_side_length ** 2
            ```
            
        - Î≥µÏû°ÎèÑ Î∂ÑÏÑù
            - ÏãúÍ∞Ñ: O((mn)^2)
                - top-left cell ÌõÑÎ≥¥ Í∞úÏàò double for loop ‚Üí m*n
                - Í∞Å top-left cellÏóêÏÑú ÏÇ¨Í∞ÅÌòï Í∏∏Ïù¥Í∞Ä 1, 2, ‚Ä¶, kÎ°ú ÎäòÏñ¥Í∞à Îïå additional bottom row & right col Ï≤¥ÌÅ¨
                    - ÏÇ¨Í∞ÅÌòï Í∏∏Ïù¥Í∞Ä k Ïùº Îïå 2kÍ∞úÏùò cellÏùÑ Ï≤¥ÌÅ¨ÌïòÎäî ÏÖà
                    - ÏÇ¨Í∞ÅÌòï Í∏∏Ïù¥Îäî 1, 2, ‚Ä¶, k ‚Üí k(k+1)/2 * 2 = k^2 + k
                    - Í∞ÄÏû• Í≥†Ï∞®Ìï≠Îßå ÎÇ®Í∏∞Î©¥ k^2
                    - Ïù¥ Îïå kÎäî min(m, n) Ïù¥Í∏∞ ÎïåÎ¨∏Ïóê, ÌïòÎÇòÏùò top-left cellÏóê ÎåÄÌï¥ Í≤ÄÏÇ¨Ìï¥Ïïº ÌïòÎäî cellÏùò Í∞úÏàòÎäî min(m, n)^2
                
                ‚áí cell Í∞úÏàò * ÌïòÎÇòÏùò cell Îãπ Í≤ÄÏÇ¨Ìï¥Ïïº ÌïòÎäî ÏùºÏùò ÏÉÅÌïú = O(m*n*min(m, n)^2)
                
                - min(m, n)^2 < m*n ÏùºÌÖåÎãà Îã®ÏàúÌôîÌï¥ÏÑú O((mn)^2))ÎùºÍ≥† Ìïú ÎìØ
            - Í≥µÍ∞Ñ Î≥µÏû°ÎèÑ: O(1). Ï∂îÍ∞ÄÎ°ú ÌïÑÏöîÌïú Í≥µÍ∞Ñ ÏóÜÏùå
    - **Dynamic Programming**
        - Algorithm
            - dp matrix Ï¥àÍ∏∞Ìôî
                - size: input matrixÏôÄ ÎèôÏùº. m * n
                - Ï¥àÍ∏∞ cell value: 0
            - state definition
                - `dp[i,j]` : bottom-right corner Í∞Ä matrix[i][j]Ïù∏ ÏÇ¨Í∞ÅÌòï Ï§ë Í∞ÄÏû• ÌÅ¨Í∏∞Í∞Ä ÌÅ∞ ÏÇ¨Í∞ÅÌòïÏùò side length
            - recurrence relation
                - dp[i, j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1
            - Í∑∏Î¶º ÏòàÏãú
                
                ![Untitled](Untitled%20201.png)
                
                - dp[2][3] = ?
                    - dp[1][3] = 2 Ïùò ÏùòÎØ∏
                        - original matrix[1][3]ÍπåÏßÄ Í≥†Î†§ÌñàÏùÑ Îïå, Í∞ÄÎä•Ìïú Í∞ÄÏû• ÌÅ∞ Ï†ïÏÇ¨Í∞ÅÌòï ÌïúÎ≥ÄÏùò Í∏∏Ïù¥Îäî 2 ÎùºÎäî ÏùòÎØ∏
                    - dp[1][2], dp[2][2]ÎèÑ 2 Ïù∏ ÏÉÅÌÉú
                    - Ìïú Î≥ÄÏùò Í∏∏Ïù¥Í∞Ä 3Ïù∏ Ï†ïÏÇ¨Í∞ÅÌòïÏùÑ ÏñªÏùÑ Ïàò ÏûàÎäîÏßÄ Ïó¨Î∂ÄÎäî original matrix[2][3]Ïóê Îã¨Î†§ ÏûàÏùå ‚Üí Ìï¥Îãπ cell Í∞íÎèÑ 1ÏûÑ ‚Üí dp[2][3]Ïóê 3Ïù¥ Îì§Ïñ¥Í∞à Ïàò ÏûàÏùå
                - dp[3][4] = ?
                    - dp[2][3], dp[3][3] Î™®Îëê Í∞íÏù¥ 3 = Í∞Å cellÏùÑ bottom-rightÎ°ú ÌïòÎäî Ï†ïÏÇ¨Í∞ÅÌòïÏùÄ ÏµúÎåÄ 3 by 3ÍπåÏßÄ Í∞ÄÎä•
                    - Í∑∏Îü¨ÎÇò dp[2][4] = 1 ‚Üí dp[3][4]ÏóêÏÑúÎäî matrix[3][4]Î•º bottom rightÎ°ú Ìï† Îïå ÏµúÎåÄ Í∏∏Ïù¥Í∞Ä 2Ïù∏ ÏÇ¨Í∞ÅÌòï Î∞ñÏóê ÎßåÎì§ÏßÄ Î™ªÌï®. (bottom right cell ÏûêÏ≤¥Í∞Ä Í∏∏Ïù¥ 1Ïù∏ ÏÇ¨Í∞ÅÌòï + Î∞îÎ°ú Ìïú Ïπ∏ ÏúÑÏù∏ matrix[2][4]ÍπåÏßÄÎßå 1Ïù¥ Î≥¥Ïû•ÎêòÏñ¥ ÏûàÍ∏∞ ÎïåÎ¨∏Ïóê = 2)
                    - Îî∞ÎùºÏÑú dp[3][4] = 2
        - Î≥µÏû°ÎèÑ Î∂ÑÏÑù
            - ÏãúÍ∞Ñ Î≥µÏû°ÎèÑ: O(m*n). Í∞Å bottom-right cellÏóêÏÑú Ìï¥Ïïº ÌïòÎäî ÏùºÏù¥ ÏÉÅÏàò O(1)
            - Í≥µÍ∞Ñ Î≥µÏû°ÎèÑ: O(m*n). dp matrix sizeÎäî original matrix sizeÏôÄ ÎèôÏùº
    - **Better Dynamic Programming**
        - Í≥µÍ∞ÑÎ≥µÏû°ÎèÑ Îçî Ï§ÑÏù¥Í∏∞ (O(mn) ‚Üí O(n)). Í≤∞Íµ≠ ÌïÑÏöîÌïú Í±¥
            
            ![Untitled](Untitled%20202.png)
            
            - dpÎ•º num_cols ÌÅ¨Í∏∞Î°ú Ï¥àÍ∏∞Ìôî
            - ÌòÑÏû¨ Íµ¨ÌïòÎ†§Îäî Í∞í: dp[j] (matrix Í∏∞Ï§ÄÏúºÎ°úÎäî i,j Ïù¥ÏßÄÎßå iÎäî Î¨¥Ïãú)
                - matrix[i][j]Í∞Ä 0Ïù¥Î©¥ Í∑∏ÎåÄÎ°ú 0.
                - matrix[i][j]Í∞Ä 1Ïù¥Î©¥,
                    - dp[j] = min(dp[j-1], prev, dp[j]) + 1
                    - dp[j-1]ÏóêÎäî Í∞ôÏùÄ row, previous columnÏùò ÏµúÎåÄÍ∞í Ï†ÄÏû•
                        - Í∞ôÏùÄ i Í∞íÏóêÏÑú inner for loopÏùÑ ÎèåÎ©¥ÏÑú Ï±ÑÏõåÏßÄÎäî Í∞íÎì§
                    - dp[j]ÏóêÎäî Í∞ôÏùÄ col, previous rowÏùò ÏµúÎåÄÍ∞í Ï†ÄÏû•
                        - Ïù¥Î≤àÏóê dp[j] ÏóÖÎç∞Ïù¥Ìä∏ ÌïòÍ∏∞ Ï†Ñ ÏÉÅÌÉúÎäî matrix[i-1][j] cellÏù¥ bottom right cellÏùº Îïå Í≥ÑÏÇ∞Ìïú Í∞í
                        - outer for loop Í∞íÏùÄ Îã¨ÎùºÏßÄÍ≥†, inner for loopÏóêÏÑúÎäî Í∞ôÏùÄ Ï∞®Î°Ä
                    - prevÏóêÎäî inner for loop ÌïòÎÇò Ï†ÑÏóêÏÑú temp‚ÜíprevÎ°ú Î∞îÎÄê Í∞íÏùÑ Í∞ñÍ≥† ÏûàÏùå
                        - tempÎäî dp[j] ÏóÖÎç∞Ïù¥Ìä∏ ÌïòÍ∏∞ Ï†Ñ Í∞í Ï¶â, outer for loop ÌïòÎÇò Ï†ÑÏóêÏÑú Íµ¨Ìïú Í∞íÏùÑ Ï†ÄÏû•Ìï¥ ÎëêÏóàÏùå
                        - Îî∞ÎùºÏÑú inner for loopÎèÑ ÌïòÎÇò Ï†Ñ, outer for loopÎèÑ ÌïòÎÇò Ï†ÑÏùò Í∞íÏùÑ Í∞ñÍ≥† ÏûàÎäî ÏÖà
- Trial
    - Editorial Î≥¥Í≥† Ïß∞ÎäîÎç∞ Ïôú ÏòàÏ†úÎèÑ ÌÜµÍ≥º Î™ªÌïòÏßÄ
        
        ```python
        class Solution:
            def maximalSquare(self, matrix: List[List[str]]) -> int:
                num_rows, num_cols = len(matrix), len(matrix[0])
                dp = [[0] * num_cols for _ in range(num_rows)]
        
                # base case
                ## edge cell as bottom-right cell -> max side length is always 1 
                for i in range(num_rows):
                    dp[i][0] = int(matrix[i][0])
                for j in range(num_cols):
                    dp[0][j] = int(matrix[0][j])
                
                # recurrence relation 
                for i in range(1, num_rows):
                    for j in range(1, num_cols):
                        if matrix[i][j] != '1':
                            continue
                        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1
                
                return dp[-1][-1]
        ```
        
- ÎÜìÏ≥§Îçò Ï†ê
    - return Í∞íÏùÄ dp[-1][-1]Ïù¥ ÏïÑÎãàÎã§ - dp matrixÏóêÏÑú Í∞ÄÏû• ÌÅ∞ Í∞íÏùò Ï†úÍ≥±(ÎÑìÏù¥)
        - Í∑ºÎç∞ Îã§ Í≥ÑÏÇ∞ÌïòÍ≥† ÎßàÏßÄÎßâÏóê ÌïúÎ≤à Îçî ÎèåÎ©¥ÏÑú ÏµúÎåÄÍ∞í Íµ¨ÌïòÎ†§Î©¥ Î≤àÍ±∞Î°úÏö∞Îãà
        - Í∞Å cell Í∞íÏùÑ Íµ¨Ìï† ÎïåÎßàÎã§ ÏµúÎåÄÍ∞íÏùÑ ÎØ∏Î¶¨ ÎØ∏Î¶¨ update Ìï¥ÎëîÎã§
- AC ÏΩîÎìú (‚ö°Ô∏è)
    
    ```python
    class Solution:
        def maximalSquare(self, matrix: List[List[str]]) -> int:
            num_rows, num_cols = len(matrix), len(matrix[0])
            dp = [[0] * num_cols for _ in range(num_rows)]
            max_side_length = 0
            # base case
            ## edge cell as bottom-right cell -> max side length is always 1 
            for i in range(num_rows):
                dp[i][0] = int(matrix[i][0])
                max_side_length = max(max_side_length, dp[i][0])
            for j in range(num_cols):
                dp[0][j] = int(matrix[0][j])
                max_side_length = max(max_side_length, dp[0][j])
            
            # recurrence relation 
            for i in range(1, num_rows):
                for j in range(1, num_cols):
                    if matrix[i][j] != '1':
                        continue
                    dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1
                    max_side_length = max(max_side_length, dp[i][j])
    
            
            return max_side_length ** 2
    ```
    
- AC ÏΩîÎìú (Í≥µÍ∞Ñ Î≥µÏû°ÎèÑ Í∞úÏÑ†, ‚ö°Ô∏è)
    
    ```python
    class Solution:
        def maximalSquare(self, matrix: List[List[str]]) -> int:
            num_rows, num_cols = len(matrix), len(matrix[0])
            dp = [0] * num_cols 
            max_side_length, prev = 0, 0
    
            # recurrence relation 
            for i in range(num_rows):
                prev = 0 # reset prev for each new row 
                for j in range(num_cols):
                    temp = dp[j] # save the result from the previous row 
                    
                    if matrix[i][j] == '1':      
                        # base case 
                        if i == 0 or j == 0:
                            dp[j] = 1
                        # recurrence relation
                        else:
                            # use of old prev
                            dp[j] = min(dp[j-1], prev, dp[j]) + 1
                        max_side_length = max(max_side_length, dp[j])
                    else:
                        dp[j] = 0 
    
                    prev = temp # updated prev
            
            return max_side_length ** 2
    ```