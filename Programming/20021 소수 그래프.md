# 20021. 소수 그래프

Status: GG
Theme: SWEA
Created time: April 4, 2024 8:20 PM
Last edited time: April 5, 2024 11:36 AM

- 문제 이해
    - 3 이상 1000 이하의 자연수 n이 주어질 때, 아래 조건을 모두 만족하는 무향 그래프가 존재하는지 판단하고, 존재한다면 아무거나 하나를 구하는 프로그램을 작성하라.
        - 정점의 개수는 n개이다. 각각의 정점에는 1 이상 n 이하의 서로 다른 자연수 번호가 하나씩 붙어 있다.
        - 간선의 개수는 소수(prime number)이다.
            - 0은 소수가 아님
            - 전체 간선의 개수겠지?
        - 모든 정점의 차수(degree, 해당 정점과 연결되어 있는 간선의 수)는 소수(prime number)이다.
            - 근데 같은 숫자일 필요는 없음
            - 대신 다 더해서 소수가 되어야 한다는 거겠지?
            - 모든 정점의 차수의 합은 간선의 개수 * 2
        - 그래프는 단순 그래프(simple graph)이다. 즉, 같은 정점을 잇는 간선이나, 같은 정점 쌍을 잇는 두 개 이상의 간선이 존재하면 안 된다.
            - 1, 2 연결하는 간선은 하나면 됨. 2, 1 필요 없음
        - 그래프가 연결되어 있을 필요는 없다.
            - 그치만 간선이 없는 노드는 없을 걸. degree가 소수인데
        - 어떤 자연수 k가 소수(prime number)라는 것은, k가 2 이상이며, k의 양의 약수가 1과 k뿐이라는 것과 같다.
            - 0도 아니고 1도 안되는구나
    - 과정
        - 1에서 n까지 소수가 최소 n개여야 함 - 각 정점의 차수가 소수여야 하니까
        - 그리고 다 더해서도 소수가 되어야 함
        - 에지 리스트에서 나온 알파벳(정점) 개수를 세는 것으로 각 노드의 차수를 쉽게 알 수 있습니다.
    - 각 노드별 차수까지는 구했는데, 어떻게 valid graph로 만들어야 하는지 모르겠음
- Trial
    - 차수 → 그래프 만들기에서 실패
        
        ```sql
        from itertools import combinations_with_replacement
        
        def prime_graph(n_nodes):
            def is_prime(k):
                for i in range(2, int(k ** 0.5)+1):
                    if k % i == 0:
                        return False
                return True
        
            def get_edges(comb):
                print(sum(comb)//2)
                edge_dict = {i:[] for i in range(1, n_nodes+1)}
                for i, num in enumerate(comb):
                    end = 1
                    for _ in range(num):
                        #if i + 1 in edge_dict[end]:
                            #continue
                        if end == i+1:
                            end += 1
                        if end not in edge_dict[i+1]:
                            edge_dict[i+1].append(end)
                        if i+1 not in edge_dict[end]:
                            edge_dict[end].append(i+1)
                        end += 1
                sum_ans = 0
                for key in edge_dict:
                    sum_ans += len(edge_dict)
        
                return True, edge_dict
        
            prime_nums = []
            for i in range(2, n_nodes):
                if is_prime(i):
                    prime_nums.append(i)
        
            flag = False
            for comb in combinations_with_replacement(prime_nums, n_nodes):
                sum_comb = sum(comb)
                if sum_comb % 2 != 0:
                    continue
                if sum_comb // 2 > 13:
                    continue
                if is_prime(sum_comb//2):
                    print(comb)
                    valid, edge_dict = get_edges(comb)
                    if not valid:
                        continue
                    if valid:
                        print(sum_comb // 2)
                        for k, v in edge_dict.items():
                            print(k, len(v))
                        flag = True
                        '''
                        for key in edge_dict:
                            for val in edge_dict[key]:
                                print(key, val)
                        flag = True
                        '''
        
            if not flag:
                print(-1)
        
        n = int(input())
        for t in range(1, n+1):
            num_nodes = int(input())
            prime_graph(num_nodes)
        
        ```
        
    - 간선에서 조합을 찾기
        
        ```sql
        from itertools import combinations
        def prime_graph(n_nodes):
            def is_prime(k):
                if k == 0 or k == 1:
                    return False
                for i in range(2, int(k ** 0.5)+1):
                    if k % i == 0:
                        return False
                return True
        
            # 가능한 모든 간선 생성
            all_possible_edges = list(combinations(range(1, n + 1), 2))
        
            def check_prime_conditions(edges, n):
                # 노드의 차수 계산
                degrees = [0] * n
                for edge in edges:
                    # idx: node_num-1
                    degrees[edge[0] - 1] += 1
                    degrees[edge[1] - 1] += 1
        
                # 모든 노드의 차수가 소수인지 확인
                if not all(is_prime(deg) for deg in degrees):
                    return False
        
                # 전체 간선의 개수의 절반도 소수인지 확인
                if not is_prime(len(edges) // 2):
                    return False
        
                return True
        
            # 조건을 만족하는 간선의 조합을 찾습니다.
            for r in range(2, len(all_possible_edges) + 1):  # 최소 1개의 간선부터 시작
                for edges_subset in combinations(all_possible_edges, r):
                    if check_prime_conditions(edges_subset, n_nodes):
                        print("조건을 만족하는 간선 집합:", edges_subset)
                        break  # 조건을 만족하는 첫 번째 조합을 찾으면 반복을 중단합니다.
                else:
                    continue
                break  # 조건을 만족하는 조합을 찾으면 바깥쪽 반복도 중단합니다.
        
        n = int(input())
        for t in range(1, n+1):
            num_nodes = int(input())
            prime_graph(num_nodes)
        
        ```