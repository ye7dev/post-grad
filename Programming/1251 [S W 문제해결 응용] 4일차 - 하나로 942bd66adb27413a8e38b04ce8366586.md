# 1251. [S/W 문제해결 응용] 4일차 - 하나로

Created time: April 7, 2024 9:35 PM
Last edited time: April 7, 2024 10:34 PM

- AC 코드
    - 내 답안-union find → Kruskal
        
        ```python
        import heapq
        
        class UnionFind:
            def __init__(self, n):
                self.rank = [1] * n
                self.root = [i for i in range(n)]
        
            def find(self, x):
                if x != self.root[x]:
                    self.root[x] = self.find(self.root[x])
                return self.root[x]
        
            def union(self, x, y):
                root_x, root_y = self.find(x), self.find(y)
                if root_x != root_y:
                    if self.rank[root_x] > self.rank[root_y]:
                        self.root[root_y] = root_x
                    elif self.rank[root_x] < self.rank[root_y]:
                        self.root[root_x] = root_y
                    else:  # equal
                        self.root[root_y] = root_x
                        self.rank[root_x] += 1
            def connected(self, x, y):
                return self.find(x) == self.find(y)
        
        def get_min_cost(X, Y):
            min_cost = 0
            n = len(X)
            UF = UnionFind(n)
            all_edges = []
            for i in range(n):
                for j in range(i+1, n):
                    weight = (X[i]-X[j]) ** 2 + (Y[i]-Y[j]) ** 2
                    heapq.heappush(all_edges, [weight, i, j])
        
            while all_edges:
                cur_weight, i, j = heapq.heappop(all_edges)
                if not UF.connected(i, j):
                    #print(cur_weight, i, j)
                    min_cost += cur_weight
                    UF.union(i, j)
        
            return min_cost
        
        T = int(input())
        for t in range(1, T+1):
            N = int(input())
            X = list(map(int, input().split()))
            Y = list(map(int, input().split()))
            E = float(input())
            ans = round(get_min_cost(X, Y) * E)
            print(f'#{t} {ans}')
        ```
        
    - 남의 답안-prim
        - 이 과정에서 필요한 반복 횟수는 정확히 노드의 수 **`N`** 만큼입니다. 각 반복마다 MST에 새로운 노드를 추가하게 되므로, 전체 노드가 MST에 포함되면 반복이 종료됩니다.
        
        ```python
        for tc in range(1, int(input()) + 1):
            N = int(input())
            X = list(map(int, input().split()))
            Y = list(map(int, input().split()))
            E = float(input())
            mst = [False] * N
            cur = 0
            mst[0] = True
            cnt = 0
            INF = float('inf')
            shortcut = [INF] * N
            shortcut[0] = 0
            for cnt in range(N):
                mini = INF
                new = -1
                for des in range(N):
                    if not mst[des]:
                        dist = (X[cur] - X[des])**2 + (Y[cur] - Y[des])**2
                        if dist < shortcut[des]:
                            shortcut[des] = dist
                        if shortcut[des] < mini:
                            mini = shortcut[des]
                            new = des
                mst[new] = True
                cur = new
            answer = round(sum(shortcut) * E)
            print("#{} {}".format(tc, answer))
        ```