# 10507. 영어 공부

Created time: May 2, 2024 5:16 PM
Last edited time: May 3, 2024 11:28 AM

- Lessons
    1. 이진탐색으로 푸는 경우 
        1. 전체 흐름 
            1. 주어진 공부한 날들 사이의 공부 안한 날들을 계산
                - 계산 편리를 위해 특정 공부 한 날에서 첫번째 공부 한 날 사이의 공부 안한 날들을 미리 계산해 둔다
                - 미리 계산해 둔 공부 안한 날을 바탕으로 어느 두 공부한 날짜 사이의 공부 안한 날을 모두 계산할 수 있다
            2. p로 커버칠 수 있는 범위 내에서, 어느 공부 한 두 날 사이의 공부 안한 날을 채웠을 때, 최대 연속 날짜가 얼마나 되는지 계산한다
                - 그 중 가장 큰 날이 정답
        2. 이진탐색의 용도
            - p로 커버칠 수 있는 범위 중 가장 큰 범위(가장 큰 공부 안한 날)를 탐색
                - target보다 작거나 같은 값 중 가장 큰 값을 찾는 이진 코드
                    
                    ```python
                    def find_largest_le(nums, target):
                        if not nums:
                            return None
                        
                        left, right = 0, len(nums) - 1
                        result = None
                        
                        while left <= right:
                            mid = (left + right) // 2
                            
                            # 찾고자 하는 target 값보다 현재 중간값이 작거나 같다면
                            # 이 값이 현재까지의 최대값이 될 수 있으므로 result를 업데이트하고
                            # 더 큰 값을 찾기 위해 오른쪽 부분을 탐색합니다.
                            if nums[mid] <= target:
                                result = nums[mid]
                                left = mid + 1
                            else:
                                # 중간값이 target보다 크다면 target보다 작은 값들 중 최대값을
                                # 찾기 위해 왼쪽 부분을 탐색합니다.
                                right = mid - 1
                        
                        return result
                    
                    ```
                    
            - 범위 시작점은 모든 공부한 날이 다 가능 - 한번의 이진탐색으로 끝나는게 아니라, for loop 돌아야 하는 점 주의
    2. 투포인터로 푸는 경우 
        1. 전체 흐름 
            - init
                - start, end는 같은 점 → 둘 사이의 구간은 0. end는 exclusive boundary
                - max_range 는 P + 1. 공부한 날이 최소 1개는 들어오고, 1개 + P개 써서 연속으로 만들면 P+1의 값은 언제든지 얻을 수 있기 때문에
                - 주어진 공부한 날짜들을 바탕으로 studied라는 array를 만든다. studied[i]: i번째 날에 공부했으면 1, 아니면 0
            - transition
                - 기본 원리: start는 갈 때까지 간 다음에 움직이고, 아직 수월하게 이동이 가능할 때는 end를 뒤로 더 보낸다
                - 수월하게 이동이 가능한 때
                    - end가 이미 공부한 날일 때
                    - P가 아직 남아 있어서 end를 커버쳐줄 수 있을 때
                    - end가 이동하면서 현재 range가 하나 더 커지고, update된 range 값이 max_range와 비교해서 어느 쪽이 더 큰지 확인한다
                - 갈 때까지 간 상황
                    - 현재 end는 공부를 안해서 커버업이 필요한데 P가 0인 경우 → 현재 start로는 더 진전할 방법이 없음
                    - 다음 start로 넘어간다
                        - 단, 현재 start가 커버업된 상태였으면, 넘어가면서 start를 가렸던 P를 하나 뺏어와서 다른 곳에 사용 가능한 상태로 만들어준다
                        - end는 아직 이동하지 않은 상황에서 start만 하나 밀었으므로 range가 하나 줄었고, 이 구간에 대해 range 상태 update 하고, max_range랑 값 비교한다

- 문제 이해
    - 영어 공부 한 날에는 점수가 전날보다 1씩 쌓이고, (누적)
    - 접속하지 않으면 점수가 0이 되는 연속 공부 기간 점수  (누적 다시 원점으로)
    - 그 동안 적립했던 점수 중 최댓값으로 경쟁 → 연속 기간이 길면 길수록 유리
    - p개 날짜에 대해서도 체크할 수 있음 → 연속 기간의 최대 가능 길이를 구하라
- AC 코드
    - 투포인터
        
        ```python
        def cover_to_max(p):
            # last: 가능한 마지막 날
            cur_start, cur_end = 0, 0  # cur_end: exclusive boundary
            cur_window_size = 0  # cur_end - cur_start
            max_window_size = p + 1
        
            while cur_end <= last_day:
                if studied[cur_end]:  # no need to cover -> proceed
                    cur_end += 1
                    cur_window_size += 1
                    max_window_size = max(max_window_size, cur_window_size)
                else:
                    if p == 0:  # cover up이 더 이상 없다
                        if not studied[cur_start]:
                            p += 1  # start에서 뺏어오기
                        cur_start += 1
                        cur_window_size -= 1
                    else:
                        p -= 1  # end 커버업
                        cur_end += 1
                        cur_window_size += 1
                        max_window_size = max(max_window_size, cur_window_size)
        
            return max_window_size
        
        T = int(input())
        for t in range(1, T+1):
            N, P = map(int, input().split())
            days = list(map(int, input().split()))
            last_day = days[-1]
            studied = [0] * (last_day + 1)
            for d in days:
                studied[d] = 1
            ans = cover_to_max(P)
            print(f'#{t} {ans}')
        
        ```
        
    - 이진탐색
        
        ```python
        def cover_to_max(p):
            max_ans = p + 1
            for cur_start in range(N):  # N의 최소값은 1
                left, right = cur_start, N-1  # left, right update -> mid == end가 바뀌는 것
                while left <= right:
                    cur_end = (left + right) // 2  # 사실은 이게 범위의 end
                    # start는 고정되어 있다
                    cur_gap = gaps[cur_end] - gaps[cur_start]
                    if cur_gap <= p:
                        left = cur_end + 1
                        remain_p = p - cur_gap
                        cur_coverage = days[cur_end] - days[cur_start] + 1  # inclusive range
                        max_ans = max(max_ans, cur_coverage + remain_p)
                    else:
                        right = cur_end - 1
            return max_ans
        
        T = int(input())
        for t in range(1, T+1):
            N, P = map(int, input().split())
            days = list(map(int, input().split()))
            gaps = [0] * N
            for i in range(1, N):
                gaps[i] = gaps[i-1] + days[i] - days[i-1] - 1
            ans = cover_to_max(P)
            print(f'#{t} {ans}')
        
        ```
        
- scratch
    - maximum subsequence 길이
    - n=5, p=2
        - 공부한 날: 3, 5, 6, 10, 11
        - 0 0 1 0 1 1 0 0 0 1 1
        - 두 번의 기회를 4, 7에 쓰면 3, 4, 5, 6, 7 총 5일 연속
        - dp..일까나?
    - 모르겠음. 다른 사람 코드 보자
- 남의 코드 이해
    - 이진탐색
        
        ```python
        # blank 만들기 
        blank_count = 0
        blanks = [0]  # 맨 첫 날짜까지는 공백 X
        
        for j in range(n - 1):
            blank_count += days[j + 1] - days[j] - 1
            blanks.append(blank_count)
        
        def binary_search(n, p, days, blanks):
            max_period = 0
            for i in range(n):
                start = i
                end = n - 1
                answer = 0
                while end >= start:
                    mid = start + (end - start) // 2
                    didnt_study = blanks[mid] - blanks[i]
                    cur_p = max(0, p - didnt_study)
        
                    if didnt_study > p:
                        end = mid - 1
                    else:
                        answer = days[mid] - days[i] + 1 + cur_p
                        start = mid + 1
        
                if max_period < answer:
                    max_period = answer
            return max_period
        
        ```
        
        - blanks[i] =  days[i] - days[0] - i
            - days[i]와 days[0] 사이의 불연속적인 공백이 존재
            - 두 날짜 사이의 (경계 exclusive) 전체 날 수: days[i]-days[0]-1
            - 두 날짜 사이에 공부한 전체 날의 수: i-0-1 = i-1
            - 전체 날 수 - 공부한 전체 날 수
                
                = days[i] - days[0] -1 - (i-0-1) = days[i] - days[0] -1 -i +1 
                
                = days[i] - days[0] - i 
                
            - 식을 안 풀고 누적식 자체만 보면 days[i] += days[i]-days[i-1]-1
                - 바로 직전 공부한 날과 이번 공부한 날 사이의 순수 공백 = 공부 안한 날 수
                - 만큼 씩 모든 구간에 대해 더해주는 것
        - blanks[mid] - blanks[i]
            
            ⇒ days[mid]와 days[i] 사이의 공부 안한 날 전체 수 
            
            = days[mid] - days[0] - mid - (days[i] - days[0] - i)
            
            = days[mid] - days[i] - (mid - i)
            
            - days[mid]와 days[i] 사이(경계 exclusive)의 전체 날 수 : days[mid]-days[i]-1
            - days[mid]와 days[i] 사이의 전체 공부한 날의 수 : mid - i - 1
                - days list에서 index mid와 index i 사이의 exclusive 범위에서 원소가 몇 개 존재하는지 세면 mid - i -1
            - 전체 날 수에서 공부 안한 전체 날 수 빼면, days[mid] - days[i] - 1 - (mid - i -1) = days[mid] - days[i] -1 -mid + i + 1 = days[mid]-days[i] - (mid-1)
        - 예시
            - n, p = 5, 2
            - days = [3 5 6 10 11]
            - blanks = [0, 1, 1,
                - 0이 이미 리스트에 추가된 채로 시작한다.
                    - 공부 한 첫 날과 같은 날 사이의 간격은 없기 때문에 공부 안한 날이 존재할 수가 없다
                - j = 0~3
                - days[1] = days[1] - days[0] -1 = 1
                - days[2] = days[1] - days[0] -1 + days[2] - days[1] -1
                    
                    = days[2]-days[0]-2= 6-3-2 = 1-0 = 1
                    
                - days[3] = days[3]-days[0]-1-(3-0-1) = days[3]-days[0]-3 = 10-3-3 = 4
                    - 10일과 3일 사이의 공부 안한 날 총 수: 1(4일) + 3(7, 8, 9일) = 4
            - i: 0~3
                - i = 0
                    - start = 0, end = 3 → mid = 1
                    - didn’t study = blanks[1] - blanks[0] = -1
                    - cur_p = 2- (-1) = 3
                
    - 투포인터
        - visited 배열을 만들어두고, 공부한 날만 True로 표시한다
        
        ```python
        def search(last, visited, P):
        		# last: 공부한 마지막 날 
            start = 1
            end = 1
            num = 0 # start와 end 사이의 거리(경계는 둘 중 하나만 inclusive?)
            max_val = P + 1  
        
            while end < last + 1:
                if visited[end]: # 공부한 날 -> 연속 구간 하루 더 늘어남
                    num += 1 # 구간 크기 
                    end += 1 # 연속 구간 끝 경계 
                    max_val = max(max_val, num) # 가장 큰 구간 record
                else:
                    if P == 0: # 공부한 날이 아닌데, 커버칠 찬스도 남아 있지 않음 
                        max_val = max(max_val, num) # 현재 상태 구간 record 
                        if not visited[start]: # 구간 첫날을 P 중 하나로 커버친 상태였음 
                            P += 1 # start 지점에서 사용된 커버 찬스를 하나 회수 
                        start += 1 # 구간 첫날은 이제 커버를 벗었으므로 유효 범위에서 제외 
                        num -= 1 # 구간 크기도 하나 제외 
                    else:
                        P -= 1 # 아직 커버 찬스가 남아 있으므로 
                        num += 1 # 구간 크기가 1 증가했음 
                        end += 1 # end를 커버치고 다음 경계로 넘어감 
            return max_val
        ```
        
        - 좀 더 직관적으로 내가 rephrase 하면…
            
            ```python
            def cover_to_max(last, studied, P):
                # last: 가능한 마지막 날
                cur_start, cur_end = 0, 0  # cur_end: exclusive boundary
                cur_window_size = 0  # cur_end - cur_start
                max_window_size = P + 1 
            
                while cur_end <= last:
                    if studied[cur_end]:  # no need to cover -> proceed
                        cur_end += 1
                        cur_window_size += 1
                        max_window_size = max(max_window_size, cur_window_size)
                    else:
                        if P == 0:  # cover up이 더 이상 없다
                            if not studied[cur_start]:
                                P += 1  # start에서 뺏어오기
                            cur_start += 1
                            cur_window_size -= 1
                        else:
                            P -= 1 # end 커버업
                            cur_end += 1 
                            cur_window_size += 1
                            max_window_size = max(max_window_size, cur_window_size)
                            
                return max_window_size
            
            ```
            
- 이진탐색에서 특정 구간에 대한 답을 구하는 법
    - gaps[i]: days[i]-days[0]-i
        - -1 : exclusive 구간 위해서
        - -(i-1): 두 날짜 사이의 공부한 날의 개수
            - 1, …, i-1인데 두 경계 모두 inclusive
    - gaps[end] - gaps[start]
        
        = days[end] - days[0] - end - days[start] + days[0] + start 
        
        = days[end] - days[start] - (end-start)
        
        → end와 start 사이의 순수 공백