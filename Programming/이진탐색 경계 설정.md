# 이진탐색 경계 설정

- [x]  나무자르기 문제부터 이어서
- [ ]  lower-bound, upper-bound 이어서
- 이해한 내용
    - 구한 경계에서 답이 left 인지 right인지 생각해보고 return
    - 예제: 1~50개의 오름차순 정렬된 카드 더미 → 28번 카드를 찾는 문제
        - 결정 문제 - 찾을 수 있냐 없냐
            - deck[i] ≥ 28의 답은 i가 증가함에 따라 [F, F, …, F, T, T, … T]
            - 우리가 찾고자 하는 값은 처음으로 deck[i] ≥ 28인 지점 = 처음으로 T가 나오는 위치
                - 이 답을 기준으로 문제의 답이 두 구간으로 나뉨 F | T
        - 1개의 파라미터 - 카드 인덱스
    - 경계를 포함하는 구간 `[left, right]` (inclusive) 설정
        - 구간의 길이를 절반씩 줄여나가며 left, right가 경계 지점에 위치하도록 하는 것
            - BS 끝난 뒤에 left 다음 칸은 right이고, check(left) ≠ check(right)
                - [F, F, …, F, T, T, …, T] 에서 left는 제일 마지막 F, right는 제일 첫 T 자리에 오게 됨
                - 정답이 가장 큰 F면 low를 return, 가장 작은 T면 right를 return
    - 어떤 조건을 만족하는 x의 최댓값(최소값) 찾는 문제 = 최적화 문제는 BS로 많이 풀린다고 함
    - 구현 방법
        - check(left) ≠ check(right)가 되도록 left, right 초기 값을 설정
            
            → 결정 문제의 답이 바뀌는 경계는 반드시 [left, right] 사이에 있다 
            
        - 진행
            
            ```python
            while (left + 1) < right: # 무조건 left, right 사이에는 한 개의 칸이 있다 
            	mid = (left + right) // 2 
            	if check(mid) == check(left): # 결정 경계는 여기에 없다 
            			left = mid  # 새로운 범위: [mid, right]
            	else:
            			right = mid  # 새로운 범위: [left, mid] 
            ```
            
        - left + 1 == right (left 바로 뒤에 right) 되면 탈출. left, right는 경계에 위치
            
            ![Untitled](Untitled%20227.png)
            
            ![Untitled](Untitled%20228.png)
            
- 모르겠는 내용
    - [x]  check function
        
        → check(x): 결정 문제의 parameter가(값이) x 일 때 결정 문제의 답 
        
    - [x]  [left, right]가 Check(left) != Check(right)가 되도록 구간을 설정
    - [x]  code
    - [x]  구간의 길이를 절반씩 줄여나가며 left, right가 경계 지점에 위치하도록 하는 것
    - [x]  이제 lo + 1 < hi인 동안 [lo, hi]를 [lo, mid] 또는 [mid, hi]로 줄여나가는데, 이 경우 Check(lo), Check(hi)는 바뀌지 않습니다. 이유는 Check(lo) == Check(mid)라면 lo = mid를, Check(hi) == Check(mid)라면 hi = mid를 하기 때문입니다.
        
        → left나 right를 mid로 업데이트해도, 기존 결정 경계에서의 값, 즉, check[left](left = mid)와 check[right](right=mid)는 바뀌지 않는다
        
    - [x]  반복문을 탈출했다면 lo + 1 >= hi인데 lo < mid < hi인 mid를 대입하기 때문에 lo < hi이고, 두 조건을 만족하는 lo, hi는 lo + 1 == hi인 경우밖에 없습니다)
        
        → lo에 mid를 대입해도 lo (mid) < hi이고, hi에 mid를 대입해도, lo < hi(mid) 
        
        → low < high 이면서 low +1 ≥ high 만족하는 경우는 low = high 밖에 없다 
        
        - low + 2 = high 인 경우
            - low < high 만족하지만 low + 1 < high (low+2)라서 성립 안됨
        - low = high인 경우
            - low +1 ≥ high 만족하지만, low < high(low) 라서 성립 안됨