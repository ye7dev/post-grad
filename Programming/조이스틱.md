# 조이스틱

Status: in progress, 🏋️‍♀️
Theme: Programmers, greedy
Created time: April 1, 2024 3:36 PM
Last edited time: April 1, 2024 5:28 PM

- 상하, 좌우 조작을 따로 생각해줘야
- 상하는 char by char 하나씩 누적으로 생각
- 좌우는 각 시작점에 따라 whole sequence에 대해 한번에 계산
    - 이 때 옵션은 기존 최소 좌우 이동 값
    - 좌→우 가다가 A 연속 지점 시작점 만나면 다시 우 → 좌 → 더 왼쪽으로 가서 end 지점에서 다시 하나씩 왼쪽으로 → 마지막은 A 연속 지점이 끝나서 A가 처음으로 아닌 next
    - 처음부터 왼쪽으로 한칸 이동해서 end 지점 도착 → end 지점에서 next까지 조지고 → 다시 next에서 end로 좌→우 이동 → 이어서 다시 오른쪽으로 가서 A 연속 지점이 시작하기 직전에서 멈춤
- AC 코드
    - 호리즌탈, 버티컬 함수 이름 때문에 좀 헷갈림 ;;
    
    ```python
    def solution(name):
        horizontal_moves = len(name) - 1 # start -> end 
        vertical_moves = 0 # char by char
        
        for i, char in enumerate(name):
            from_a = ord(char) - ord('A')
            from_z = 1 + ord('Z') - ord(char)
            vertical_moves += min(from_a, from_z)
            
            # check consecutive As
            next = i + 1
            while next < len(name) and name[next] == 'A':
                next += 1 
            # next : first non-A char index following the current index
            
            in_order_first = 2 * i + len(name) - next
            reverse_order_first = 2 * (len(name)-next) + i
            horizontal_moves = min(horizontal_moves, in_order_first, reverse_order_first)
            
        return horizontal_moves + vertical_moves
    ```
    
    - end는 len(name)-1이고 여기서 next까지 가는 비용은 len(name)-1-next가 맞다. 근데 start → end가는 1이 더해지거나 해서 결국엔 위처럼 식이 나오는 것