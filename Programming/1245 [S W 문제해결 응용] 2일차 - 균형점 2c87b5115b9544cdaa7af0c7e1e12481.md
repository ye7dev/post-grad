# 1245. [S/W 문제해결 응용] 2일차 - 균형점

Created time: April 23, 2024 3:09 PM
Last edited time: April 23, 2024 4:38 PM

- F_a = G `* m_A * m2 / (d_a * d_a)`
- F_b = G `* m_B * m2 / (d_b * d_b)`
    
    → F_a - F_b = G * m2(m_a/ d_a^2 - m_b/d_b^2) = 0
    
     G * m2(m_a/ d_a^2 - m_b/d_b^2) = 0
    
    (m_a/ d_a^2 - m_b/d_b^2) = 0
    
    m_a*d_b^2 =m_b * d_a^2
    
    m_a*(x-x_b) ** 2 = m_b * (x-x_a)**2 
    
- 도움이 된 댓글
    
    수포자 분들을 위한 소소한 문제 해설 적어두겠습니다. 당연히 풀이 스포는 없으니 안심하고 읽으셔도 돼요!
    
    F = G*m1*m2/(d*d)
    
    위와 같은 식이 나오면 지레 겁을 먹게 되는데, G와 m1 은 생략이 가능하다는 것만 인지하시면 될 것 같아요.
    
    두 자성체 사이의 식에 대입할 물체의 질량(m1)과 G는 같은 수이기 때문입니다.
    
    하여, 두 개의 자성체 A, B 사이에 둘 물체 X에 대한 식은
    
    F = m2(Am 또는 Bm) / d(물체 X와 A 또는 B의 거리) *d 가 됩니다.
    
    그렇다면, 주어진 식에서 미지수가 F와 d 두 개로 어떻게 식을 세워야 하는 지에 대한 의문이 들 수 있는데,
    
    너무 간단하게도 F나 d에 임의의 수를 대입하여 식을 만들고 풀이하면 됩니다.
    
    또한 문제에서 딱히 설명되지 않은 내용으로, 여러개의 자성체에서 생기는 인력(F)은 단순히 더하면 됩니다.
    
    예를 들어, A B X(임의의 물체) C D E 에서 (A, B, C, D, E 는 각기 다른 자성체)
    
    X 에 가해지는 인력은 좌측으로 AF+BF 우측으로 CF+DF+EF 입니다.
    
    마지막으로, 정확한 중간을 찾으려면 끝이 나지 않습니다. 소수점이 계속 늘어나다 마지막엔 어떤 오류든 발생 하게되죠.
    
    하여, 10의 -12승이 허용 가능한 오차범위로 제시되었습니다.
    
    이는 쉽게 말해 양방향의 인력이 소수점 밑으로 12자리까지만 같으면 된다는 의미이며, 그 밑으로는 올리든 버리든 반올림하든 상관이 없습니다.
    
    문제가 원하는 출력은 소수점 밑 10자리 까지이기 때문이니까요.
    
    문제에 겁을 먹고 넘기기엔 너무 재밌고 꼭 풀어보셨으면 하는 문제라 아쉬운 마음에 주저리주저리 적어봤습니다. 갈피를 못 잡으시는 분들께 조금이나마 도움이 되었길 바라며, 다들 화이팅입니다!
    
- 정지
    1. n개의 자성체가 있다면 n-1개의 균형점이 존재한다. → 이 중 어떤 균형점을 return?
        
        → #7 57.8805685415 81.8651598883 91.0573691382 105.0835650491 133.2934094881 이렇게 여러 개를 return 하면 된다 
        
    2. m_a*(x-x_b) ** 2 = m_b * (x-x_a)**2  이 식에서 어떻게 더 전진? 
        
        → G, m2 생략하고 `force = masses[j] / (mid-x_coords[i]) ** 2` 이렇게 계산함 
        
- 완전 탐색이라고 함
- AC 코드
    
    ```python
    def get_balance_point(x_coords, masses):
        ans = []
        for i in range(1, N):
            low, high = x_coords[i-1], x_coords[i]
            mid = None
            while high - low > 1 / (10 ** 12): # 간격이 너무 작으면 mid 위치 변화 미미
                mid = (low + high) / 2
                left = right = 0
                for j in range(N):
                    # mid와 주어진 점 사이의 질량 - mid 질량은 생략한다
                    force = masses[j] / (mid-x_coords[j]) ** 2
                    if x_coords[j] < mid: # 왼쪽으로 당기는 힘
                        left += force
                    else: # 오른쪽으로 미는 힘
                        right += force
                if left < right: # 오른쪽으로 미는 힘이 더 크면
                    high = mid # mid 값을 줄여야
                else:
                    low = mid # mid 값을 늘려야
            if mid is not None:
                ans.append(mid)
        return ans
    
    T = int(input())
    for t in range(1, T+1):
        N = int(input())
        data = list(map(int, input().split()))
        ans = get_balance_point(data[:N], data[N:])
        ans = ' '.join(f'{a:.10f}' for a in ans)
        print(f'#{t} {ans}')
    ```
    
    - Lessons
        - 좌표값의 오차가 10 -12(1e-12) 보다는 작아야 함에 주의하자.
            - 왜 `while high - low > 1 / (10 ** 12)` 로 구현되는가?
                - 우리가 찾으려는 실제 값도 low와 high 값 사이에 있음
                
                → 실제 값이 이 범위에 있다는 보장은 어딨나? 
                
                - “ n개의 자성체가 있다면 n-1개의 균형점이 존재한다. “
                - i번째 mid는 i-1 번째 점과 i 번째 점 사이
                    
                    여기서 찾으려는 균형점은 
                    
                    - 0~i-1번째 점이 모두 왼쪽으로 당기는 힘과
                    - i~N-1번째 점이 모두 오른쪽으로 당기는 힘
                    - 사이에서 균형을 이루는 점
                - 탐색 범위가 10^-12로 좁아지면 이 안에 있는 어떤 두 점도 10^-12 이상의 차를 가질 수 없음
                - 따라서 실제 값과 mid의 차이도 최대 10 -12(1e-12) 이기 때문에 좌표 값의 오차파 10 -12(1e-12)보다 작다는 것이 보장되므로 탐색을 멈춘다.
        - 이진탐색으로 mid의 범위를 좁히되, 각 mid에 대해서는 모든 점과의 인력을 계산하고 (물론 그 이후에 left, right로 갈리지만…)한다는 점에서 완전 탐색인가봄
            - 정확히 말하면 parametric search
        - 이걸 어떻게 생각해내?!