# 1266. [S/W 문제해결 응용] 9일차 - 소수 완제품 확률

Created time: May 8, 2024 5:22 PM
Last edited time: May 9, 2024 3:25 PM

- Lessons
    1. is_prime 함수
        1. 2보다 작은 수가 들어오는 경우는 예외 처리 
        2. int(math.sqrt(x)) + 1이 right range boundary 
        
        ```sql
        def is_prime(x):
            if x < 2:
                return False
            for i in range(2, int(math.sqrt(x)) + 1):
                if x % i == 0:
                    return False
            return True
        ```
        
    2. 조건부 확률 계산
        1. 문제의 요구 사항: 최소 한 명이 만든 완제품 수가 소수일 확률 
            - P_a(b): A(B)가 만든 제품 수가 소수인 경우의 확률 합
            - A(B)가 만든 완제품 수가 소수가 아닌 경우 : 1 - [2, 3, …, 17] = 1-P_a(b)
            - 1 - (1-P_a) * (1-P_b) = 1 - (1 -P_a -P_b + P_a*P_b) = P_a + P_b - P_a * P_b
        2. 처음 나의 접근
            - 1~18을 nested for loop로 돌면서 둘다 소수가 아닌 경우에만 dp_a[i], dp_b[j] 곱한 다음 1에서 빼줬다
            
            → 맞는 접근
            
            1. 각 사람별로 성공 개수가 소수인 경우를 모두 더한다
            2. 각 사람에 대해 1-(1.에서 구한 수치) 계산
            3. 두 사람의 2.수치를 곱한다
            4. 1에서 3.의 결과를 뺀다  
            
            → 여전히 이해가 안간다…! 
            
    3. 예외사항 처리 
        1. a나 b의 확률이 100인 경우, fail_a(b)는 0이 나와서 zerodevision 에러가 발생한다
        2. 이를 막기 위해 예외 케이스로 flag 변수를 두었고, flag 변수가 False이면 
            - dp array 값을 모두 1로 초기화해주었음
            - prime 숫자를 완성할 확률 합계는 0 - 확률이 100이면 늘 18개를 완성하기 때문에…
            - 그래도 어느 한 쪽만 flag True면 공식에 의해 0이 아니게 된다
                - P_a + P_b - P_a * P_b
                    - p_b가 0이더라도 p_a 값은 살아남는다
- 문제 이해
    
    문제가 좀 이상하게 서술되어 있음 
    
    5분 안에 완제품을 만들거나 안 만들거나 → 1, 0
    
    이 때 1을 채울 확률이 주어진다는 것이고, 1에서 그 수를 빼면 0을 채울 확률이 주어지는 것 
    
    최대 만들 수 있는 제품수는 90//5 = 18 
    
    18 안에 있는 소수는 2, 3, 5, 7, 11, 13, 17 → 7개
    
    1 - 모두 소수가 아닐 확률 
    
    소수가 아닌 수는 1, 2의 배수, 3의 배수, 5의 배수
    
    1 → 1개
    
    4 6 8 10 12 14 16 18 → 8개
    
    9 15 → 2개
    
- scratch
    
    0개 성공: (1-a) ** 18
    
    1개 성공 : 18C1 * a * (1-a)**17
    
    2개 성공: 18C2 * a**2 * (1-a) ** 16 
    
    n개 성공: 18Cn * a ** n * (1-a) ** (18-n)
    
    18/1 → 18*17/2*1 → 18*17*16/3*2*1
    
    17/2 → 16/3 
    
    0 → 1, …, 18 → 19?
    
    17개 성공 → 18*17*…*1/17*16*…*1 = 18 
    
    18개 성공: a ** 18
    
    18 → 18*17 → 18*17*…*2 →  18*17*…*1
    
    1 → 2*1 → 17*16….1 → 18*17*16…1
    
- Trial
    - zero devision error
        
        ```sql
        import sys
        sys.stdin = open('temp_input/input.txt', 'r')
        
        import math
        def is_prime(num):
            for i in range(2, int(math.sqrt(num))+1):
                if num % i == 0:
                    return False
            return True
        def prime_finish():
            dp_a, dp_b = [0] * 19, [0] * 19
            a, b = A * 0.01, B * 0.01
            fail_a, fail_b = 1 - a, 1 - b
            # base case
            dp_a[0] = fail_a ** 18
            dp_b[0] = fail_b ** 18
        
            # iterative case
            for i in range(1, 19):
                dp_a[i] = dp_a[i-1] * a / fail_a * (18-i+1) / i
                dp_b[i] = dp_b[i-1] * b / fail_b * (18-i+1) / i
        
            no_prime = 0
            for i in range(1, 19):
                if is_prime(i):
                    continue
                no_prime += dp_a[i] * dp_b[i]
        
            return (1 - no_prime)
        
        T = int(input())
        for t in range(1, T+1):
            A, B = map(int, input().split())
            ans = prime_finish()
            print(f'#{t} {round(ans, 6):.6f}')
        ```
        
- AC code
    
    ```sql
    import sys
    sys.stdin = open('temp_input/input.txt', 'r')
    
    import math
    def is_prime(x):
        if x < 2:
            return False
        for i in range(2, int(math.sqrt(x)) + 1):
            if x % i == 0:
                return False
        return True
    
    def prime_finish():
        a, b = A * 0.01, B * 0.01
        a_flag = True if a != 1 else False
        b_flag = True if b != 1 else False
        a_prime, b_prime = 0, 0
        fail_a, fail_b = 1 - a, 1 - b
        a_cand, b_cand = 0, 0
    
        if not a_flag:
            dp_a = [1] * 19
        else:
            dp_a = [0] * 19
            dp_a[0] = fail_a ** 18
            for i in range(1, 19):
                dp_a[i] = dp_a[i - 1] * (a / fail_a) * ((18 - i + 1) / i)
                if is_prime(i):
                    a_prime += dp_a[i]
                else:
                    a_cand += dp_a[i]
    
        if not b_flag:
            dp_b = [1] * 19
        else:
            dp_b = [0] * 19
            dp_b[0] = fail_b ** 18
            for i in range(1, 19):
                dp_b[i] = dp_b[i - 1] * (b / fail_b) * ((18 - i + 1) / i)
                if is_prime(i):
                    b_prime += dp_b[i]
    
        either_prime = a_prime + b_prime - (a_prime * b_prime)
    
        return either_prime
    
    T = int(input())
    for t in range(1, T+1):
        A, B = map(int, input().split())
        ans = prime_finish()
        print(f'#{t} {round(ans, 6):.6f}')
    ```