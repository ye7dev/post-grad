# 502. IPO

Status: done, in progress
Theme: heap
Created time: November 1, 2023 6:24 PM
Last edited time: November 1, 2023 10:30 PM

- 문제 이해
    
    best way to maximize its total capital after finishing at most `k` distinct projects.
    
    You are given `n` projects where the `ith` project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.
    
    초기 자본 w가 주어진다고 함 
    
- 나의 30분
    
    이거 왠지 희토류 문제랑 비슷한 듯. 다만 날짜가 연속되지 않음. 
    
    보유 자본이 적으면 어떤 프로젝트는 시작할 수도 없음 
    
    희토류랑 다르게 프로젝트를 시작한다고 해서 비용을 지불해야 하는 건 아닌 듯. 그냥 minimum을 가지고 있으면 됨 
    
    내 비용으로 가능한 것 중 제일 profit이 큰 게 제일 먼저 나오니까 그냥 그거 우선 만나면…되는 게 아니라 내 비용으로 가능한 데 가장 작은 비용부터 나오니까 그게 문제. 내가 더 낼 수 있고 더 큰 이익을 얻을 수 있으면 그걸 하는 게 맞는데…
    
- 내힘으로 코드
    
    ```python
    import heapq
    class Solution:
        def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
            heap = []
            temp = []
            for i in range(len(profits)):
                # min capital, max profit prefered 
                # with same capital, second value which is negative profit 
                if capital[i] > w:
                    heapq.heappush(temp, (capital[i], -profits[i]))
                else:
                    heapq.heappush(heap, (-profits[i], capital[i]))
            if not heap:
                return w
    
            mine = w
            for _ in range(k):
                cur_pro, cur_cap = heapq.heappop(heap)   
                mine -= cur_pro # pro being negative
                while temp:
                    cur_cap, cur_pro = heapq.heappop(temp)
                    if cur_cap > mine:
                        heapq.heappush(temp, (cur_cap, cur_pro))
                        break 
                    else:
                        heapq.heappush(heap, (cur_pro, cur_cap))
                if not heap:
                    print(heap, temp)
                    return mine
                    
            return mine
    ```
    
- 남의 본받을 만한 코드
    - 기본적인 idea는 맞았다
    - capital이 작은 순으로 pair sort (=projects)
        
        → projects의 앞 원소부터 비용이 현재 W보다 작거나 같으면 heap에 넣어준다
        
        - 이 때 project 자체에서는 원소가 pop되거나 하지 않는다
        - heap에 넣어주는 값은 negative profit
        
        → projects를 다 돌고 나서 heap에 원소가 있으면 pop 한번만 해서 negative를 positive로 바꿔서 W에 반영 
        
        - heap에 원소가 없으면 이어서 for loop k번만큼 반복 수행
    
    ```python
    def findMaximizedCapital(self, k, W, Profits, Capital):
            heap = []
            projects = sorted(zip(Profits, Capital), key=lambda l: l[1])
            i = 0
            for _ in range(k):
                while i < len(projects) and projects[i][1] <= W:
                    heapq.heappush(heap, -projects[i][0])
                    i += 1
                if heap: W -= heapq.heappop(heap)
            return W
    ```