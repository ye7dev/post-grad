# 3124. 최소 스패닝 트리

Created time: May 14, 2024 3:09 PM
Last edited time: May 14, 2024 5:08 PM

- MST 알고리즘 revisit
    - **Kruskal's Algorithm (크루스칼 알고리즘)**
        1. **개요**: 그래프의 모든 간선을 가중치에 따라 오름차순으로 정렬한 후, 사이클을 생성하지 않는 간선들을 하나씩 선택하여 최소 신장 트리를 구성합니다.
        2. **단계**:
            - **간선 정렬**: 그래프의 모든 간선을 가중치에 따라 오름차순으로 정렬합니다.
            - **간선 선택**: 정렬된 간선 리스트에서 순서대로 간선을 선택합니다.
            - **사이클 검사**: 선택된 간선이 사이클을 생성하는지 확인합니다. 사이클을 생성하지 않으면 해당 간선을 최소 신장 트리에 추가합니다.
            - **Union-Find 사용**: 사이클 검사를 위해 Union-Find 자료 구조를 사용합니다.
        3. **특징**:
            - 간선을 기준으로 선택
            - 사이클 검사 필요
            - 간선의 수가 적을 때 유리
    - **Prim's Algorithm (프림 알고리즘)**
        1. **개요**: 하나의 시작 정점에서 출발하여, 인접한 간선 중 최소 가중치를 가지는 간선을 선택하여 최소 신장 트리를 구성합니다.
        2. **단계**:
            - **시작 정점 선택**: 임의의 정점을 시작 정점으로 선택합니다.
            - **인접 간선 선택**: 현재 트리와 인접한 간선 중에서 최소 가중치를 가지는 간선을 선택합니다.
            - **정점 추가**: 선택된 간선의 끝점을 최소 신장 트리에 추가합니다.
            - **반복**: 모든 정점이 포함될 때까지 위 과정을 반복합니다.
        3. **특징**:
            - 정점을 기준으로 선택
            - 우선순위 큐 사용 (보통 힙을 사용)
            - Dense 그래프 (간선이 많은 그래프)에 유리
        
        이 두 알고리즘은 모두 최소 신장 트리를 찾는 데 사용되지만, 접근 방식과 사용 사례가 다릅니다. Kruskal은 간선 중심, Prim은 정점 중심으로 동작합니다.
        
- 프림 알고리즘 헷갈리는 부분들
    - 노드 번호가 1~V라는 점이 주어져 있지 않을 때 자료구조를 뭘써서 방문 처리해야 하려나? → 딕셔너리 쓴다
    - MST 가중치 합은…어떻게 구하나
        - start node의 모든 이웃을 pq에 넣고 시작하는게 맞나? → 맞다
        - 다음 방문할 이웃 노드의 또 이웃을 모두 넣고 거기서 다시 가중치 가장 작은 목적지가 다음 노드로 튀어나오는 듯…
    - 방문 처리는 pop 할 때 하는 듯? → 싫다 난 pq에 넣으면서 할테다 → 이렇게 했더니 틀렸다
        - 왜냐면 다른 노드 탐방하면서 더 가중치가 작은 간선이 나올 수도 있는데
        - 처음 보자마자 pq에 추가해버리면, 그 이후로는 다시 추가될 기회가 없어져 버리기 때문
        - 그리고 이미 방문된 노드가 나올 수도 있기 때문에 그럴 경우에는 그냥 pop 한다
    - pq 초기화 잘못한 듯
    - 참고로 `heapq.heapify(pq)  # heapify returns nothing`
- Trial
    - 예제는 통과했는데 왜 본 문제는 다 틀리누
        
        ```python
        import sys
        sys.stdin = open('temp_input/sample_input.txt', 'r')
        
        import heapq
        
        def prim_algo():
            start = s
            pq = [(0, start)]
            weight_sum = 0
            while pq:
                cur_weight, cur_node = heapq.heappop(pq)
                if visited[cur_node]:
                    continue
                visited[cur_node] = 1
                weight_sum += cur_weight
                for connected in graph[cur_node]:
                    weight, next_node = connected
                    if not visited[next_node]:
                        heapq.heappush(pq, connected)
        
            return weight_sum
        
        T = int(input())
        for t in range(1, T+1):
            V, E = map(int, input().split())
            graph = {}
            visited = {}
            for _ in range(E):
                s, e, w = map(int, input().split())
                if s not in graph:
                    graph[s] = []
                graph[s].append((w, e))
                if e not in graph:
                    graph[e] = []
                if s not in visited:
                    visited[s] = 0
                if e not in visited:
                    visited[e] = 0
            ans = prim_algo()
            print(f'#{t} {ans}')
        ```
        
- AC 코드
    - 아오 이게 이렇게 오래 걸릴 문제냐고;; MST는 undirected 그래프라서 엣지를 양방향으로 추가해주는 게 핵심이었다;;
    
    ```python
    import sys
    sys.stdin = open('temp_input/sample_input.txt', 'r')
    
    import heapq
    
    def prim_algo(start):
        cnt = 0
        pq = [(0, start)]
        weight_sum = 0
        while pq:
            cur_weight, cur_node = heapq.heappop(pq)
            if visited[cur_node] == 0:
                visited[cur_node] = 1
                weight_sum += cur_weight
                for weight, next_node in graph[cur_node]:
                    if visited[next_node] == 0:
                        heapq.heappush(pq, (weight, next_node))
    
        return weight_sum
    
    T = int(input())
    for t in range(1, T+1):
        V, E = map(int, input().split())
        graph = {}
        visited = {}
        for _ in range(E):
            s, e, w = map(int, input().split())
            if s not in graph:
                graph[s] = []
            graph[s].append((w, e))
            if e not in graph:
                graph[e] = []
            graph[e].append((w, s))
    
            if s not in visited:
                visited[s] = 0
            if e not in visited:
                visited[e] = 0
        ans = prim_algo(1)
        print(f'#{t} {ans}')
    ```