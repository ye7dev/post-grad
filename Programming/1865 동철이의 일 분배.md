# 1865. 동철이의 일 분배

Created time: April 30, 2024 4:23 PM
Last edited time: May 1, 2024 10:31 AM

- Lesson
    - backtracking
        - 함수 진입하자마자 하는 것 두 개
            1. 새 stack frame 만들어졌기 때문에 global 변수 선언 
            2. 해당 인덱스에 대한 방문 처리
            3. 주어진 파라미터에 대한 작업 수행 → 값 update   
        - base case: idx = N-1
            - 이번에 update한 값이 전역 변수보다 크면 update
        - recursive case
            - valid case로만 탐색 이어나갈 수 있도록 프루닝 조건 확인
                1. 아직 방문 전 인덱스인지 
                2. 그 인덱스에 해당하는 값을 현재 값에 곱했을 때 지금까지 구해놓은 전역 변수 값보다 큰지 
            - 부합하면 재귀호출
        - 다시 방문 처리 원상 복구
- 첫인상
    - 나이브하게 봤을 때는 row별 최댓값 구해서 누적으로 곱한 다음 소수 7번째 자리에서 반올림하면 되는듯?
        - 시간 초과나려나?
        - 아니다 dp다
        - recursive로 풀어보자
- Trial
    - Timeout
        
        ```python
        from itertools import permutations
        def get_success_rate(nums, rates):
            success_rate = 1
            for i, n in enumerate(nums):
                success_rate *= rates[i][n] * 0.01
            return success_rate * 100
        
        T = int(input())
        for t in range(1, T+1):
            N = int(input())
            data = []
            for _ in range(N):
                row = list(map(int, input().split()))
                data.append(row)
            indices = [i for i in range(N)]
            ans = -1
            for comb in permutations(indices, N):
                cur = get_success_rate(comb, data)
                ans = max(ans, cur)
            print(f'#{t} {ans:.6f}')
        
        ```
        
- Scratch
    - 모든 조합을 다해봐야 할 것 같은데 어떻게…?
    - 16차원 매트릭스 설마?
- 쉽지 않고만
- 테리 힌트
    
    ### **풀이방법**
    
    DFS(깊이 우선 탐색)알고리즘과 Backtracking(되추적)으로 해결한다.
    
    모든 직원이 일이 중복 되지 않도록 일을 선택할 수 있는 모든 경우 중 최대값을 찾는다.
    
    1번 직원이 선택할 수 있는 일은 n가지이다.
    
    1번 직원이 일을 선택한 후, 2번 직원이 선택할 수 있는 일은 n-1가지이다.
    
    2번 직원이 일을 선택한 후, 3번 직원이 선택할 수 있는 일은 n-2가지이다.
    
    ...
    
    n-1번 직원이 일을 선택한 후, n번 직원이 선택할 수 있는 일은 1가지이다.
    
    즉, 1부터 n까지 n개의 수가 주어졌을 때, 중복이 허용되지 않는 모든 순열을 구하는 문제이다.
    
    순열의 모든 경우의 수는 n개의 숫자가 주여졌을 때, n!이 된다.
    
    문제에서 n은 16까지 입력되므로 16!일 경우 시간초과가 발생하게 된다.
    
    따라서 백트레킹으로 유망하지 않는 경우는 프루닝해서 탐색하는 노드의 수를 줄인다.
    
    프루닝의 조건은 현재 탐색하는 경로에서 i번째 직원(1 <= i <= n)까지의 성공확률이 이전에 구했던 최대 성공확률보다 작을 때이다.
    
    확률은 0 ~ 1사이인데, 0 ~ 1 사이의 숫자를 계속 곱하면 계속해서 작아지기만 할 뿐이다.
    
    따라서 이미 이전의 최대 성공확률보다 작다면 최대 성공확률이 될 수 없으므로 백트레킹한다.
    
- 남의 답안
    
    ```python
    def dfs(x, depth, result):
        global max_value  # 파이썬에서는 전역 변수를 수정할 때 global 키워드를 사용합니다.
        result *= a[x][depth]
        visit[x] = 1
        
        # base case 
        if depth == n - 1:
            if max_value < result:
                max_value = result
            visit[x] = 0
            return
        
        for i in range(n):
            if visit[i] == 0 and result * a[i][depth + 1] > max_value:
                dfs(i, depth + 1, result)
        visit[x] = 0
    ```
    
- AC 코드
    
    ```python
    def recur(row_idx, col_idx, prev_val):
        global ans
        # mark as visited
        visited[col_idx] = 1
        # process current state
        cur_val = prev_val * data[row_idx][col_idx] * 0.01
        # base case
        if row_idx == N-1:
            if ans < cur_val:
                ans = cur_val
            # unmark the visit
            visited[col_idx] = 0
            return
    
        # recursive case
        for next_idx in range(N):
            if visited[next_idx] == 0 and cur_val * data[row_idx+1][next_idx] * 0.01 > ans:
                recur(row_idx+1, next_idx, cur_val)
    
        # unmark the visit
        visited[col_idx] = 0
    
    T = int(input())
    for t in range(1, T+1):
        N = int(input())
        data = []
        for _ in range(N):
            row = list(map(int, input().split()))
            data.append(row)
        ans = 0
        visited = [0] * N
        for i in range(N):
            recur(0, i, 1)
        ans *= 100
        print(f'#{t} {ans:.6f}')
    ```
    
    - [x]  Lesson 정리하기