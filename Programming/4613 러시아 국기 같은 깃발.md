# 4613. 러시아 국기 같은 깃발

Status: 🏋️‍♀️
Created time: April 30, 2024 11:20 AM
Last edited time: April 30, 2024 3:58 PM

- 첫인상
    
    DP 문제인것도 같은데 모르겠다 
    
    근데 인풋이 작아서 BF도 가능할지도? 
    
- 맨 윗줄은 무조건 흰색, 맨 아랫줄은 무조건 빨간색
- 나머지 줄 어떻게 처리해야 하는지 몰루
- 남의 힌트
    
    동적계획법(DP, Dynamic Programming) 알고리즘을 활용해 문제를 해결한다.
    
    흰색, 파란색, 빨간색 중에서 유동적으로 변하지 않는 값(색을 새로 칠해야하는 칸의 수)을 찾는다.
    
    흰색의 같은 경우 0번째 행에서 시작하므로 행을 1개, 2개, 3개 차지할 때 값이 변하지 않는다.
    
    빨간색의 경우도 마찬가지로 n-1번짹 행에서부터 칠해지므로 행을 1개, 2개, 3개 차지할 때 값이 유동적으로 변하지 않는다.
    
    다만, 파란색의 경우 흰색의 행의 수에 따라 값이 유동적으로 변하게 된다.
    
    파란색을 제외하고는 빨간색과 흰색은 여러 줄의 차지할 때 그 값이 고정이 된다.
    
    따라서, 빨간색과 흰색이 각 각n, m줄일 때, 새로 칠해야하는 칸의 수를 미리 저장한다.
    
    총 새로 칠해야하는 칸의 수는 흰색을  위에서부터 몇 줄 칠하고, 빨간색을 아래서부터 몇 줄 칠했을 때,
    
    나머지 가운데 부분을 빨간색으로 칠했을 때 새로 칠하는 칸의 수를 구하면 된다.
    
    이 때, 흰색의 몇줄, 빨간색의 몇줄은 미리 저장해서 알기 때문에, 파란색을 칠해야하는 수만 매 사이클마다 찾아주면 된다.
    
    흰색과 빨간색이 1, 2, 3, ..., n-2행을 차지할 때의 값을 ws[m], rs[m]이라고 하고 파란색의 각 행을 새로 칠하는 수를 b[n]이라고 할 때,
    
    총 새로 칠해야하는 칸의 개수는 ws[i] + rs[j] + r[i+1] + r[i+2] + ... + r[n-j]가 된다.
    
    즉, 흰색을 i줄 칠하고, 빨간색을 j줄 칠했을 때, i+1부터 n-j줄까지는 파란색으로 칠하는 것이 된다.
    
- scratch
    - 파란색 줄 수는 흰, 빨 합에 의해 결정됨. num_rows - (흰 + 빨)
    - state 변수는 2개
    - base case
        - 파란색 줄수는 0이고
        - 흰: num_rows-1, 빨: 1
        - 흰: 1, 빨: num_rows-1
    - 흰: 1
        - 빨: num_rows-2~1
    - 흰 2
        - 빨: num_rows-3~1
    - 흰 3
        - 빨:  num_rows-4~1
    - 흰 num_rows-2
        - 빨:1
    - 흰색이 n이면 n-1번째 row
        - 파란색은 n번째 row
    - 흰색이 i, 파란색이 b → 1, 2 → 0번째 row는 흰색, 1, 2는 파란색 → 빨간색은 3번째 row부터
- Trial
    
    ```python
    from collections import Counter
    def get_num_to_color(matrix):
        num_rows, num_cols = len(matrix), len(matrix[0])
    
        dp = [[float('inf')] * (num_rows+1) for _ in range(num_rows+1)]
    
        # state: dp[i][j]: num switch when num white rows = i, num red rows = j
        # base case: no blue
    
        switch_to_white = 0
        switch_to_red = 0
        for i in range(num_rows):
            cur_switch = num_cols - Counter(matrix[i])['R']
            switch_to_red += cur_switch
        # switch_to_red: number of cells to color for red only matrix
    
        for i in range(1, num_rows):  # 1~num_rows-1 -> idx: 0~num_rows-2
            to_white = num_cols - Counter(matrix[i-1])['W']
            to_red = num_cols - Counter(matrix[i-1])['R']
            switch_to_white += to_white
            switch_to_red -= to_red
            # 1, num_rows-1 ~num_rows-1, 1
            dp[i][num_rows-i] = switch_to_red + switch_to_white
    
        # iterative case
        # min: 2, max: num_rows-2
        min_val = float('inf')
        for num_white in range(1, num_rows-1):  # 1~num_rows-2
            for num_red in range(1, num_rows-num_white):  # 1~num_rows-2
                num_blue = num_rows - num_white - num_red
                # 0~num_white-1 / num_white~num_rows-1-num_red / num_rows-num_red~num_rows-1
                min_temp = float('inf')
                for blue in range(num_blue+1):  # 0~num_blue -> num_blue~0
                    if num_white-blue >= 1 and num_red-(num_blue-blue) >= 1:
                        print(num_white-blue, num_red-(num_blue-blue))
                        temp = dp[num_white-blue][num_red-(num_blue-blue)]
                        min_temp = min(min_temp, temp)
    
                switch_to_blue = 0
                for idx in range(num_white, num_rows-num_red):
                    switch_to_blue += num_cols - Counter(matrix[idx])['B']
                print(switch_to_blue)
    
                dp[num_white][num_red] = min_temp + switch_to_blue
    
                if min_val > dp[num_white][num_red]:
                    min_val = dp[num_white][num_red]
        print(dp)
        return min_val
    
    T = int(input())
    for t in range(1, T+1):
        N, M = map(int, input().split())
        data = []
        for _ in range(N):
            data.append(input())
        ans = get_num_to_color(data)
        print(f'#{t} {ans}')
    ```
    
- base case를 잘못 잡은듯
    - 기존: red + white = nrows가 되는 곳에서만 구함
    - 맞는 것: red, white 리스트를 따로 두고, 각각 몇 개의 row를 차지할 때의 수정해야 하는 cell의 개수를 구한다
        - 하나의 테이블에 만드는게 아니었음
- AC 코드(🪇)
    
    ```python
    from collections import Counter
    def get_num_to_color(matrix):
        num_rows, num_cols = len(matrix), len(matrix[0])
    
        dp = [[float('inf')] * (num_rows+1) for _ in range(num_rows+1)]
    
        # state: dp[i][j]: num switch when num white rows = i, num red rows = j
        # base case: no blue
        switch_to_white = [0]
        switch_to_red = [0]
    
        cur = 0
        for i in range(num_rows):
            cur += num_cols-Counter(matrix[i])['W']
            switch_to_white.append(cur)
    
        cur = 0
        for i in range(num_rows-1, -1, -1):
            cur += num_cols - Counter(matrix[i])['R']
            switch_to_red.append(cur)
    
        # iterative case
        # min: 2, max: num_rows-2
        min_val = float('inf')
        for num_white in range(1, num_rows-1):  # 1~num_rows-2
            for num_red in range(1, num_rows-num_white):  # 1~num_rows-2
                # 0~num_white-1 / num_white~num_rows-1-num_red / num_rows-num_red~num_rows-1
                switch_to_blue = 0
                for idx in range(num_white, num_rows-num_red):
                    switch_to_blue += num_cols - Counter(matrix[idx])['B']
    
                dp[num_white][num_red] = switch_to_white[num_white] + switch_to_red[num_red] + switch_to_blue
    
                if min_val > dp[num_white][num_red]:
                    min_val = dp[num_white][num_red]
    
        return min_val
    
    T = int(input())
    for t in range(1, T+1):
        N, M = map(int, input().split())
        data = []
        for _ in range(N):
            data.append(input())
        ans = get_num_to_color(data)
        print(f'#{t} {ans}')
    ```
    
- 엄청 허무하고 더 쉬운 방법
    - 수정해야 하는 cell의 개수 = 전체 column 개수 - 맞는 cell의 개수
    - 수정해야 하는 cell의 개수가 최소가 된다 = 맞는 cell의 개수가 최대가 된다
    
    ```python
    T = int(input())
    for tc in range(1, T+1):
        N, M = map(int, input().split())
        arr = [input() for _ in range(N)]
     
        mx = 0
        for i in range(N-2):
            for j in range(i+1, N-1):
                cnt = 0
                for s in range(i+1):
                    cnt += arr[s].count('W')    # 하얀색 깃발 개수 count
                for s in range(i+1, j+1):
                    cnt += arr[s].count('B')
                for s in range(j+1, N):
                    cnt += arr[s].count('R')
                mx = max(mx, cnt)
        print(f'#{tc} {N*M-mx}')
    ```