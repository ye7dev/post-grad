# 4613. ëŸ¬ì‹œì•„ êµ­ê¸° ê°™ì€ ê¹ƒë°œ

Status: ğŸ‹ï¸â€â™€ï¸
Created time: April 30, 2024 11:20 AM
Last edited time: April 30, 2024 3:58 PM

- ì²«ì¸ìƒ
    
    DP ë¬¸ì œì¸ê²ƒë„ ê°™ì€ë° ëª¨ë¥´ê² ë‹¤ 
    
    ê·¼ë° ì¸í’‹ì´ ì‘ì•„ì„œ BFë„ ê°€ëŠ¥í• ì§€ë„? 
    
- ë§¨ ìœ—ì¤„ì€ ë¬´ì¡°ê±´ í°ìƒ‰, ë§¨ ì•„ë«ì¤„ì€ ë¬´ì¡°ê±´ ë¹¨ê°„ìƒ‰
- ë‚˜ë¨¸ì§€ ì¤„ ì–´ë–»ê²Œ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ”ì§€ ëª°ë£¨
- ë‚¨ì˜ íŒíŠ¸
    
    ë™ì ê³„íšë²•(DP, Dynamic Programming) ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•´ ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤.
    
    í°ìƒ‰, íŒŒë€ìƒ‰, ë¹¨ê°„ìƒ‰ ì¤‘ì—ì„œ ìœ ë™ì ìœ¼ë¡œ ë³€í•˜ì§€ ì•ŠëŠ” ê°’(ìƒ‰ì„ ìƒˆë¡œ ì¹ í•´ì•¼í•˜ëŠ” ì¹¸ì˜ ìˆ˜)ì„ ì°¾ëŠ”ë‹¤.
    
    í°ìƒ‰ì˜ ê°™ì€ ê²½ìš° 0ë²ˆì§¸ í–‰ì—ì„œ ì‹œì‘í•˜ë¯€ë¡œ í–‰ì„ 1ê°œ, 2ê°œ, 3ê°œ ì°¨ì§€í•  ë•Œ ê°’ì´ ë³€í•˜ì§€ ì•ŠëŠ”ë‹¤.
    
    ë¹¨ê°„ìƒ‰ì˜ ê²½ìš°ë„ ë§ˆì°¬ê°€ì§€ë¡œ n-1ë²ˆì§¹ í–‰ì—ì„œë¶€í„° ì¹ í•´ì§€ë¯€ë¡œ í–‰ì„ 1ê°œ, 2ê°œ, 3ê°œ ì°¨ì§€í•  ë•Œ ê°’ì´ ìœ ë™ì ìœ¼ë¡œ ë³€í•˜ì§€ ì•ŠëŠ”ë‹¤.
    
    ë‹¤ë§Œ, íŒŒë€ìƒ‰ì˜ ê²½ìš° í°ìƒ‰ì˜ í–‰ì˜ ìˆ˜ì— ë”°ë¼ ê°’ì´ ìœ ë™ì ìœ¼ë¡œ ë³€í•˜ê²Œ ëœë‹¤.
    
    íŒŒë€ìƒ‰ì„ ì œì™¸í•˜ê³ ëŠ” ë¹¨ê°„ìƒ‰ê³¼ í°ìƒ‰ì€ ì—¬ëŸ¬ ì¤„ì˜ ì°¨ì§€í•  ë•Œ ê·¸ ê°’ì´ ê³ ì •ì´ ëœë‹¤.
    
    ë”°ë¼ì„œ, ë¹¨ê°„ìƒ‰ê³¼ í°ìƒ‰ì´ ê° ê°n, mì¤„ì¼ ë•Œ, ìƒˆë¡œ ì¹ í•´ì•¼í•˜ëŠ” ì¹¸ì˜ ìˆ˜ë¥¼ ë¯¸ë¦¬ ì €ì¥í•œë‹¤.
    
    ì´ ìƒˆë¡œ ì¹ í•´ì•¼í•˜ëŠ” ì¹¸ì˜ ìˆ˜ëŠ” í°ìƒ‰ì„  ìœ„ì—ì„œë¶€í„° ëª‡ ì¤„ ì¹ í•˜ê³ , ë¹¨ê°„ìƒ‰ì„ ì•„ë˜ì„œë¶€í„° ëª‡ ì¤„ ì¹ í–ˆì„ ë•Œ,
    
    ë‚˜ë¨¸ì§€ ê°€ìš´ë° ë¶€ë¶„ì„ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ì¹ í–ˆì„ ë•Œ ìƒˆë¡œ ì¹ í•˜ëŠ” ì¹¸ì˜ ìˆ˜ë¥¼ êµ¬í•˜ë©´ ëœë‹¤.
    
    ì´ ë•Œ, í°ìƒ‰ì˜ ëª‡ì¤„, ë¹¨ê°„ìƒ‰ì˜ ëª‡ì¤„ì€ ë¯¸ë¦¬ ì €ì¥í•´ì„œ ì•Œê¸° ë•Œë¬¸ì—, íŒŒë€ìƒ‰ì„ ì¹ í•´ì•¼í•˜ëŠ” ìˆ˜ë§Œ ë§¤ ì‚¬ì´í´ë§ˆë‹¤ ì°¾ì•„ì£¼ë©´ ëœë‹¤.
    
    í°ìƒ‰ê³¼ ë¹¨ê°„ìƒ‰ì´ 1, 2, 3, ..., n-2í–‰ì„ ì°¨ì§€í•  ë•Œì˜ ê°’ì„ ws[m], rs[m]ì´ë¼ê³  í•˜ê³  íŒŒë€ìƒ‰ì˜ ê° í–‰ì„ ìƒˆë¡œ ì¹ í•˜ëŠ” ìˆ˜ë¥¼ b[n]ì´ë¼ê³  í•  ë•Œ,
    
    ì´ ìƒˆë¡œ ì¹ í•´ì•¼í•˜ëŠ” ì¹¸ì˜ ê°œìˆ˜ëŠ” ws[i] + rs[j] + r[i+1] + r[i+2] + ... + r[n-j]ê°€ ëœë‹¤.
    
    ì¦‰, í°ìƒ‰ì„ iì¤„ ì¹ í•˜ê³ , ë¹¨ê°„ìƒ‰ì„ jì¤„ ì¹ í–ˆì„ ë•Œ, i+1ë¶€í„° n-jì¤„ê¹Œì§€ëŠ” íŒŒë€ìƒ‰ìœ¼ë¡œ ì¹ í•˜ëŠ” ê²ƒì´ ëœë‹¤.
    
- scratch
    - íŒŒë€ìƒ‰ ì¤„ ìˆ˜ëŠ” í°, ë¹¨ í•©ì— ì˜í•´ ê²°ì •ë¨. num_rows - (í° + ë¹¨)
    - state ë³€ìˆ˜ëŠ” 2ê°œ
    - base case
        - íŒŒë€ìƒ‰ ì¤„ìˆ˜ëŠ” 0ì´ê³ 
        - í°: num_rows-1, ë¹¨: 1
        - í°: 1, ë¹¨: num_rows-1
    - í°: 1
        - ë¹¨: num_rows-2~1
    - í° 2
        - ë¹¨: num_rows-3~1
    - í° 3
        - ë¹¨:  num_rows-4~1
    - í° num_rows-2
        - ë¹¨:1
    - í°ìƒ‰ì´ nì´ë©´ n-1ë²ˆì§¸ row
        - íŒŒë€ìƒ‰ì€ në²ˆì§¸ row
    - í°ìƒ‰ì´ i, íŒŒë€ìƒ‰ì´ b â†’ 1, 2 â†’ 0ë²ˆì§¸ rowëŠ” í°ìƒ‰, 1, 2ëŠ” íŒŒë€ìƒ‰ â†’ ë¹¨ê°„ìƒ‰ì€ 3ë²ˆì§¸ rowë¶€í„°
- Trial
    
    ```python
    from collections import Counter
    def get_num_to_color(matrix):
        num_rows, num_cols = len(matrix), len(matrix[0])
    
        dp = [[float('inf')] * (num_rows+1) for _ in range(num_rows+1)]
    
        # state: dp[i][j]: num switch when num white rows = i, num red rows = j
        # base case: no blue
    
        switch_to_white = 0
        switch_to_red = 0
        for i in range(num_rows):
            cur_switch = num_cols - Counter(matrix[i])['R']
            switch_to_red += cur_switch
        # switch_to_red: number of cells to color for red only matrix
    
        for i in range(1, num_rows):  # 1~num_rows-1 -> idx: 0~num_rows-2
            to_white = num_cols - Counter(matrix[i-1])['W']
            to_red = num_cols - Counter(matrix[i-1])['R']
            switch_to_white += to_white
            switch_to_red -= to_red
            # 1, num_rows-1 ~num_rows-1, 1
            dp[i][num_rows-i] = switch_to_red + switch_to_white
    
        # iterative case
        # min: 2, max: num_rows-2
        min_val = float('inf')
        for num_white in range(1, num_rows-1):  # 1~num_rows-2
            for num_red in range(1, num_rows-num_white):  # 1~num_rows-2
                num_blue = num_rows - num_white - num_red
                # 0~num_white-1 / num_white~num_rows-1-num_red / num_rows-num_red~num_rows-1
                min_temp = float('inf')
                for blue in range(num_blue+1):  # 0~num_blue -> num_blue~0
                    if num_white-blue >= 1 and num_red-(num_blue-blue) >= 1:
                        print(num_white-blue, num_red-(num_blue-blue))
                        temp = dp[num_white-blue][num_red-(num_blue-blue)]
                        min_temp = min(min_temp, temp)
    
                switch_to_blue = 0
                for idx in range(num_white, num_rows-num_red):
                    switch_to_blue += num_cols - Counter(matrix[idx])['B']
                print(switch_to_blue)
    
                dp[num_white][num_red] = min_temp + switch_to_blue
    
                if min_val > dp[num_white][num_red]:
                    min_val = dp[num_white][num_red]
        print(dp)
        return min_val
    
    T = int(input())
    for t in range(1, T+1):
        N, M = map(int, input().split())
        data = []
        for _ in range(N):
            data.append(input())
        ans = get_num_to_color(data)
        print(f'#{t} {ans}')
    ```
    
- base caseë¥¼ ì˜ëª» ì¡ì€ë“¯
    - ê¸°ì¡´: red + white = nrowsê°€ ë˜ëŠ” ê³³ì—ì„œë§Œ êµ¬í•¨
    - ë§ëŠ” ê²ƒ: red, white ë¦¬ìŠ¤íŠ¸ë¥¼ ë”°ë¡œ ë‘ê³ , ê°ê° ëª‡ ê°œì˜ rowë¥¼ ì°¨ì§€í•  ë•Œì˜ ìˆ˜ì •í•´ì•¼ í•˜ëŠ” cellì˜ ê°œìˆ˜ë¥¼ êµ¬í•œë‹¤
        - í•˜ë‚˜ì˜ í…Œì´ë¸”ì— ë§Œë“œëŠ”ê²Œ ì•„ë‹ˆì—ˆìŒ
- AC ì½”ë“œ(ğŸª‡)
    
    ```python
    from collections import Counter
    def get_num_to_color(matrix):
        num_rows, num_cols = len(matrix), len(matrix[0])
    
        dp = [[float('inf')] * (num_rows+1) for _ in range(num_rows+1)]
    
        # state: dp[i][j]: num switch when num white rows = i, num red rows = j
        # base case: no blue
        switch_to_white = [0]
        switch_to_red = [0]
    
        cur = 0
        for i in range(num_rows):
            cur += num_cols-Counter(matrix[i])['W']
            switch_to_white.append(cur)
    
        cur = 0
        for i in range(num_rows-1, -1, -1):
            cur += num_cols - Counter(matrix[i])['R']
            switch_to_red.append(cur)
    
        # iterative case
        # min: 2, max: num_rows-2
        min_val = float('inf')
        for num_white in range(1, num_rows-1):  # 1~num_rows-2
            for num_red in range(1, num_rows-num_white):  # 1~num_rows-2
                # 0~num_white-1 / num_white~num_rows-1-num_red / num_rows-num_red~num_rows-1
                switch_to_blue = 0
                for idx in range(num_white, num_rows-num_red):
                    switch_to_blue += num_cols - Counter(matrix[idx])['B']
    
                dp[num_white][num_red] = switch_to_white[num_white] + switch_to_red[num_red] + switch_to_blue
    
                if min_val > dp[num_white][num_red]:
                    min_val = dp[num_white][num_red]
    
        return min_val
    
    T = int(input())
    for t in range(1, T+1):
        N, M = map(int, input().split())
        data = []
        for _ in range(N):
            data.append(input())
        ans = get_num_to_color(data)
        print(f'#{t} {ans}')
    ```
    
- ì—„ì²­ í—ˆë¬´í•˜ê³  ë” ì‰¬ìš´ ë°©ë²•
    - ìˆ˜ì •í•´ì•¼ í•˜ëŠ” cellì˜ ê°œìˆ˜ = ì „ì²´ column ê°œìˆ˜ - ë§ëŠ” cellì˜ ê°œìˆ˜
    - ìˆ˜ì •í•´ì•¼ í•˜ëŠ” cellì˜ ê°œìˆ˜ê°€ ìµœì†Œê°€ ëœë‹¤ = ë§ëŠ” cellì˜ ê°œìˆ˜ê°€ ìµœëŒ€ê°€ ëœë‹¤
    
    ```python
    T = int(input())
    for tc in range(1, T+1):
        N, M = map(int, input().split())
        arr = [input() for _ in range(N)]
     
        mx = 0
        for i in range(N-2):
            for j in range(i+1, N-1):
                cnt = 0
                for s in range(i+1):
                    cnt += arr[s].count('W')    # í•˜ì–€ìƒ‰ ê¹ƒë°œ ê°œìˆ˜ count
                for s in range(i+1, j+1):
                    cnt += arr[s].count('B')
                for s in range(j+1, N):
                    cnt += arr[s].count('R')
                mx = max(mx, cnt)
        print(f'#{tc} {N*M-mx}')
    ```