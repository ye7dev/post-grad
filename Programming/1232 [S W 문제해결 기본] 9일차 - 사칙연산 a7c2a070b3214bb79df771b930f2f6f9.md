# 1232. [S/W 문제해결 기본] 9일차 - 사칙연산

Created time: May 2, 2024 3:00 PM
Last edited time: May 2, 2024 5:15 PM

- scratch
    - 1
        
        1 - 2 3
        
        2 - 4 5
        
        3 10
        
        4 88
        
        5 65
        
                1(-)
        
        2(-)         3(10)
        
        4(88)   5(65)
        
        (88-65)-10 = 23-10 = 13
        
    - 2
        
                            1(/)
        
                  2(-)              3(-)
        
           4(261) 5(61)  6(81) 7(71)
        
        261-61 = 200
        
        81-71 = 10
        
        200 / 10 = 20 
        
- 파라미터 값을 업데이트 해도 상위 호출 스택에 반영되지 않는 문제
    - 이것은 함수 내에서 이러한 인자들을 변경하더라도 그 변경사항이 함수 외부에 영향을 미치지 않는다는 것을 의미합니다.
    - 위 코드에서 **`cur_val`**과 **`cur_op`**는 함수의 인자로서, 함수 내에서 이 값을 변경해도 그 변경이 호출한 측에는 반영되지 않습니다. 따라서 함수 내부에서 이 변수들을 변경하는 것은 로컬에서만 유효하고, 함수가 리턴된 후에는 이 변경사항이 손실됩니다.
    
    ```python
    def in_order_op(node, cur_val, cur_op):
        if node.left:
            in_order_op(node.left, cur_val, cur_op)
        if node.val in op_dict: # operation
            cur_op = node.val
        else: # nums
            if cur_val < 0:
                cur_val = node.val
            else:
                cur_val = op_dict[cur_op](cur_val, node.val)
        if node.right:
            in_order_op(node.right, cur_val, cur_op)
        return cur_val
    ```
    
- in-order traversal로 왜 안되지?
    
                        1(/)
    
              2(-)              3(-)
    
       4(261) 5(61)  6(81) 7(71)
    
    이런 상황에서 200 / 까지 만들어서 3에 들어온다 
    
    근데 3에 있는 - 처리하기 전에 6(81)에서 200 /가 그대로 들어온다 
    
    올바른 input은 다시 None이어야 하는데 
    
    생각해보니까 in-order이 아니고!!!!
    
    post order을 해야 겠다!!!! ← 이런 생각을 해낸 나 너무 기특해요 
    
- AC 코드(🪇)
    
    ```python
    class Node:
        def __init__(self, key, val=None, left=None, right=None):
            self.key = key
            self.val = val
            self.left = left
            self.right = right
    
    def post_order_op(node, cur_val, cur_op):
        if node.left:
            left_val, left_op = in_order_op(node.left, cur_val, cur_op)
        if node.right:
            right_val, right_op = in_order_op(node.right, cur_val, cur_op)
    
        # cur_node
        if node.val in op_dict: # operation
            cur_op = node.val
            cur_val = op_dict[cur_op](left_val, right_val)
        else:  # nums
            cur_val = node.val
    
        return cur_val, cur_op
    
    for t in range(1, 2):
        N = int(input())
        nodes = {i: Node(i) for i in range(1, N+1)}
        op_dict = {'+': lambda x, y: (x + y),
                   '-': lambda x, y: (x - y),
                   '*': lambda x, y: (x * y),
                   '/': lambda x, y: (x / y)}
        for _ in range(N):
            data = input().split()
            if len(data) == 2:
                key, val = data
                nodes[int(key)].val = int(val)
            else:
                key, val, left, right = data
                cur_node = nodes[int(key)]
                cur_node.val = val
                cur_node.left = nodes[int(left)]
                cur_node.right = nodes[int(right)]
    
        ans, _ = post_order_op(nodes[1], None, None)
        print(f'#{t} {int(ans)}')
    
    ```