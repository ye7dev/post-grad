# 1824. 혁진이의 프로그램 검증

Created time: April 5, 2024 5:11 PM
Last edited time: April 6, 2024 4:46 PM

- 문제 이해
    
    혁진이는 자신이 개발한 언어 혁셈블리어를 이용해 대회에 참가했다.축제에서 꼭 우승하고 싶은 혁진이는 자신이 작성한 프로그램이 결국에는 멈출 수 있는지 확인하고 싶다.
    
    혁셈블리어는 다음과 같이 동작한다:    
    
    - 프로그램이 수행해야 하는 명령은 문자로 주어지며, 문자들은 2차원 격자 모양으로 줄지어 있다. 다음은 혁셈블리어 프로그램의 예이다.       
    
     6>--v.        
    
    .^--_@ 
    
    - 프로그램은 현재 위치에 있는 문자가 나타내는 명령을 처리하고, 이동 방향에 따라 다음 문자로 이동해야 한다. 
    
    가장 처음 위치는 제일 왼쪽 위에 있는 문자이고, 이동 방향은 오른쪽이다.
    
    명령을 처리하다 보면 이동 방향이 상하좌우로 바뀔 수 있다.     
    
    만약 다음 이동이 2차원 격자의 바깥으로 이동하는 방향이면, 반대편에 있는 위치로 이동한다.     
    
     예를 들어, 첫 번째 줄의 가장 오른쪽 칸에서 오른쪽 방향으로 이동하면 첫 번째 줄의 가장 왼쪽 칸으로 이동한다.     
    
    혁셈블리어에서는 메모리가 단 하나 있으며, 0에서 15사이의 정수를 하나 저장할 수 있다. 
    
    가장 처음에는 0이 저장되어 있다.사용 가능한 명령은 아래와 같다:
    
    | 문자 | 수행 명령 |
    | --- | --- |
    | < | 이동 방향을 왼쪽으로 바꾼다. |
    | > | 이동 방향을 오른쪽으로 바꾼다. |
    | ^ | 이동 방향을 위쪽으로 바꾼다. |
    | v | 이동 방향을 아래쪽으로 바꾼다. |
    | _ | 메모리에 0이 저장되어 있으면 이동 방향을 오른쪽으로 바꾸고, 아니면 왼쪽으로 바꾼다. |
    | | | 메모리에 0이 저장되어 있으면 이동 방향을 아래쪽으로 바꾸고, 아니면 위쪽으로 바꾼다. |
    | ? | 이동 방향을 상하좌우 중 하나로 무작위로 바꾼다. 방향이 바뀔 확률은 네 방향 동일하다. |
    | . | 아무 것도 하지 않는다. |
    | @ | 프로그램의 실행을 정지한다. |
    | 0~9 | 메모리에 문자가 나타내는 값을 저장한다. |
    | + | 메모리에 저장된 값에 1을 더한다. 만약 더하기 전 값이 15이라면 0으로 바꾼다. |
    | - | 메모리에 저장된 값에 1을 뺀다. 만약 빼기 전 값이 0이라면 15로 바꾼다. |
    
    **[입력]**
    
    첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
    
    각 테스트 케이스의 첫 번째 줄에는 두 정수 R, C (2 ≤ R, C ≤ 20) 가 공백으로 구분되어 주어진다.
    
    이는 프로그램이 R행 C열의 문자로 이루어짐을 나타낸다.
    
    다음 R개의 줄의 각 줄에는 C개의 문자로 이루어진 문자열이 주어진다. 주어지는 문자는 위에서 주어진 문자들이다.
    
    **[출력]**
    
    각 테스트 케이스마다 ‘#x’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고,
    
    주어진 프로그램이 정지할 수 있으면 “YES”를 출력하고, 아니면 “NO”를 출력한다.
    
- Trial
    - 지옥의 빡구현
        
        ```python
        def can_stop(mat):
            nrows = len(mat)
            ncols = len(mat[0])
            directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # v, >, ^, <
            visited = [[False for _ in range(ncols)] for _ in range(nrows)]
            memory = 0
        
            def recur(x, y, didx):
                nonlocal memory
                cur_sign = mat[x][y]
                # base case
                if cur_sign == '.':
                    return False
                if cur_sign == '@':
                    return True
        
                if visited[x][y]: # cycle
                    return False
                visited[x][y] = True
        
                if cur_sign == '<':
                    if y == 0:
                        return recur(x, ncols-1, '<')
                    else:
                        return recur(x, y-1, '<')
                if cur_sign == '>':
                    if y == ncols-1:
                        return recur(x, 0, '>')
                    else:
                        return recur(x, y+1, '>')
                if cur_sign == '^':
                    if x == 0:
                        return recur(nrows-1, y, '^')
                    else:
                        return recur(x-1, y, '^')
                if cur_sign == 'v':
                    if x == nrows-1:
                        return recur(0, y, 'v')
                    else:
                        return recur(x+1, y, 'v')
        
                if cur_sign in [str(i) for i in range(10)]:
                    memory = int(cur_sign)
                    if didx == '<':
                        if y == 0:
                            return recur(x, ncols - 1, '<')
                        else:
                            return recur(x, y - 1, '<')
                    if didx == '>':
                        if y == ncols - 1:
                            return recur(x, 0, '>')
                        else:
                            return recur(x, y + 1, '>')
                    if didx == '^':
                        if x == 0:
                            return recur(nrows - 1, y, '^')
                        else:
                            return recur(x - 1, y, '^')
                    if didx == 'v':
                        if x == nrows - 1:
                            return recur(0, y, 'v')
                        else:
                            return recur(x + 1, y, 'v')
        
                if cur_sign == '?':
                    if y == 0:
                        if recur(x, ncols - 1, '<'):
                            return True
                    else:
                        if recur(x, y - 1, '<'):
                            return True
                    if y == ncols - 1:
                        if recur(x, 0, '>'):
                            return True
                    else:
                        if recur(x, y + 1, '>'):
                            return True
                    if x == 0:
                        if recur(nrows - 1, y, '^'):
                            return True
                    else:
                        if recur(x - 1, y, '^'):
                            return True
                    if x == nrows - 1:
                        if recur(0, y, 'v'):
                            return True
                    else:
                        if recur(x + 1, y, 'v'):
                            return True
                    return False
        
                if cur_sign == '_':
                    if memory != 0:
                        if y == 0:
                            return recur(x, ncols - 1, '<')
                        else:
                            return recur(x, y - 1, '<')
                    else:
                        if y == ncols - 1:
                            return recur(x, 0, '>')
                        else:
                            return recur(x, y + 1, '>')
        
                if cur_sign == '|':
                    if memory == 0:
                        if x == nrows - 1:
                            return recur(0, y, 'v')
                        else:
                            return recur(x + 1, y, 'v')
                    else:
                        if x == 0:
                            return recur(nrows - 1, y, '^')
                        else:
                            return recur(x - 1, y, '^')
        
                if cur_sign == '+':
                    if memory == 15:
                        memory = 0
                    else:
                        memory += 1
                    if didx == '<':
                        if y == 0:
                            return recur(x, ncols - 1, '<')
                        else:
                            return recur(x, y - 1, '<')
                    if didx == '>':
                        if y == ncols - 1:
                            return recur(x, 0, '>')
                        else:
                            return recur(x, y + 1, '>')
                    if didx == '^':
                        if x == 0:
                            return recur(nrows - 1, y, '^')
                        else:
                            return recur(x - 1, y, '^')
                    if didx == 'v':
                        if x == nrows - 1:
                            return recur(0, y, 'v')
                        else:
                            return recur(x + 1, y, 'v')
        
                if cur_sign == '-':
                    if memory == 0:
                        memory = 15
                    else:
                        memory -= 1
                    if didx == '<':
                        if y == 0:
                            return recur(x, ncols - 1, '<')
                        else:
                            return recur(x, y - 1, '<')
                    if didx == '>':
                        if y == ncols - 1:
                            return recur(x, 0, '>')
                        else:
                            return recur(x, y + 1, '>')
                    if didx == '^':
                        if x == 0:
                            return recur(nrows - 1, y, '^')
                        else:
                            return recur(x - 1, y, '^')
                    if didx == 'v':
                        if x == nrows - 1:
                            return recur(0, y, 'v')
                        else:
                            return recur(x + 1, y, 'v')
        
            return recur(0, 0, '>')
        
        T = int(input())
        for t in range(1, T+1):
            R, C = map(int, input().split())
            matrix = []
            for _ in range(R):
                matrix.append(input())
            if can_stop(matrix):
                print(f'#{t} YES')
            else:
                print(f'#{t} NO')
        
        ```
        
    - 69개의 테스트케이스 중 58개가 맞았습니다.
        
        ```python
        def can_stop(mat):
            nrows = len(mat)
            ncols = len(mat[0])
            # memory state in visited matrix
            visited = [[[False] * 16 for _ in range(ncols)] for _ in range(nrows)]
            directions = {'v': (1, 0), '^': (-1, 0), '>': (0, 1), '<': (0, -1)}
        
            def recur(x, y, mem, heading):
                # base case
                cur_sign = mat[x][y]
                #print(cur_sign, x, y, mem, heading)
                if cur_sign == '@':
                    return True
                if visited[x][y][mem]:
                    return False
        
                # marking as visited
                visited[x][y][mem] = True
        
                # case1
                if cur_sign in directions:
                    dx, dy = directions[cur_sign]
                    new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                    return recur(new_x, new_y, mem, cur_sign)
                # case2
                elif cur_sign == '.':
                    dx, dy = directions[heading]
                    new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                    return recur(new_x, new_y, mem, heading)
        
                # case 3
                elif cur_sign == '?':
                    for rand_dir in ['v', '^', '>', '<']:
                        dx, dy = directions[rand_dir]
                        new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                        if recur(new_x, new_y, mem, rand_dir):
                            return True
                # case 4
                elif cur_sign in [str(i) for i in range(10)]:
                    mem = int(cur_sign)
                    dx, dy = directions[heading]
                    new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                    return recur(new_x, new_y, mem, heading)
                # case 5
                elif cur_sign in ['+', '-']:
                    if cur_sign == '+':
                        mem = (mem + 1) % 16
                    else:
                        mem = (mem - 1) % 16
                    dx, dy = directions[heading]
                    new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                    return recur(new_x, new_y, mem, heading)
                # case 6
                else:
                    if cur_sign == '_':
                        new_head = '>' if mem == 0 else '<'
                    else:
                        new_head = 'v' if mem == 0 else '^'
                    dx, dy = directions[new_head]
                    new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                    return recur(new_x, new_y, mem, new_head)
        
                return False
        
            return recur(0, 0, 0,'>')
        
        T = int(input())
        for t in range(1, T+1):
            R, C = map(int, input().split())
            matrix = []
            flag = False # '@' existence check
            for _ in range(R):
                row = input()
                if '@' in row:
                    flag = True
                matrix.append(row)
        
            if not flag:
                print(f'#{t} NO')
            else:
                if can_stop(matrix):
                    print(f'#{t} YES')
                else:
                    print(f'#{t} NO')
        
        ```
        
        - 이런 경우 stack overflow-무한재귀호출
            
            ```python
            20 20
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ????????????????????
            ???????????????????+
            ```
            
    - DFS → BFS 전환 중간 단계 1: matrix 4차원으로 수정
        
        ```python
        import sys
        
        sys.stdin = open("/Users/youngeun/Downloads/input-3.txt", "r")
        from collections import deque
        def can_stop(mat):
            nrows = len(mat)
            ncols = len(mat[0])
            # visited state: x, y, mem, dir
            visited = [[[[0]*4 for _ in range(16)] for _ in range(ncols)] for _ in range(nrows)]
            dir_idx = ['v', '^', '>', '<']
            directions = {'v': (1, 0), '^': (-1, 0), '>': (0, 1), '<': (0, -1)}
        
            def recur(x, y, mem, heading):
                # base case
                cur_sign = mat[x][y]
                #print(cur_sign, x, y, mem, heading)
                if cur_sign == '@':
                    return True
                if visited[x][y][mem][heading]:
                    return False
        
                # marking as visited
                visited[x][y][mem][heading] = True
        
                # case1
                if cur_sign in dir_idx:
                    dx, dy = directions[cur_sign]
                    new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                    return recur(new_x, new_y, mem, dir_idx.index(cur_sign))
                # case2
                elif cur_sign == '.':
                    dx, dy = directions[dir_idx[heading]]
                    new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                    return recur(new_x, new_y, mem, heading)
        
                # case 3
                elif cur_sign == '?':
                    for rand_dir in [0, 1, 2, 3]:
                        dx, dy = directions[dir_idx[rand_dir]]
                        new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                        if recur(new_x, new_y, mem, rand_dir):
                            return True
                # case 4
                elif cur_sign in [str(i) for i in range(10)]:
                    mem = int(cur_sign)
                    dx, dy = directions[dir_idx[heading]]
                    new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                    return recur(new_x, new_y, mem, heading)
                # case 5
                elif cur_sign in ['+', '-']:
                    if cur_sign == '+':
                        mem = (mem + 1) % 16
                    else:
                        mem = (mem - 1) % 16
                    dx, dy = directions[dir_idx[heading]]
                    new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                    return recur(new_x, new_y, mem, heading)
                # case 6
                else:
                    if cur_sign == '_':
                        new_head = '>' if mem == 0 else '<'
                    else:
                        new_head = 'v' if mem == 0 else '^'
                    dx, dy = directions[new_head]
                    new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                    return recur(new_x, new_y, mem, dir_idx.index(new_head))
        
                visited[x][y][mem][heading] = False
                return False
        
            return recur(0, 0, 0,2)
        
        T = int(input())
        for t in range(1, T+1):
            R, C = map(int, input().split())
            matrix = []
            flag = False # '@' existence check
            for _ in range(R):
                row = input()
                if '@' in row:
                    flag = True
                matrix.append(row)
            if t == 40:
                print(R, C)
            if not flag:
                print(f'#{t} NO')
            else:
                if can_stop(matrix):
                    print(f'#{t} YES')
                else:
                    print(f'#{t} NO')
        
        ```
        
    - 60/69 BFS 전환 완료
        
        ```python
        import sys
        
        sys.stdin = open("/Users/youngeun/Downloads/input-3.txt", "r")
        from collections import deque
        def can_stop(mat):
            nrows = len(mat)
            ncols = len(mat[0])
            # visited state: x, y, mem, dir
            visited = [[[[0]*4 for _ in range(16)] for _ in range(ncols)] for _ in range(nrows)]
            dir_marks = ['v', '^', '>', '<']
            directions = {0: (1, 0), 1: (-1, 0), 2: (0, 1), 3: (0, -1)}
        
            dq = deque([(0, 0, 0, 2)])
            visited[0][0][0][2] = 1 # marking as enqueing
        
            while dq:
                x, y, mem, heading = dq.popleft()
                cur_sign = mat[x][y]
                #print(cur_sign, x, y, mem, heading)
                # base case
                if cur_sign == '@':
                    return True
        
                # iterative case
                if cur_sign == '?':
                    for rand_dir in [0, 1, 2, 3]:
                        dx, dy = directions[rand_dir]
                        new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                        if not visited[new_x][new_y][mem][rand_dir]:
                            visited[new_x][new_y][mem][rand_dir] = 1
                            dq.append((new_x, new_y, mem, rand_dir))
                    continue # next element in dq
                # case1
                elif cur_sign in dir_marks:
                    new_head = dir_marks.index(cur_sign)
                # case2
                elif cur_sign == '.':
                    new_head = heading
                # case 3
                elif cur_sign in [str(i) for i in range(10)]:
                    mem = int(cur_sign)
                    new_head = heading
                # case 5
                elif cur_sign in ['+', '-']:
                    if cur_sign == '+':
                        mem = (mem + 1) % 16
                    else:
                        mem = (mem - 1) % 16
                    new_head = heading
                else:
                    if cur_sign == '_':
                        new_head = 2 if mem == 0 else 3
                    else:
                        new_head = 0 if mem == 0 else 1
        
                # with updated direction
                dx, dy = directions[new_head]
                new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                if not visited[new_x][new_y][mem][new_head]:
                    visited[new_x][new_y][mem][new_head] = 1
                    dq.append((new_x, new_y, mem, new_head))
        
            return False
        
        T = int(input())
        for t in range(1, T+1):
            R, C = map(int, input().split())
            matrix = []
            flag = False # '@' existence check
            for _ in range(R):
                row = input()
                if '@' in row:
                    flag = True
                matrix.append(row)
            if not flag:
                print(f'#{t} NO')
            else:
                if can_stop(matrix):
                    print(f'#{t} YES')
                else:
                    print(f'#{t} NO')
        
        # mat = ['6>--v.', '.^--_@']
        # can_stop(mat)
        ```
        
    - 예제는 다 맞는 것 같은데….?
        
        ```python
        # import sys
        # 
        # sys.stdin = open("/Users/youngeun/Downloads/input-3.txt", "r")
        # with open("/Users/youngeun/Downloads/output-3.txt", "r") as file:
        #     lines = file.readlines()
        #     output = [line.rstrip() for line in lines]
        
        from collections import deque
        def can_stop(mat):
            nrows = len(mat)
            ncols = len(mat[0])
            # visited state: x, y, mem, dir
            visited = [[[[0]*4 for _ in range(16)] for _ in range(ncols)] for _ in range(nrows)]
            dir_marks = ['v', '^', '>', '<']
            directions = {0: (1, 0), 1: (-1, 0), 2: (0, 1), 3: (0, -1)}
        
            dq = deque([(0, 0, 0, 2)])
            visited[0][0][0][2] = 1 # marking as enqueing
        
            while dq:
                x, y, mem, heading = dq.popleft()
                cur_sign = mat[x][y]
                #print(cur_sign, x, y, mem, heading)
                # base case
                if cur_sign == '@':
                    return True
        
                # iterative case
                if cur_sign == '?':
                    for rand_dir in [0, 1, 2, 3]:
                        dx, dy = directions[rand_dir]
                        new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                        if not visited[new_x][new_y][mem][rand_dir]:
                            visited[new_x][new_y][mem][rand_dir] = 1
                            dq.append((new_x, new_y, mem, rand_dir))
                    continue # next element in dq
                # case1
                elif cur_sign in dir_marks:
                    new_head = dir_marks.index(cur_sign)
                # case2
                elif cur_sign == '.':
                    new_head = heading
                # case 3
                elif cur_sign in [str(i) for i in range(10)]:
                    mem = int(cur_sign)
                    new_head = heading
                # case 5
                elif cur_sign in ['+', '-']:
                    if cur_sign == '+':
                        mem = (mem + 1) % 16
                    else:
                        mem = (mem - 1) % 16
                    new_head = heading
                else:
                    if cur_sign == '_':
                        new_head = 2 if mem == 0 else 3
                    else:
                        new_head = 0 if mem == 0 else 1
        
                # with updated direction
                dx, dy = directions[new_head]
                new_x, new_y = (x + dx) % nrows, (y + dy) % ncols
                if not visited[new_x][new_y][mem][new_head]:
                    visited[new_x][new_y][mem][new_head] = 1
                    dq.append((new_x, new_y, mem, new_head))
        
            return False
        
        T = int(input())
        for t in range(1, T+1):
            R, C = map(int, input().split())
            matrix = []
            flag = False # '@' existence check
            for _ in range(R):
                row = input()
                if '@' in row:
                    flag = True
                matrix.append(row)
            if not flag:
                #ans = f'#{t} NO'
                print(f'#{t} NO')
            else:
                if can_stop(matrix):
                    #ans = f'#{t} YES'
                    print(f'#{t} YES')
                else:
                    #ans = f'#{t} NO'
                    print(f'#{t} NO')
        
            # if ans != output[t-1]:
            #     print(t-1)
        
        # print('correct!')
        
        # mat = ['6>--v.', '.^--_@']
        # can_stop(mat)
        ```