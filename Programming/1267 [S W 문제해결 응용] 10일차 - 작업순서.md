# 1267. [S/W 문제해결 응용] 10일차 - 작업순서

Created time: May 9, 2024 3:26 PM
Last edited time: May 9, 2024 3:58 PM

- topological sorting 복습
    
    위상 정렬을 수행하기 위해서는 두 가지 주요 점을 고려해야 합니다:
    
    1. **사이클 없음**: 위상 정렬은 사이클이 없는 방향 그래프(Directed Acyclic Graph, DAG)에서만 수행될 수 있습니다.
    2. **정렬 순서**: 그래프에 있는 각 정점은 그 정점으로 들어오는 모든 간선들이 처리되어야만 순서에 포함될 수 있습니다.
    
    위상 정렬의 알고리즘은 크게 두 가지 방식으로 구현될 수 있습니다:
    
    ### **1. Kahn의 알고리즘**
    
    Kahn의 알고리즘은 다음과 같은 단계로 이루어집니다:
    
    1. 모든 노드의 진입 차수(들어오는 간선의 수)를 계산합니다.
    2. 진입 차수가 0인 모든 노드를 큐에 삽입합니다.
    3. 큐가 빌 때까지 다음 과정을 반복합니다:
        - 큐에서 원소를 꺼내 출력합니다.
        - 해당 원소와 연결된 노드의 진입 차수를 1 감소시킵니다.
        - 진입 차수가 0이 된 노드를 큐에 삽입합니다.
- AC 코드
    
    ```sql
    import sys
    sys.stdin = open('temp_input/sample_input.txt')
    
    from collections import deque
    def get_procedure():
        ans = []
        visited = [0] * (V+1)
        start = [i for i in range(1, V+1) if in_degree[i] == 0]
        for s in start:
            visited[s] = 1
        queue = deque(start)
        while queue:
            cur_node = queue.popleft()
            ans.append(str(cur_node))
            for neighbor in graph[cur_node]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0 and not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)
        return ans
    
    for t in range(1,11):
        V, E = map(int, input().split())
        graph = {i:[] for i in range(1, V+1)}
        in_degree = [0] * (V+1)
        edges = input().split()
        for i in range(0, 2*E, 2):
            a, b = int(edges[i]), int(edges[i+1])
            graph[a].append(b)
            in_degree[b] += 1
        ans = get_procedure()
        print(f'#{t} {" ".join(ans)}')
    ```