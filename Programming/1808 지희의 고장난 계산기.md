# 1808. 지희의 고장난 계산기

Created time: May 1, 2024 3:12 PM
Last edited time: May 2, 2024 9:50 AM

- scratch
    - 나눈 몫이 주어진 숫자로 만들 수 있는지 어떻게 아는가? X가 10**6이면 최대 7자리라는 건데
- Lessons
    1. recursive 함수가 있을 때는 별도 함수를 하나만 쓸 수 있도록 print 문 전에 만들어 둘 것 들을 미리 만들어둔다
    2. target으로 들어올 수 있는 최소 값은 1이고, base case에서 값을 줘야할 수들은 0~9다 → 따라서 dp table 차원이 target 값에만 의존할 것이 아니라, base case까지 고려해야 한다 ⇒ dp = [초기 cell value] * (target + base case 개수 10) 
    3. dp 각 state마다 세 가지 상태가 있다 
        - dp state: 해당 숫자를 만들 때 최소로 필요한 버튼 누름 횟수
        1. 아예 recur 함수 통과 전 : 초기 cell value -1 
            
            → -1은 recur 함수 들어오면 무조건 다른 숫자로 바뀌게 된다 
            
        2. 직접 작동하는 숫자를 눌러서 만들 수 있는지 체크된 상태 
        3. b에 다가 인수 분해로 만들 수 있는지 체크된 상태 
        
        → b, c 둘 중 하나라도 방법이 있다면 dp[숫자] = 어떤 정수. 두 방법 다 사용해도 답이 안나오면 dp[숫자] = float(’inf’) 
        
    4. base case 
        - 일단 dp[숫자]가 -1이 아니라면 == 해당 숫자를 가지고 recur 함수 이미 처리가 되었다면, 저장해둔 값을 그대로 return 한다
    5. 3-b
        1. string 화 해서 사용하는 방법
            - 전체 숫자를 string 화 한 뒤, 각 자리 숫자가 working 하는 버튼을 갖고 있으면, count 변수 값을 늘린다
            - 중간에 작동 안하는 버튼의 숫자가 나오면 for loop break
            - count 변수 값을 가지고 for loop이 중도에 끝났는지, 아님 다 돌고 종료되었는지 확인 (다 돌고 종료되었으면 count = len(str(num)))
        2. 나눗셈 나머지 사용하는 방법 
            - 제일 마지막 자리 숫자는 10으로 나눈 나머지라는 점을 이용
            - 숫자가 0보다 큰 상태를 유지하는 동안
                - temp = 숫자를 10으로 나눈 나머지 == 마지막 자리
                - 마지막 자리의 버튼 작동 여부 확인
                - 만약 작동 안하면 그대로 while loop break
                - 작동했으면 count 변수 하나 늘리고, 숫자는 10으로 나눈 몫으로 update!
        - a, b 둘 다 했는데도 적절한 변수로 update 못했으면 float(’inf’)로 바꿔둔다
    6. 3-c
        - 소인수 분해 - 숫자 전체에 대해 하는 것이 아니라, 그 숫자의 제곱근까지만 한다
            - 예) 16의 경우 4, 4 다음 가능한 조합은 8 2 인데 얘는 이미 앞에서 2 8 순서 조합으로 확인한 적이 있으므로, 다시 볼 필요 없다
        - 1~제곱근까지 돌면서, 해당 범위에서 인수 후보를 얻는다
            - 인수 후보, 그 인수 후보로 나눈 몫
                - 만약 두 숫자가 정말 인수들이라면 둘을 곱했을 때 지금 숫자를 얻게 된다
            - valid 인수 조건
                1. 지금 숫자를 인수 후보로 나눈 나머지는 0이다 (나누어 떨어진다) 
                2. 인수 후보, 그 후보로 나눈 몫 둘다 dp에서 적절한 값을 가진다 (처리했는데도 방법 찾지 못한 경우 - float(’inf’)- 가 아니다 
            - valid 하면 현재 dp[num] 값 vs. dp[i] + dp[num // i] + 1
                - +1은 곱하기 버튼 때문에 필요
        - 적절한 값으로 update 못 했으면 그냥 3-b 이후 가지게 된 값으로 유지
    7. valid 값을 가지는 경우 마지막에 등호 버튼을 누르는 횟수 1을 더해줘야 한다! 
- Trial
    
    ```python
    from itertools import combinations_with_replacement
    def get_min_press():
        dp = [float('inf')] * (target + 1)
        # base case
        for i in range(10):
            if working[i]:
                dp[i] = 1
    
        num_len = len(str(target))
        combs = list(combinations_with_replacement([i for i in range(10) if working[i]], num_len))
        for c in combs:
            temp = [str(num) for num in c]
            if int("".join(temp)) > target:
                continue
            else:
                i = 0
                while i < len(c):
                    if working[c[i]]:
                        i += 1
                    else:
                        break
                if i == len(c)-1:
                    dp[int("".join(temp))] = len(c)
    
        for i in range(10):
            if not working[i]:
                continue
            for num in range(target, -1, -1):
                q, r = divmod(num, i)
                if r == 0 and dp[num] > dp[q] + 2:
                    dp[num] = dp[q] + 2
        return dp[target]
    
    T = int(input())
    for t in range(1, T+1):
        working = list(map(int, input().split()))
        target = int(input())
        ans = get_min_press()
        print(f'#{t} {ans}')
    ```
    
- 남의 힌트
    
    1. 거꾸로 생각해야한다.2. 주어진 수를 계산기의 버튼으로 누를 수 있는지 검사한다.3. 누를 수 없다면 주어진 수의 제곱근까지를 나눠본다.4. 나누어 떨어지면서 버튼으로 누를 수 있다면 나눈 몫을 재귀함수로 호출한다.5. 가장 최소 호출수인 dfs를 고른다.
    
    출처:
    
    [https://toastfactory.tistory.com/91](https://toastfactory.tistory.com/91)
    
    [이삭이의 토스트 공장:티스토리]
    
- AC 코드
    
    ```python
    import math
    
    def recur(num):
        global dp
        # base case - already processed
        if dp[num] != -1:
            return dp[num]
    
        # direct pressing
        temp = 0
        for char in str(num):
            if working[int(char)]:
                temp += 1
            else:
                break
        if temp == len(str(num)):
            dp[num] = temp
        else:
            dp[num] = float('inf')
    
        # recursive case
        for i in range(1, int(math.sqrt(num)) + 1):
            if num % i == 0:  # factor
                f = recur(i)
                q = recur(num // i)
                if f != float('inf') and q != float('inf'):
                    dp[num] = min(dp[num], f + q + 1)  # +1 for * button
    
        return dp[num]
    
    T = int(input())
    for t in range(1, T+1):
        working = list(map(int, input().split()))
        target = int(input())
    
        # target min: 1 -> 최소 10개는 있어야 base case 만들 수 있다
        dp = [-1] * (target + 10)
    
        # base case
        for i in range(10):
            if working[i]:
                dp[i] = 1
    
        # recursive case
        recur(target)
    
        if dp[target] == float('inf'):
            ans = -1
        else:
            ans = dp[target] + 1  # +1 for '=' button
        print(f'#{t} {ans}')
    
    ```