# 1855. 영준이의 진짜 BFS

Created time: April 9, 2024 5:00 PM
Last edited time: April 11, 2024 3:36 PM

- 다시 짜봤을 때 모르겠는 점
    - [x]  lca에서 b를 얼마나 올려야 하는지
- AC 코드
    
    ```python
    from collections import deque
    import math
    def get_bfs_length(nodes):
        # 자료 구조 초기화
        n = len(nodes) # N + 1
        graph = {i:[] for i in range(1, n)}
        # parent 정보로 depth 구하기
        depth = [0] * n
        for i in range(2, n):
            p = nodes[i]
            graph[i].append(p)
            graph[p].append(i)
            depth[i] = depth[p] + 1
    
        # dp table init - dp[i][j]: i's 2**j th ancestor
        max_level = math.ceil(math.log2(n-1))
        max_depth = math.floor(math.log2(n-1))
        dp = [[-1] * (max_level + 1) for _ in range(n)]
        ## base case
        for i in range(2, n):
            dp[i][0] = nodes[i] # 2**0 = 1 -> parent
        ## iterative case
        for i in range(2, n):
            for j in range(1, max_depth+1):
                if dp[i][j-1] == -1:
                    continue
                dp[i][j] = dp[dp[i][j-1]][j-1]
        # lca
        def lca(a, b):
            if depth[b] > depth[a]:  # a: always lower node
                a, b = b, a
            for i in range(max_depth, -1, -1):
                if depth[a] - (1 << i) >= depth[b]:
                    a = dp[a][i]
            if a == b:
                return b
            for i in range(max_depth, -1, -1):
                if dp[a][i] != dp[b][i]:
                    a = dp[a][i]
                    b = dp[b][i]
            return dp[a][0]
        # bfs
        ans = 0
        dq = deque([1])
        prev_node = 1
        while dq:
            cur_node = dq.popleft()
            cur_lca = lca(prev_node, cur_node)
            ans += (depth[cur_node]-depth[cur_lca]) + (depth[prev_node]-depth[cur_lca])
            for next_node in graph[cur_node]:
                if depth[next_node] > depth[cur_node]:
                    dq.append(next_node)
            prev_node = cur_node
        return ans
    
    T = int(input())
    for t in range(1, T+1):
        N = int(input())
        parents = list(map(int, input().split()))
        # root node: 1, parents[1] = -1, len(parents) = N+1, last idx of parents: N
        parents = [-1, -1] + parents
        ans = get_bfs_length(parents)
        print(f'#{t} {ans}')
    
    ```