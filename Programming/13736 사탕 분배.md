# 13736. 사탕 분배

Created time: June 20, 2024 3:30 PM
Last edited time: June 20, 2024 5:23 PM

- Trial
    - recursive + memo : 예제 3번까지는 통과, input이 커지면 maximum recursion error 발생
        
        ```python
        import sys
        sys.stdin = open('temp_input/sample_input.txt')
        
        def recur(x, y, k):
            # check memo
            state = (x, y, k)
            if state in memo:
                return memo[state]
        
            # base case
            if k == 0:
                return min(x, y)
        
            # recursive case
            p = x
            q = y
            if 2*p >= q-p:
                return recur(q-p, 2*p, k-1)
            else:
                return recur(2*p, q-p, k-1)
        
        T = int(input())
        for t in range(1, T+1):
            A, B, K = list(map(int, input().split()))
            memo = {}
            if A > B:
                ans = recur(B, A, K)
            else:
                ans = recur(A, B, K)
            print(f'#{t} {ans}')
        ```
        
- Solution
    - 일반항을 도출해야 풀 수 있는 문제
        - 그래도 최종 코드는 `min(result, sum - result)`
    - 도대체 이런 건 어떻게 푼담? 점화식을 꼼꼼히 해보면 되려나?
- Scratch
    
    A+B=C로 캔디의 개수는 일정하다는 게 포인트
    
    - A, B 항 두 개를 남겼을 때는 별다른 규칙 못찾음
        1. A ≤ B 인 경우
            - 2A, B-A
                - 2A ≤ B-A
                    - 3A, B-2A
                - 2A > B-A
                    - 2A-(B-A), 2(B-A) = 2A-B+A, 2B-2A = 3A-B, 2B-2A
        2. A > B인 경우
            - A-B, 2B
                - A-B ≤ 2B
                    - 2(A-B) ≤ 2B-(A-B) = 2A-2B, 3B-A
    - B = C-A로 해보자
        
        
        | round1  | 2A, C-2A | 2A-C, 2C-2A |
        | --- | --- | --- |
        | round2 | 4A, C-4A 
        4A-C, 2C-4A | 4A-2C, 3C-4A
        4A-3C, 4C-4A  |
        | round3 | 8A, C-8A 
        8A-C, 2C-8A
        8A-2C, 3C-8A |  |
        - round 1
            1. A ≤ C-A 
                - 2A, C-A-A = C-2A
                - C가 A+B 전체니까 C에서 앞의 값을 뺀 값
            2. A > C-A 
                - A-(C-A), 2*(C-A) = 2A-C, 2C-2A
                - 2A > C 이면서 A < C → 2A < 2C
                    
                    ➜ C < 2A < 2C 
                    
                - 2A = kC + r
                    - 0 ≤ r < C 이고 C < kC+r <2C
                    - 0 ≤ r/C < 1 이고 C-r < kC < 2C-r
                    - 1-r/C < k < 2-r/C 이면 [0.xxx](http://0.xxx) < k < 1.xxx
                    - 따라서 k는 1만 가능
                - 2A = C + r
                    - 2A % C = 2A-C 성립!
        - 나머지 round를 보면 모두 오른쪽 항은 C-왼쪽 항이다
        - 일반항으로 나타내면 `(2^k*A)%C`
            - n번째 단계에서 A개를 가지고 있는 사람이 B개를 갖고 있는 사람보다 더 적다면 2A
                - 2A < C 이면 2A%C 해도 2A
            - 반대의 경우 C-A(B) 개를 빼게 될 테니 2A-C
                - (2A-C) % C 를 하면 ((2A % C) - (C % C))%C 와 동일
                - C %C 는 0이니까 2A % C와 동일