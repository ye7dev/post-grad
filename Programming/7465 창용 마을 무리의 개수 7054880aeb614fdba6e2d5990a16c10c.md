# 7465. 창용 마을 무리의 개수

Created time: April 23, 2024 5:21 PM
Last edited time: April 23, 2024 6:44 PM

- Trial
    - 9/10
        
        ```python
        class UnionFind:
            def __init__(self, size):
                self.root = [i for i in range(size+1)]
                self.level = [1] * (size+1)
            def find(self, x):
                # if or while
                if x != self.root[x]:
                    self.root[x] = self.find(self.root[x])
                return self.root[x]
        
            def union(self, x, y):
                root_x, root_y = self.root[x], self.root[y]
                if root_x != root_y:
                    if self.level[root_x] >= self.level[root_y]:
                        self.root[root_y] = root_x
                        self.level[root_x] += 1
                    else:
                        self.root[root_x] = root_y
                        self.level[root_y] += 1
        
            def is_connected(self, x, y):
                return True if self.find(x) == self.find(y) else False
        
        T = int(input())
        for t in range(1, T+1):
            N, M = map(int, input().split())
            graph = {i: [] for i in range(1, N+1)}
            for _ in range(M):
                a, b = map(int, input().split())
                graph[a].append(b)
                graph[b].append(a)
            UF = UnionFind(N)
            for node_1 in graph:
                for node_2 in graph[node_1]:
                    if not UF.is_connected(node_1, node_2):
                        UF.union(node_1, node_2)
            print(f'#{t} {len(set(UF.root[1:]))}')
        
        ```
        
- AC 코드
    - UF 클래스 정의에서 몇 번 잘못해서 수정
    - 그리고 가장 큰 문제는 self.find를 마지막에 하지 않으면 root가 중간 parent로 설정되어 있는 경우가 있어서, 최종 조상 개수를 return 해야 하는 문제에 오답을 내는 경우가 많았음
    - 그래서 마지막으로 각 노드에 대해 self.find를 꼭 수행해야 함
    
    ```python
    class UnionFind:
        def __init__(self, size):
            self.root = [i for i in range(size)]
            self.level = [1] * size  # rank
    
        def find(self, x):
            # if or while -> if
            if x != self.root[x]:
                self.root[x] = self.find(self.root[x])
            return self.root[x]
    
        def union(self, x, y):
            root_x, root_y = self.find(x), self.find(y)
            if root_x != root_y:
                if self.level[root_x] > self.level[root_y]:
                    self.root[root_y] = root_x
                elif self.level[root_x] < self.level[root_y]:
                    self.root[root_x] = root_y
                else:
                    self.root[root_y] = root_x
                    self.level[root_x] += 1
    
        def is_connected(self, x, y):
            return self.find(x) == self.find(y)
    
    T = int(input())
    for t in range(1, T+1):
        N, M = map(int, input().split())
        graph = {i: [] for i in range(N)}
        for _ in range(M):
            a, b = map(int, input().split())
            graph[a-1].append(b-1)
            graph[b-1].append(a-1)
        UF = UnionFind(N)
        for node_1 in graph:
            for node_2 in graph[node_1]:
                if not UF.is_connected(node_1, node_2):
                    UF.union(node_1, node_2)
    
        for node in graph:
            UF.find(node)
        
        print(f'#{t} {len(set(UF.root))}')
    
    ```