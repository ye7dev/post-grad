# 12/16 시험 문제

Status: done, in progress
Theme: combat
Created time: December 18, 2023 9:48 AM
Last edited time: December 18, 2023 10:20 AM

- 얼마나 맞는지 모르겠는데 chat GPT도 나랑 비슷한 생각을 한 것 같다.
- 코드
    
    ```python
    from collections import Counter
    
    def canTransform(A, B, E):
        if len(A) != len(B):
            return False
    
        counter_B = Counter(B)
    
        def backtrack(index):
            if index == len(A):
                return all(count == 0 for count in counter_B.values())
    
            for delta in [E, -E]:
                next_element = A[index] + delta
    
                if counter_B[next_element] > 0:
                    counter_B[next_element] -= 1
    
                    if backtrack(index + 1):
                        return True
                    
                    # Backtrack
                    counter_B[next_element] += 1
    
            return False
    
        return backtrack(0)
    
    # Example usage
    A = [1, 2, 3]
    B = [4, 3, 2]
    E = 1
    print(canTransform(A, B, E))
    ```
    
- memoization 적용한 경우
    - 근데 argument로 Counter B를 다들고 다녀야 하면 좀 비효율이지 않을까
    
    ```python
    from collections import Counter
    
    def canTransform(A, B, E):
        if len(A) != len(B):
            return False
    
        counter_B = Counter(B)
        memo = {}
    
        def backtrack(index, counter_B, transformations):
            if index == len(A):
                return all(count == 0 for count in counter_B.values())
    
            # Use transformations as part of the memoization key
            state_key = (index, transformations)
    
            if state_key in memo:
                return memo[state_key]
    
            for delta in [E, -E]:
                next_element = A[index] + delta
    
                if counter_B[next_element] > 0:
                    counter_B[next_element] -= 1
    
                    if backtrack(index + 1, counter_B, transformations + (delta,)):
                        memo[state_key] = True
                        return True
                    
                    # Backtrack
                    counter_B[next_element] += 1
    
            memo[state_key] = False
            return False
    
        return backtrack(0, counter_B, ())
    
    # Example usage
    A = [1, 2, 3]
    B = [4, 3, 2]
    E = 1
    print(canTransform(A, B, E))
    ```