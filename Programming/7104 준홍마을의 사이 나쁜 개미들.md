# 7104. 준홍마을의 사이 나쁜 개미들

Created time: May 25, 2024 3:28 PM
Last edited time: May 25, 2024 10:40 PM

- 문제 이해
    
    한쪽 방향으로만 이동 가능
    
    다른 개미와 같은 개미집에 머무는 것, 같은 개미굴을 지나는 것을 싫어한다.
    
    또한 다른 개미가 이미 지나갔던 개미집이나 개미굴로 이동하는 것도 싫어한다.
    
    이동을 시작하는 1번 개미집과 도착하는 2번 개미집에서 만나는 것은 허용한다.
    
    K마리의 개미들이 1번 개미집에서 출발하여 2번 개미집에 도착하는데,
    
    서로 다른 두 개미가 같은 개미집 또는 개미굴을 거치지 않는 것이 가능한 지 계산하는 프로그램을 작성하라.
    
- scratch
    
    최단 경로 문제는 아님 
    
    1→2 갈 수 있는 루트가 K개이상인지를 묻는 문제인데
    
    a-b-c, a-b-d는 같은 루트로 보나 다른 루트로 보나? 
    
    문제 정의에 따르면 a-b는 이미 다른 개미가 지나간 개미굴이니까 안되지 않을까 
    
    아이디어가 안 떠오른다 
    
    1→x→2에서 우선 K개가 존재하는지 봐야 겠네 
    
    최단 경로부터 보고, 그 경로 지나는 거 다 제외하고
    
    그 다음 경로 보고…
    
    dfs로 풀어야 하려나? 루트를 다 저장해두고? 아 아님 백트래킹?
    
- 네트워크 유량에 대한 문제였음
    
    [[네트워크 유량(flow) 문제](https://gseok.gitbooks.io/algorithm/content/b124-d2b8-c6cc-d06c-d50c-b85c-c6b0/d3ec-b4dc-d480-cee4-c2a828-ford-fulkerson-c560-b4dc-baac-b4dc-ce74-d50428-edmonds-karp.html) ](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20%E1%84%8B%E1%85%B2%E1%84%85%E1%85%A3%E1%86%BC(flow)%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%200e8b3ffbc1824f84be9b9906692e2665.md) 
    
- AC 코드
    - 자바 코드 번역
        
        ```sql
        import sys
        sys.stdin = open('temp_input/sample_input.txt')
        from collections import deque
        
        T = int(input())
        for t in range(1, T+1):
            K, N, M = map(int, input().split())
            # 해당 edge를 통해 흐를 수 있는 자원의 최대 양
            capacity = [[0] * (N+1) for _ in range(N+1)]
            # 실제로 edge를 통해 흐르는 자원의 양
            flow = [[0] * (N+1) for _ in range(N+1)]
            # 인접 노드
            adj = [[0] * (N+1) for _ in range(N+1)]
            # 방문 노드
            visited = [0] * (N+1)
            for _ in range(M):
                x, y = map(int, input().split())
        
                if x == 1 and y == 2:
                    K -= 1
                    continue
                capacity[x][y] = 1
                adj[x][y] = adj[y][x] = 1  # 양방향 체크
            res = 0
            ans = 'NO'
        
            if K <= N: # 개미 수가 더 많으면 답 없음
                while True:
                    dq = deque([1])  # source
                    prev = [0] * (N+1)
                    prev[1] = 1 # source
                    visited[1] = 1
        
                    while dq:
                        cur_node = dq.popleft()
                        for next_node in range(1, N+1):
                            # edge 유무 체크
                            if not adj[cur_node][next_node]:
                                continue
                            # 이미 어떤 노드로부터 통과된 노드 (방문 처리 유무 확인)
                            if prev[next_node]:
                                continue
                            if capacity[cur_node][next_node] - flow[cur_node][next_node] > 0:
                                dq.append(next_node)
                                prev[next_node] = cur_node # 방문 처리
                                if next_node == 2:
                                    break # 이번 경로는 완성 되었음 (1->2)
        
                    # 큐 다 돌고도 sink에 도달하지 못했으면 while True문 break
                    if not prev[2]:
                        break
        
                    node = 2
                    while node != 1:
                        parent = prev[node]
                        flow[parent][node] += 1
                        # 역방향으로도
                        flow[node][parent] -= 1
                        if node != 2:
                            visited[node] = 1
                        node = prev[node]
                    res += 1
                print(res)
                if res >= K:
                    ans = 'YES'
        
            print(f'#{t} {ans}')
        ```
        
    - chatGPT 코드 이식