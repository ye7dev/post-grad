# 1224. [S/W 문제해결 기본] 6일차 - 계산기3

Created time: April 29, 2024 4:42 PM
Last edited time: April 29, 2024 6:23 PM

- 문제 이해
    - 3+(4+5)*6 +7 → 345+6*+7+ = 64
        - 후위표현식 계산하는 방법
            - +를 기준으로 앞쪽 두 개의 피연산자 2개를 더한다 = 4+5 = 9
            - 값을 저장하고 다시 연산자를 찾는다
                - 396*
            - *를 기준으로 앞쪽 두 개의 피연산자 2개를 곱한다
                
                = 9*6 = 54 
                
            - 값을 저장하고 다시연산자를 찾는다
                - 354+7+
            - +를 기준으로 앞쪽 두개 피연산자 2개를 더한다
                
                = 3+54= 57 
                
            - 값을 저장하고 다시 연산자를 찾는다
                - 577+
            - +를 기준으로 앞쪽 두 개 피연산자를 더한다
                - 57+7 =. 4
        - 후위표현식 만드는 방법
            - (4+5) → 45+
            - prev*6 → prev6*
            - 3+prev → 3prev+
            - prev+7 → prev7+
            
            → 345+6*+7+ 
            
    - [3+]
    - (4+5) → 45+
    - pop → 얘네append 하고 → 다시 + append
        - [345++]
    - *6
        - pop → [345+] → [345+6*] → [345+6*+]
    - +7
        - 그냥 append
        - [345+6*+7+]
- Trial
    - 도대체 이런 걸 어떻게 생각해낸단 말인지…
        
        ```python
        def do_postfix(data):
            op_dict = {'*':3, '+':2, '(':1}
            stack = []
            ans = ""
            for i in range(len(data)):
                if data[i] == '(':
                    stack.append(data[i])
                elif data[i] == ')':
                    while stack and stack[-1] != '(':
                        ans += stack.pop()
                    if stack:
                        stack.pop()
                elif data[i] == '+' or data[i] == '*':
                    if not stack:
                        stack.append(data[i])
                    elif op_dict[stack[-1]] > op_dict[data[i]]:
                        stack.append(data[i])
                    else:
                        temp = stack.pop()
                        stack.append(data[i])
                else:
                    ans += data[i]
            ans += " ".join(stack)
            res = compute_postfix(ans)
            return res
        
        def compute_postfix(data):
            stack = []
            for i in range(len(data)):
                if data[i] == '+':
                    a, b = stack.pop(), stack.pop()
                    stack.append(a + b)
                elif data[i] == '*':
                    a, b = stack.pop(), stack.pop()
                    stack.append(a * b)
                else:
                    stack.append(int(data[i]))
            return stack[0]
        
        for t in range(1, 2):
            case_len = int(input())
            case = list(input())
            ans = do_postfix(case)
            print(f'#{t} {ans}')
        ```
        
- AC 코드
    
    ```python
    def trans_postfix(data):
        op_dict = {'*':3, '+':2, '(':1}
        stack = []
        exp = ""
        for i in range(len(data)):
            if data[i] == '(':
                stack.append(data[i])
            elif data[i] == ')':
                while stack and stack[-1] != '(':
                    exp += stack.pop()
                if stack: # remove '('
                    stack.pop()
            elif data[i] == '+' or data[i] == '*':
                while stack and stack[-1] != '(' and op_dict[stack[-1]] >= op_dict[data[i]]:
                    exp += stack.pop()
                stack.append(data[i])
            else: # nums
                exp += data[i]
        while stack:
            exp += stack.pop()
        return exp
    
    def compute_postfix(data):
        stack = []
        for i in range(len(data)):
            if data[i] == '+':
                a, b = stack.pop(), stack.pop()
                stack.append(a + b)
            elif data[i] == '*':
                a, b = stack.pop(), stack.pop()
                stack.append(a * b)
            else:
                stack.append(int(data[i]))
        return stack[0]
    
    for t in range(1, 2):
        case_len = int(input())
        case = list(input())
        expression = trans_postfix(case)
        print(expression)
        ans = compute_postfix(expression)
        print(f'#{t} {ans}')
    ```
    
- 도움받은 링크: [https://dheldh77.tistory.com/entry/SWEA-1224-SW-문제해결-기본-6일차-계산기3](https://dheldh77.tistory.com/entry/SWEA-1224-SW-%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0-%EA%B8%B0%EB%B3%B8-6%EC%9D%BC%EC%B0%A8-%EA%B3%84%EC%82%B0%EA%B8%B03)
- 계산식 변환 톺아보기
    - 3+(4+5)*6+7 → 345+6*+7+
        - 가장 안쪽에 있는 괄호가 가장 먼저 계산되는 것도 아니다
    - 데이터는 앞에서부터 읽는다
    - 숫자는 수식에 그대로 들어가고, 연산 기호만 stack에 넣었다가 순서대로 붙여준다
    - stack에 괄호 안쪽 부분을 모두 넣어놨다가 우선순위 맞춰서 수식에 붙여준다
        - ( → stack에 그대로 push
        - ) → stack에 (가 나오기 전까지 내용물 다 pop 해서 수식에 붙여준다
            - 예) stack = [(, +, *] → exp += *, exp += +
            - stack에 남아 있는 괄호 ‘)’도 pop 해서 없애준다
        - +
            
            → stack에 원소가 없으면 바로 넣어준다 
            
            → stack 마지막 원소가 ( 이면, 괄호 다음 나오는 첫 연산이니까 stack에 바로 넣어준다 
            
            → 앞에 *가 있으면 *의 우선 순위가 더 높으니까. pop 해서 수식에 붙여주고 그 다음에 stack에 넣어준다 
            
        - *
            
            → stack에 원소가 없거나 마지막 원소가 (이면 stack에 넣어준다 
            
    - 다 돌고 stack에 남은 것들만 수식에 다 붙여준다
        
        
- 계산식 변환 더 요약하기
    1. 데이터는 앞에서부터 읽는다
    2. 숫자는 그대로 수식에 붙여준다
    3. 스택에는 연산 기호, 괄호만 들어간다 
    4. ‘(’는 새로운 부분 연산의 시작이니까 그대로 stack에 넣어준다 
    5. ‘)’는 부분 연산의 끝이니까 ‘(’ 나오기 전까지 연산기호 순차적으로 pop 해서 수식에 붙여준다 
    6. ‘+’는 stack top에 ‘*’나 ‘+’ 있는지 확인하고 있으면 pop 해서 수식에 붙여준 다음에 자기가 stack에 들어간다 
        - 없으면 그냥 들어간다
        - stack top이 ‘(’이면 처음으로 나오는 부분 연산이라는 뜻으로 5.일 때 나와서 수식에 붙어야 하니까 stack에 얌전히 들어간다
    7. ‘*’는 자기 앞에 ‘*’ 있는지 확인하고, 있으면 pop 해서 수식에 붙여준 다음 자기가 stack에 들어간다 
    8. 데이터 다 읽고 나서는 stack에 남은 원소 pop 해서 하나씩 수식에 붙여준다 
- 예제로 해보기 : 3+(4+5)*6+7
    
    stack = []
    
    exp = 3
    
    stack = [+]
    
    stack = [+, (]
    
    exp = 34
    
    stack = [+, (, +]
    
    exp = 345
    
    ‘)’ → exp = 345+, stack = [+] 
    
    stack = [+, *]
    
    exp = 345+6
    
    +우선순위 < *우선순위 → stack = [+], exp = 345+6* → +우선순위 = +우선순위 → stack = [+], exp =345+6*+
    
    exp = 345+6*+7
    
    stack 남은 원소 모두 수식에 붙이기 
    
    **exp = 345+6*+7+**