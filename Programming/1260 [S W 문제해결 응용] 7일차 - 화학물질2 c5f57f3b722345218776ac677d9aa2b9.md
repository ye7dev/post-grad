# 1260. [S/W 문제해결 응용] 7일차 - 화학물질2

Created time: May 6, 2024 9:56 PM
Last edited time: May 8, 2024 3:58 PM

- 문제 이해
    - 위 그림에서 3개의 행렬 (A(3x4), B(2x3), C(4x5))의 곱셈을 살펴보면, (B*A)*C, 즉, B*A를 먼저 수행하고 그 결과 행렬을 C 와 곱하면, 64번의 원소간 곱셈이 수행된다.
        - B*A = 2x3 * 3x4 → 2x4
            - 결과 행렬의 각 원소 당 3번의 곱셈이 필요 → 8 * 3 = 24
            - 그림 설명
                - 한 원소당 세번의 곱셈이 필요하다
                
                ![Untitled](Untitled%20148.png)
                
        - (B*A)*C = 2x4 * 4x5 → 2x5
            - 결과 행렬의 각 원소당 4번의 곱셈 필요 → 10 * 4 = 40
        
        → 24 + 40 = 64
        
    - 그러나 B*(A*C)의 경우는 90번의 곱셈이 필요하다.
        - A*C = 3x4 * 4x5 → 15*4 = 60
        - B*(A*C) = 2x3 * 3x5 → 10*3 = 30
        
        → 30 + 60 = 90 
        
- Scratch
    - 서브행렬 구하는 거까진 했음
    - 근데 dfs로 최소 곱 구하는 건 아직
        - 중간결과를 어디에 저장할지 생각해야 함
- Trial
    - 예제는 다 맞았는데 2/10 why…?
        
        ```python
        import sys
        sys.stdin = open('temp_input/input.txt', 'r')
        
        def recur(i, num_visited, num_matmul, prev_size):
            mat_visited[i] = True
            num_visited += 1
            # prev_x, prev_y * x, y -> prev_x, y
            prev_x, prev_y = prev_size
            if prev_x == 0 and prev_y == 0:
                x, y = sub_matrices[i]
                cur_matmul = 0
            else:
                x, y = prev_x, sub_matrices[i][1]
                cur_matmul = x * y * prev_y
        
            if num_visited == len(sub_matrices):
                return num_matmul + cur_matmul
        
            temp = float('inf')
            for j in range(num_mat):
                if not mat_visited[j] and sub_matrices[j][0] == y:
                    temp = min(temp, recur(j, num_visited, num_matmul + cur_matmul, [x, y]))
        
            mat_visited[i] = False
            num_visited -= 1
        
            return temp
        
        T = int(input())
        for t in range(1, T+1):
            n = int(input())
            matrix = []
            for _ in range(n):
                row = list(map(int, input().split()))
                matrix.append(row)
        
            # get submatrices
            sub_matrices = []
            visited = [[False] * n for _ in range(n)]
            for i in range(n):
                for j in range(n):
                    if not visited[i][j] and matrix[i][j] != 0:
                        x, y = i, j
                        while x < n and matrix[x][y] != 0:
                            x += 1
                        x -= 1
                        while y < n and matrix[x][y] != 0:
                            y += 1
                        x += 1
                        # mark as visited
                        for r in range(i, x):
                            for c in range(j, y):
                                visited[r][c] = True
                        sub_matrices.append([x-i, y-j])
        
            # matmul
            num_mat = len(sub_matrices)
            ans = float('inf')
            mat_visited = [False] * num_mat
            for idx in range(num_mat):
                ans = min(ans, recur(idx, 0, 0, [0, 0]))
            print(f'#{t} {ans}')
        ```
        
        - submatrix 구하는 부분에는 이상이 없고, chatgpt도 문제 없다는데 이유를 모르겠다
        
- AC 코드
    - dfs로 정렬하는 것 까지는 맞았는데, 그대로 앞에서부터 계산하면 될일이 아니라, 거기 안에서 어떤 쌍끼리 먼저 계산을 하느냐에 따라서 결과가 달라짐
    - dp 점화식 이용
        - [https://skud8049.github.io/알고리즘/swea-1260/](https://skud8049.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/swea-1260/)
    
    ```python
    import sys
    sys.stdin = open('temp_input/input.txt', 'r')
    
    def recur(i, mat_visited):
        mat_visited.append(i)
        # base case
        if len(mat_visited) == num_mat:
            return mat_visited
    
        # recursive case
        for j in range(num_mat):
            if j not in mat_visited and sub_matrices[i][1] == sub_matrices[j][0]:
                temp = recur(j, mat_visited)
                if temp:
                    return temp
        return []
    
    def recur2(i, j):
        # base case
        if dp[i][j] != -1:
            return dp[i][j]
        min_matmul = float('inf')
        for k in range(i, j): # 주의 j 전까지 가야함
            # i_x, k_y * k+1_x, j_y
            cur_matmul = sub_matrices[i][0] * sub_matrices[k][1] * sub_matrices[j][1]
            min_matmul = min(min_matmul, recur2(i, k) + recur2(k+1, j) + cur_matmul)
        dp[i][j] = min_matmul
        return dp[i][j]
    
    T = int(input())
    for t in range(1, T+1):
        n = int(input())
        matrix = []
        for _ in range(n):
            row = list(map(int, input().split()))
            matrix.append(row)
    
        # get submatrices
        sub_matrices = []
        visited = [[False] * n for _ in range(n)]
        for i in range(n):
            for j in range(n):
                if not visited[i][j] and matrix[i][j] != 0:
                    x, y = i, j
                    while x < n and matrix[x][y] != 0:
                        x += 1
                    x -= 1
                    while y < n and matrix[x][y] != 0:
                        y += 1
                    x += 1
                    # mark as visited
                    for r in range(i, x):
                        for c in range(j, y):
                            visited[r][c] = True
                    sub_matrices.append([x-i, y-j])
    
        # make matrix chain
        num_mat = len(sub_matrices)
        for idx in range(num_mat):
            mat_chain = recur(idx, [])
            if mat_chain:
                break
        sub_matrices = [sub_matrices[mat_chain[i]] for i in range(num_mat)]
        # dp matmul - dp[i][j]: min num matmul for sub_matrices[i:j+1]
        dp = [[-1] * num_mat for _ in range(num_mat)]
        # base case
        for i in range(num_mat):
            dp[i][i] = 0
    
        recur2(0, num_mat-1)
        print(f'#{t} {dp[0][num_mat-1]}')
    ```