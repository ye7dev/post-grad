# 10장 조인 심화

### 외부 조인

- 내부 조인: 쿼리가 조인 조건을 충족하는 행만 반환
- 외부 조인: join 하려는 테이블에 행이 있는지 여부에 상관 없이 지금 테이블에 관한 행을 모두 반환
    - left, right 키워드는 데이터에 null이 있을 수 있는 table을 서버에 알려주는 역할
        - a left join b == b right join a (a의 모든 행, b의 추가적인 열)
    - 보통은 left outer join을 많이 사용한다
    - `left outer join` join의 왼쪽에 있는 테이블의 모든 행을 포함. 오른쪽 테이블에 매칭되는 행이 없으면(조인 조건이 실패하면) null로 표시
        - 결과셋의 행수는 왼쪽 테이블이 결정 ↔ 일치하는 항목이 발견될 때마다 열 값을 제공하는 건 오른쪽 테이블
        
        ```sql
        select f.film_id, f.title, count(i.inventory_id) num_copies
        from film f
        	left outer join inventory i
            on f.film_id = i.film_id
        group by f.film_id, f.title;
        ```
        
    - `right outer join` join의 오른쪽 테이블의 모든 행을 포함. 조인 조건이 맞으면 열 값을 제공하는 테이블은 왼쪽 테이블
        
        ```sql
        select f.film_id, f.title, i.inventory_id
        from film f
        	right outer join inventory i
            on f.film_id = i.film_id
        where f.film_id between 13 and 15;
        ```
        
    - 3방향 외부 조인 (three-way outer join)
        - LEFT OUTER JOIN을 여러 개 수행하더라도, 모든 행의 데이터를 항상 포함하는 테이블은 원래 FROM 절에서 언급된 첫 번째 테이블(왼쪽 테이블)입니다. 다른 테이블들은 조인 조건에 따라 매칭되는 행이 있으면 포함되고, 매칭되지 않는 경우에는 NULL 값이 됩니다.
        
        ```sql
        select f.film_id, f.title, i.inventory_id, r.rental_date
        from film f
        	left outer join inventory i
            on f.film_id = i.film_id
            left outer join rental r
            on i.inventory_id = r.inventory_id
        where f.film_id between 13 and 15;
        ```
        

### 교차 조인

- 데카르트 곱 - 모든 가능한 행 조합
    - on 조건 줄 필요 없음. 두 테이블의 행 수를 곱한 값이 결과 셋의 행수
    
    ```sql
    select c.name category_name, l.name language_name
    from category c
    	cross join language l;
    ```
    
- 교차 조인이 유용한 상황
    - [서브쿼리 세 개와 union all을 사용하는 방법](https://www.notion.so/Learning-SQL-6f5006f0a7ae4f3e8456a06a399a1456?pvs=21)
        - 다른 테이블에 조인할 수 있는 3개의 행을 가진 테이블을 만드는 경우
            - 예-총 영화 대여료를 기준으로 고객을 세 그룹으로 분류할 때 필요한 테이블
        - union all을 사용해서 단일 행 테이블을 병합하려는 방법은 큰 테이블을 만들어야 하는 경우에는 잘 맞지 않음
            - 예-날짜마다 한 행 씩 366개(2020년은 윤달)를 만들려면 너무 피곤
                
                ```sql
                select '2020-01-01' dt 
                union all
                ...
                select '2020-12-31' dt
                ```
                
    - 더 나은 방법
        - 하나의 열에 0~366 사이의 숫자를 포함하는 366개 행이 있는 테이블을 생성 → 2020-01-01부터 일수를 더해주기
        - 366개 행이 있는 테이블 생성하기
            1. 일의 자리, 십의 자리, 백의 자리 수를 데카르트 곱하기! 
                - 십의 자리, 백의 자리에도 0을 넣어줘서 한 자리, 두 자리 수가 만들어지게끔 해야 함
                - 이러면 사실 400개(0~399)가 만들어지지만 초과 행은 쉽게 제거 가능
                - 코드
                    
                    ```sql
                    select ones.num + tens.num + hundreds.num days
                    from (select 0 num union all
                    	select 1 num union all
                    	select 2 num union all
                    	select 3 num union all
                    	select 4 num union all
                    	select 5 num union all
                    	select 6 num union all
                    	select 7 num union all
                    	select 8 num union all
                    	select 9 num) ones
                        cross join (select 0 num union all
                    				select 10 num union all
                    				select 20 num union all
                    				select 30 num union all
                    				select 40 num union all
                    				select 50 num union all
                    				select 60 num union all
                    				select 70 num union all
                    				select 80 num union all
                    				select 90 num) tens
                    	cross join (select 0 num union all
                    				select 100 num union all
                    				select 200 num union all
                    				select 300 num) hundreds
                    order by days;
                    	
                    				
                    
                    ```
                    
            2. 숫자 집합을 날짜 집합으로 변환 & 초과 행 제거 하기 
                - 코드
                    
                    ```sql
                    select date_add('2020-01-01', interval (ones.num + tens.num + hundreds.num) DAY) dt 
                    from (select 0 num union all
                    	select 1 num union all
                    	select 2 num union all
                    	select 3 num union all
                    	select 4 num union all
                    	select 5 num union all
                    	select 6 num union all
                    	select 7 num union all
                    	select 8 num union all
                    	select 9 num) ones
                        cross join (select 0 num union all
                    				select 10 num union all
                    				select 20 num union all
                    				select 30 num union all
                    				select 40 num union all
                    				select 50 num union all
                    				select 60 num union all
                    				select 70 num union all
                    				select 80 num union all
                    				select 90 num) tens
                    	cross join (select 0 num union all
                    				select 100 num union all
                    				select 200 num union all
                    				select 300 num) hundreds
                    where date_add('2020-01-01', 
                    	interval (ones.num + tens.num + hundreds.num) DAY) < '2021-01-01'
                    order by 1;
                    ```
                    
        - 장점: DB 서버가 2020-01-01 + 59 할 때 자동으로 결과 셋에 추가 윤일(2020-02-29)를 포함
        - 응용: 2020년(데이터상으로는 2005)의 일별 영화 대여 횟수를 함께 표시하는 보고서를 생성하라
            - 영화를 대여하지 않은 날을 비롯한 그 해의 모든 날이 포함되어야
            - 코드 🍱
                
                ```sql
                select days.dt, count(r.rental_id) num_rentals
                from rental r 
                	right outer join
                		# days 시작 
                		(select date_add('2005-01-01', interval(ones.num + tens.num + hundreds.num) DAY) dt 
                	    from
                		    # ones 만들기
                				(select 0 num union all
                				select 1 num union all
                				select 2 num union all
                				select 3 num union all
                				select 4 num union all
                				select 5 num union all
                				select 6 num union all
                				select 7 num union all
                				select 8 num union all
                				select 9 num
                		        ) ones
                		    # tens 만들기
                		    cross join (select 0 num union all
                						select 10 num union all
                						select 20 num union all
                						select 30 num union all
                						select 40 num union all
                						select 50 num union all
                						select 60 num union all
                						select 70 num union all
                						select 80 num union all
                						select 90 num
                		                ) tens
                		    # hundreds 만들기
                				cross join (select 0 num union all
                							select 100 num union all
                							select 200 num union all
                							select 300 num
                			                ) hundreds
                			where date_add('2005-01-01', interval (ones.num + tens.num + hundreds.num) DAY) < '2006-01-01'
                		) days
                	# right outer join의 조건
                  on days.dt = date(r.rental_date)
                group by days.dt
                order by 1;
                ```
                

### 자연 조인

- DB 서버가 필요한 조인 조건 결정
    - 여러 테이블에서 동일한 열 이름을 사용해서 적절한 조인 조건 추론
- 예시
    
    ```sql
    select c.first_name, c.last_name, date(r.rental_date)
    from customer c
    natural join rental r;
    ```
    
    - 알아서 r.customer_id = c.customer_id를 추가해서 두 테이블을 조인하긴 하지만, 두 테이블에는 각각 last_update 칼럼도 있다
        - 그래서 r.last_update = c.last_update도 조인 조건에 들어가지만, 이 조건을 만족하는 행은 없다
        - 따라서 empty set return
    - natural join으로 결과를 꼭 얻고 싶다면…
        
        ```sql
        select cust.first_name, cust.last_name, date(r.rental_date)
        from 
        	# 서브쿼리 사용해서 customer table 쪽의 last_update 열을 제외한다 
        	(select customer_id, first_name, last_name
            from customer
            ) cust
            # 그럼 열 이름이 동일한 건 customer_id 뿐이라 여기에 대해 조인 실행 
            natural join rental r;
        ```
        
- 결론: natural 조인 유형을 피하고 명시적인 조인 조건과 함께 내부 조인을 사용할 것을 권장
- 실습
    - 10-1
        - me
            
            ```sql
            select c.first_name, c.last_name, sum(p.amount) total_amount
            from customer c 
              left outer join payment p
              on c.customer_id = p.customer_id
            group by c.customer_id;
            ```
            
    - 10-2
        - me
            
            ```sql
            select c.first_name, c.last_name, sum(p.amount) total_amount
            from payment p 
              right outer join customer c
              on c.customer_id = p.customer_id
            group by c.customer_id;
            ```
            
    - 10-3
        - me
            
            ```sql
            select ones.num + tens.num +1
            from (select 0 num union all
            	  select 1 num union all
                  select 2 num union all
                  select 3 num union all
                  select 4 num union all
                  select 5 num union all
                  select 6 num union all
                  select 7 num union all
                  select 8 num union all
                  select 9 num) ones
                  cross join 
            			  (select 0 num union all
            			  select 10 num union all
            			  select 20 num union all
            			  select 30 num union all
            			  select 40 num union all
            			  select 50 num union all
            			  select 60 num union all
            			  select 70 num union all
            			  select 80 num union all
            			  select 90 num ) tens
            order by 1;
            ```