# 5장 다중 테이블 쿼리

- join: 두 테이블의 열을 하나의 결과셋에 포함하도록 하는 것
- 외래키: 두 테이블 간의 연결 수단
- join할 때 외래 키를 주지 않는 경우 (어디를 기준으로 join 할지 알려주지 않는 경우)
    - 두 테이블의 모든 순열 고객 수 599 * 주소 603 = 361197 개의 행을 생성
    
    → 그래서 어디를 기준으로 조인해야 하는지 ON이 필요한 것 
    
    - address_id를 기준으로 조인하면 고객 하나 당 한 열이 나오고, 각 고객에 대응하는 주소가 같이 나옴
- 내부 조인
    - 한쪽 테이블에는 address_id 열의 갑이 있지만, 다른 테이블에는 없는 경우
        - 해당 값을 포함하는 행에 대한 조인은 실패하고, 해당 행이 결과에서 제외
- INNER JOIN 안 쓰고 JOIN 써또 기본값은 내부 조인
- Miscellaneous
    - 조인하려는 열의 이름이 각 테이블에서 동일한 경우 USING을 사용하는 경우도 있음
    - ON 대신 where 사용하는 문법도 있음
- 세 개 이상 테이블 조인
    - from 절에 세 개의 테이블, 2개의 조인 유형, 두 개의 on 하위 절
    - join 순서는 상관 없음
    
    ```sql
    SELECT c.first_name, c.last_name, ct.city
    FROM customer c
    INNER JOIN address a 
    ON c.address_id = a.address_id
    INNER JOIN city ct
    ON a.city_id = ct.city_id; 
    ```
    
- 서브쿼리의 결과 테이블과 조인
    
    ```sql
    SELECT c.first_name, c.last_name, addr.address, addr.city
    FROM customer c
    INNER JOIN (SELECT a.address_id, a.address, ct.city
    			FROM address a 
    				INNER JOIN city ct
    				ON a.city_id = ct.city_id
    			WHERE a.district = 'California'
                ) addr 
                ON c.address_id = addr.address_id;
    ```
    
- 테이블 재사용
    - 원래 코드
        - 정규화가 된 테이블들
            - film: 영화 id, 제목만 존재
            - film_actor: 영화 id, 그 영화에 출연한 배우 id만 존재
            - actor: 배우 id, 배우 이름만 존재
            
            → 세 테이블을 조인해서 마지막에 where 절로 행 필터링 → select로 열 필터링 순으로 진행 
            
        
        ```sql
        SELECT f.title
        FROM film f 
        	INNER JOIN film_actor fa 
            ON f.film_id = fa.film_id
            INNER JOIN actor a 
            ON fa.actor_id = a.actor_id 
        WHERE ((a.first_name = 'CATE' AND a.last_name = 'MCQUEEN')
        		OR (a.first_name = 'CUBA' AND a.last_name = 'BIRCH'));
        ```
        
    - 두 배우가 모두 출연한 영화만 검색한다고 가정
        - 참고로 film_actor table에서 배우 한 명 당 row가 여러 개 생김
            - 여러 영화에 출연했으므로
        - 두 배우가 모두 출연한 영화를 검색한다고 하면
            - film_actor 테이블에서 맥퀸 배우 아이디로 뜨는 모든 영화들과
            - 버치 배우 아이디로 뜨는 모든 영화들 사이의 교집합을 찾아야 함
        - 같은 테이블을 두 번 조인
            
            ```sql
            SELECT f.title # 열 필터링 
            FROM film f 
            	# 맥퀸이 나온 영화 목록 
            	INNER JOIN film_actor fa1 
                ON f.film_id = fa1.film_id
                INNER JOIN actor a1 
                ON fa1.actor_id = a1.actor_id 
                # 같은 테이블 두번 조인 / 버치가 나온 영화 목록 
            	INNER JOIN film_actor fa2 
                ON f.film_id = fa2.film_id
                INNER JOIN actor a2 
                ON fa2.actor_id = a2.actor_id 
              # 여기까지 수행하고 나면 f fa1 a1 fa2 a2 이렇게 조인된 상태 
                # 조건으로 행 필터링 
            WHERE ((a1.first_name = 'CATE' AND a1.last_name = 'MCQUEEN')
            		AND (a2.first_name = 'CUBA' AND a2.last_name = 'BIRCH'));
            ```
            
            - join 후에 테이블 모습 : [f - fa1 - a1 - fa2 - a2]
                - **`JOIN`** 연산은 **`FROM`** 절에서 시작한 기본 테이블에 다른 테이블들을 연결하는 방식으로 작동합니다.
                - 초기 **`FROM`** 절에 지정된 테이블은 전체 쿼리 동안 기준점으로서 한 번만 사용되며, 이후의 **`JOIN`**에서는 추가적으로 명시되지 않습니다.
            - 마지막 select에서 f.title이라고 하는 이유는
                - SQL에서 테이블을 조인한 후에도 각 칼럼이 어느 테이블에서 왔는지 정보는 유지됩니다. 이는 데이터베이스 관리 시스템(DBMS)이 내부적으로 칼럼과 테이블 간의 관계를 관리하기 때문입니다.
- 셀프 조인
    - 테이블을 자기 자신과 조인
    - 자기 참조 외래 키 (self-referencing foreign key)
    - 예) film 테이블에 해당 영화의 전편 (prequel_film_id) 열이 포함되어 있는 경우
        - 셀프 조인 → 전편 제목과 더불어 전편이 있는 모든 영화제목을 나열 하는 쿼리 작성 가능
        
        ```sql
        SELECT f.title, f_prnt.title prequel 
        FROM film f 
        	INNER JOIN film f_prnt # self join
        	**ON f_prnt.film_id = f.prequel_film_id** 
        WHERE f.prequel_film_id IS NOT NULL;
        ```
        
        - inner join 이후 테이블 상태
            - f의 모든 열 f의 모든 열
- 실습
    1. a, ct.city_id ⭕️
    2. John ⭕️
        
        ```sql
        SELECT f.title
        FROM film f
        INNER JOIN film_actor fa 
        ON f.film_id = fa.film_id 
        INNER JOIN actor a 
        ON fa.actor_id = a.actor_id
        WHERE a.first_name = 'JOHN'; 
        ```
        
    3. 같은 도시에 있는 모든 주소 🥳
        - Trial
            
            ```sql
            SELECT a1.address
            FROM address a1 
            INNER JOIN address a2
            ON a1.address_id = a2.address_id
            WHERE a1.city_id = a2.city_id;
            ```
            
            ```sql
            SELECT a1.city_id, a1.address, a2.address
            FROM address a1 
            INNER JOIN address a2
            ON a1.address_id = a2.address_id
            WHERE a1.city_id = a2.city_id AND a1.address != a2.address;
            ```
            
        - Lessons
            - 결과에는 각 도시와 서로 다른 두 주소가 나타나야 함