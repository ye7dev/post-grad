# 14장 뷰

- 개요 (정의, 생성, 쿼리)
    - 뷰의 정의: 데이터를 쿼리하기 위한 메커니즘
        - DB를 설계할 때 테이블을 비공개로 유지하고 사용자가 뷰 집합을 통해서만 데이터에 접근해도 유사한 결과를 얻을 수 있게끔 함
        - 데이터 스토리지가 포함되는 테이블 vs. 포함되지 않는 뷰 → 디스크 공간 차지 X
    - 뷰의 생성: select 문에 이름 지정 → 다른 사용자가 사용할 수 있도록 쿼리를 저장
        - 다른 사용자는 자기가 뷰를 사용 중인지조차 모를 수도
    - 예-customer table의 이메일 주소를 부분적으로 숨기기
        - context: 마케팅 부서에서 이메일 주소에 접근하는 것 외에는 개인보호 정책에 따라 데이터 안전하게 유지해야
        - customer 테이블에 직접 액세스 하는 대신, customer_vw라는 뷰 정의
            - 마케팅 부서 외의 모든 직원은 이걸 사용해서 고객 데이터에 엑세스
        - 뷰 생성
            
            ```sql
            create view customer_vw /* 뷰 이름 */
            	(customer_id,
                first_name,
                last_name,
                email) 
            as
            select customer_id, first_name, last_name, concat(substr(email, 1, 2), '*****', substr(email, -4)) email
            from customer;
            ```
            
            - concat 부분: 이메일의 첫 두 글자 + ‘******+ 마지막 네 글자 연결 (예-'SU*****.org’)
        - 뷰 쿼리
            
            ```sql
            select first_name, last_name, email
            from customer_vw; /* 뷰 이름 */
            ```
            
            - group by, having, order by로 select 문의 절을 자유롭게 사용할 수 있다
                
                ```sql
                select first_name, count(*), min(last_name), max(last_name)
                from customer_vw /* 뷰 이름 */
                where first_name like 'J%'
                group by first_name
                having count(*) > 1 
                order by 1;
                ```
                
            - 쿼리 내에서 다른 테이블이나 뷰에 뷰를 조인할 수 있음
                
                ```sql
                select cv.first_name, cv.last_name, p.amount
                /* 뷰와 다른 테이블을 조인  */
                from customer_vw cv
                	inner join payment p
                    on cv.customer_id = p.customer_id
                where p.amount >= 11;
                ```
                
        - 뷰에서 사용할 수 있는 칼럼 확인
            
            ```sql
            describe customer_vw;
            ```
            
- 뷰를 왜 사용하냐 (보안, 집계, 숨기기, 조인)
    - 데이터 보안
        - 주민등록번호, 신용카드번호 처럼 민감한 데이터가 포함된 열이 있는 테이블
            - 테이블을 비공개로 유지 = 사용자에게 select 권한을 부여하지 않음
            - 중요한 열을 생략하거나 숨기는 하나 이상의 뷰를 생성
        - 뷰 정의에 where절을 추가해서 user group이 접근할 수 있는 row를 제한할 수도 있음
            - 예-비활성 고객에 대한 행은 제외하고 뷰 생성
                
                ```sql
                create view active_customer_vw
                (customer_id,
                first_name,
                last_name,
                email)
                as
                select 	customer_id, first_name, last_name, 
                		concat(substr(email, 1, 2), '*****', substr(email, -4)) email
                from customer
                where active = 1; /* 행 제한 조건 */
                ```
                
    - 데이터 집계
        - 데이터를 사전 집계해서 DB에 저장하는 것처럼 보일 수 있는 좋은 방법
        - 예-관리자가 재고에 추가할 새 영화를 결정할 수 있도록 영화 카테고리별 총 판매량을 보여주는 보고서를 매월 생성한다고 가정
            
            ```sql
            create view sales_by_film_category
            as
            select 
            	c.name as category, sum(p.amount) as total_sales
                /* payment, rental, inventory, film, film_cate, category */
            	from payment as p
            		inner join rental as r 
            			on p.rental_id = r.rental_id
            		inner join inventory as i
            			on r.inventory_id = i.inventory_id
            		inner join film as f 
            			on i.film_id = f.film_id
            		inner join film_category as fc
            			on f.film_id = fc.film_id 
            		inner join category as c 
            			on fc.category_id = c.category_id
            	group by c.name /* 카테고리로 그룹핑 */
              order by total_sales DESC;
            ```
            
            - 뷰로 데이터를 집계하는 대신 테이블에서 미리 집계하는 편이 쿼리 성능에 크게 향상될 것으로 판단되는 경우
                - film_category_sales 테이블을 생성, 집계된 데이터로 로드
                - sales_by_film_category  뷰를 사용하는 모든 쿼리는 새로 생성된 film_category_sales 테이블에서 데이터를 검색하도록 수정
                    - 이 뷰를 사용하는 모든 쿼리에 대해 사용자가 쿼리를 수정하지 않고도 성능 향상
                
                ++ 부가설명
                
                - 뷰(View)는 동적 가상 테이블로서, 항상 최신 데이터를 반영
                    - 뷰를 통해 데이터를 집계하면 기본 테이블에서 직접 데이터를 가져와 실시간으로 집계 결과를 생성
                - 테이블에서 미리 집계
                    - 주기적으로 데이터를 집계하여 결과를 저장 → 쿼리 성능 향상
                    - 미리 집계된 테이블은 일정 주기마다 갱신되기 때문에, 뷰에 비해 항상 최신 데이터를 반영하지 않을 수 있음
                    - 데이터가 변경될 때마다 집계된 테이블을 업데이트해야 하므로 추가적인 유지 관리 작업이 필요
                        
                        ```sql
                        -- 예: 직원의 급여가 변경되었을 때 트리거를 설정하여 자동 업데이트
                        CREATE TRIGGER update_department_salaries
                        AFTER INSERT OR UPDATE OR DELETE ON employees
                        FOR EACH ROW
                        BEGIN
                            -- 집계 테이블 갱신 로직
                        END;
                        ```
                        
    - 복잡성 숨기기
        - 예-매달 모든 영화에 대한 정보를 보여주는 보고서 생성
            
            ```sql
            create view film_stats
            as
            select f.film_id, f.title, f.description, f.rating,
            	 /* category name */ 
            	 (select c.name
                from category c 
            		inner join film_category fc
                    on c.category_id = fc.category_id
            	  where fc.film_id = f.film_id) category_name, 
                /* number of actors */ 
                (select count(*)
                from film_actor fa 
                where fa.film_id = f.film_id) num_actors,
                 /* inventory count */
                (select count(*)
                 from inventory i
                 where i.film_id = f.film_id) inventory_cnt,
                  /* number of rentals */
                (select count(*)
                 from rental r 
            			 inner join inventory i
            			 on i.inventory_id = r.inventory_id) num_rentals
            		 where i.film_id = f.film_id)
            from film f /* 테이블 하나만 있다 */
            ```
            
            - film을 제외한 나머지 테이블의 데이터는 스칼라 서브쿼리를 사용하여 생성
            - 이 뷰를 사용하더라도, select 등에서 서브 쿼리로 정의된 각 열을 참조하지 않으면 서브 쿼리가 실행되지 않음 → 불필요한 테이블의 조인 없이도 사용 가능
    - 분할 데이터의 조인
        - 일부 DB는 설계 시에 성능을 높이고자 큰 테이블을 여러 조각으로 나눔
            - 예-payment_current(최근 6개월) + payment_historic (더 예전)
                - 특정 고객에 대한 모든 결제 내역을 보려면 두 테이블을 모두 조회해야
                - 두 테이블을 각각을 쿼리 한 뒤, 결과를 결합하는 뷰를 작성하면 모든 결제 데이터가 마치 하나의 테이블에 저장된 것처럼 보일 수 있음
            
            ```sql
            create view payment_all
            (payment_id, customer_id, staff_id, rental_id, amount, payment_date, last_update)
            as
            select payment_id, customer_id, staff_id, rental_id, amount, payment_date, last_update
            from payment_historic
            **union all** 
            select payment_id, customer_id, staff_id, rental_id, amount, payment_date, last_update
            from payment_current;
            ```
            
- 갱신 가능한 뷰 (단순, 복잡)
    - 특정 제한 사항을 준수하는 하나의 뷰를 통해 데이터 수정 가능
        - max, min, avg 등의 집계 함수가 사용되지 않음
        - 뷰에는 group by, having 절이 사용하지 않음
        - select, from 절에 서브 쿼리가 없고, where 절의 서브 쿼리는 from 절의 테이블을 참조하지 않음
        - 뷰가 union, union all 또는 distinct를 사용하지 않음
        - from 절에는 최소한 하나 이상의 테이블 또는 갱신 가능한 뷰 (updatable view)가 포함
        - from 절은 테이블이나 뷰가 둘 이상 있는 경우 inner join만 사용
    - 단순한 뷰 업데이트
        - 단일 테이블 쿼리(customer), 4개 열 중 하나만 표현식을 통해 파생(email)
            
            ```sql
            create view customer_vw  
            (customer_id, first_name, last_name, email)  
            as 
            select customer_id, first_name, last_name, concat(substr(email, 1, 2), '*****', substr(email, -4)) email 
            from customer;
            ```
            
        - update 하기
            
            ```sql
            update customer_vw
            set last_name = 'SMITH-ALLEN'
            where customer_id = 1;
            ```
            
            - 테이블 내용도 수정이 되었는가?
                - 수정되었다! (smith → smith-allen)
                    
                    ![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%B2%200408b24c0b98424fab2c54e6a2c3d2ca/Untitled.png)
                    
        - email 열은 표현식에서 파생되므로 수정할 수 없음
            - 뷰를 만든 주 목적이 이메일 주소 숨기기 였으므로 문제 없음
        - 파생 칼럼이 포함된 뷰는 데이터 삽입에 사용할 수 없음
            
            ```sql
            insert into customer_vw
            	(customer_id, first_name, last_name)
            values (99999, 'ROBERT', 'SIMPSON');
            ```
            
            - 파생열(이메일)이 포함 안되어 있는 구문이라도, 해당 칼럼을 갖는 뷰에 데이터 삽입 불가
                - Error Code: 1471. The target table customer_vw of the INSERT is not insertable-into
        
    - 복잡한 뷰 업데이트
        - 기본 쿼리의 from 절에 여러 테이블 포함
            
            ```sql
            create view customer_details
            as 
            /* eleven columns */
            select c.customer_id, c.store_id, c.first_name, c.last_name, c.address_id, c.active, c.create_date,
            		a.address, ct.city, cn.country, a.postal_code
            from customer c
            	inner join address a 
            		on c.address_id = a.address_id
              inner join city ct
            		on a.city_id = ct.city_id
            	inner join country cn
            		on ct.country_id = cn.country_id;
            ```
            
        - 두 개의 구문, 두 테이블의 column 값 수정 가능
            
            ```sql
            /* 구문 1*/
            update customer_details
            set last_name = 'SMITH-ALLEN', active = 0
            where customer_id = 1;
            
            /* 구문 2*/
            update customer_details
            set address = '999 Mockingbird Lane'
            where customer_id = 1;
            ```
            
        - 하나의 구문, 두 테이블의 열 모두 업데이트? → 불가능
            
            ```sql
            update customer_details
            set last_name = 'SMITH-ALLEN',
            active = 0,
            address = '999 Mockingbird Lane'
            where customer_id = 1;
            ```
            
            - Error Code: 1393. Can not modify more than one base table through a join view 'sakila.customer_details'
        - 하나의 구문, 하나의 테이블의 열들에 대해서는 삽입 가능
            
            ```sql
            insert into customer_details
            	(customer_id, store_id, first_name, last_name,
            	address_id, active, create_date)
            values (9998, 1, 'BRIAN', 'SALAZAR', 5, 1, now());
            ```
            
        - 하나의 구문, 두 테이블에 걸친 열들에 대해서 삽입? → 불가능
            
            ```sql
            insert into customer_details
            	(customer_id, store_id, first_name, last_name,
            	address_id, active, create_date, address)
            values (9999, 2, 'THOMAS', 'BISHOP', 7, 1, now(), '999 Mockingbird Lane');
            ```
            
            - Error Code: 1393. Can not modify more than one base table through a join view 'sakila.customer_details'
        - 복잡한 뷰를 통해 데이터를 삽입하려면 각 열의 출처를 명확히 알아야
            - 그러나 원래 뷰의 존재 이유는 최종 사용자의 복잡성을 숨기는 것
            - 사용자가 뷰 정의에 대한 명확한 지식을 갖고 있어야 하는 경우, 목적이 서로 상충
- 실습
    - 1
        - mine
            - film을 기준으로 양방향 조인이 가능한가? 조인 순서는 자율인듯. 모범 답안 참고
                
                ```sql
                create view film_ctgry_actor
                (title, category_name, first_name, last_name)
                as 
                select f.title, c.name, a.first_name, a.last_name
                from actor a 
                	inner join film_actor fa
                		on a.actor_id = fa.actor_id
                	inner join film f
                		on fa.film_id = f.film_id
                	inner join film_category fc
                		on f.film_id = fc.film_id
                	inner join category c 
                		on fc.category_id = c.category_id
                ```
                
                - 마지막에 group by film_id 했다가 select 시에 아래의 에러 발생
                    - Error Code: 1055. Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column '[sakila.c.name](http://sakila.c.name/)' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
                    - group by  할 필요 없었음
        - 모범답안
            
            ```sql
            create view film_ctgry_actor
            (title, category_name, first_name, last_name)
            as 
            select f.title, c.name, a.first_name, a.last_name
            from film f
            	inner join film_category fc
            		on f.film_id = fc.film_id
            	inner join category c
            		on fc.category_id = c.category_id
            	inner join film_actor fa
            		on fa.film_id = f.film_id
            	inner join actor a
            		on fa.actor_id = a.actor_id;
            ```
            
    - 2
        - mine
            
            ```sql
            create view customer_details2
            (country, tot_payments)
            as
            select cnt.country, (select sum(p.amount)
            		from payment p 
            			inner join customer c
            				on p.customer_id = c.customer_id
            			inner join address a
            				on c.address_id = a.address_id
            			inner join city ct
            				on a.city_id = ct.city_id
            			inner join country cnt
            				on ct.country_id = cnt.country_id
            		group by cnt.country_id) 
            from country cnt
            group by cnt.country_id;
            ```
            
        - 모범답안
            
            ```sql
            create view country_payments
            as
            select c.country,
            	(select sum(p.amount)
            	from city ct
            		inner join address a 
            			on ct.city_id = a.city_id
            		inner join customer cst
            			on a.address_id = cst.address_id
            		inner join payment p
            			on cst.customerid = p.customer_id
            	where ct.country_id = c.country_id) tot_payments
            from country c 
            ```