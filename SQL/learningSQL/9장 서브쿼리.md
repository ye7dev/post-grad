# 9장 서브쿼리

- 개요
    - 서브쿼리를 포함하는 구문은 containing statement
    - 항상 괄호 안에 들어가며, containing statement보다 먼저 실행됨
    - statement scope(구문 범위)가 있는 임시테이블처럼 동작
        - containing statement까지 실행 완료되고 나면 subquery가 return한 데이터는 폐기
    - 예-마지막 customer_id를 가진 회원의 정보
        
        ```sql
        select customer_id, first_name, last_name
        from customer
        where customer_id = (select max(customer_id) from customer);
        ```
        
    - 유형
        - return 결과셋의 유형: single row/col, single row/multi col, multi row/multi col
        - noncorrelated subqueries (비상관 서브쿼리)
            - containing statement와는 독립적으로 시행. 포함 구문 실행 전에 먼저 실행 됨
        - correlated subquery (상관 서브쿼리)
            - containing statement의 column을 참조
            - 각 후보행(최종 결과에 포함될 수 있는 행)에 대해 한번씩 실행됨

## noncorrelated subqueries (비상관 서브쿼리)

- 단독 실행 가능, containing statement에서 아무것도 참조하지 않음

### **single column, single row subquery** = scalar subquery

- 일반적인 연산자(=, ≠, <, >, ≤, ≥) 사용해서 조건 양쪽에 넣을 수 있음
- 예-인도에 없는 모든 도시를 반환
    
    ```sql
    select city_id, city
    from city
    where country_id != (select country_id from country where country='India');
    ```
    
- 동등 조건에서 subquery가 둘 이상의 행을 반환하면 오류 발생

### **single column, multi row subquery (**in, not in, all, any)

- 사용 가능 연산자: in, not in, all, any
- 예-특정 국가에 속한 모든 도시 정보 (in)
    - 하나의 표현식이 표현식 집합 내에 있는지 여부를 확인
    
    ```sql
    select city_id, city
    from city
    where country_id in (select country_id 
    										 from country
                         where country in ('France', 'Austria'));
    ```
    
- 예-무료 영화를 대여한 적이 없는 모든 고객(all)
    
    ```sql
    select first_name, last_name
    from customer
    where customer_id != all(select customer_id 
    												 from payment 
    												 where amount=0);
    ```
    
    - 한 집합의 모든 값과 하나의 값 비교 가능
    - subquery 결과: 영화 대여료로 0달러를 지불한 고객의 ID 집합 반환
    - containing query: subquery 결과에 없는 모든 고객 이름을 반환
    - 대부분은 not in을 쓰는 게 더 바람직하다고 함
    
    c.f. not in 이나 ≠ all 사용해서 하나의 값 vs. 집합 내 값 비교할 경우, 집합에 null 값을 포함하지 않도록 주의 
    
    - 표현식의 왼쪽에 있는 값을 집합의 각 멤버와 비교하는데, null 값과 비교하면 unknown이 발생하기 때문
    
    ```sql
    select first_name, last_name
    from customer
    where customer_id not in (122, 452, null); # empty set return 
    ```
    
- 예-영화 대여 횟수가 북미 고객의 대여 횟수를 초과하는 모든 고객 (all)
    
    ```sql
    select customer_id, count(*)
    from rental
    group by customer_id
    having count(*) > all(select count(*) 
    					  from rental r 
    							inner join customer c 
    	            on r.customer_id = c.customer_id 
    	            inner join address a
    	            on c.address_id = a.address_id
    	            inner join city ct
    	            on a.city_id = ct.city_id
    	            inner join country co
    	            on ct.country_id = co.country_id
    					  where co.country in ('United States', 'Mexico', 'Canada')
                group by r.customer_id);				
    ```
    
    - 서브쿼리
        - 렌탈 테이블 들고옴 → 고객 아이디-주소-도시-나라 join 해서 칼럼 연결
        
        → 나라이름으로 필터링 → 고객 아이디로 그룹화 → 행수 count → 해당 칼럼만 return 
        
    - containing statement(포함 구문)
        - 렌탈 테이블 들고 옴 → 고객 아이디로 행들 그룹화
        
        → 서브 쿼리로 들고온 집합 값(count들)과 현재 고객 아이디에 대한 행 수 비교 → 숫자가 큰 행으로 필터링 → 남은 행에서 customer_id, count 칼럼 return 
        
- 예-볼리비아, 파라과이, 칠레의 모든 고객에 대한 총 영화 대여료를 초과하는 총 결제금액을 가진 모든 고객 (any)
    - all과는 달리 집합 값 중 어느 하나에 대해서라도 조건 연산자 만족하면 return
    - = any(집합)의 경우, 집합 값 중 하나만이라도 동일하면 return → in 연산자와 동일
    
    ```sql
    select customer_id, sum(amount)
    from payment
    group by customer_id
    having sum(amount) > any (select sum(p.amount)
    						  from payment p
    								inner join customer c
    	              on p.customer_id = c.customer_id
    	              inner join address a
    	              on c.address_id = a.address_id
    	              inner join city ct
    	              on a.city_id = ct.city_id
    	              inner join country co
    	              on ct.country_id = co.country_id
    						 where co.country in ('Paraguay', 'Chile', 'Bolivia')
                 group by co.country);
    ```
    
    - 서브쿼리
        - payment table 들고 옴 → 고객 id-주소-도시-나라 칼럼 연결 → 나라 이름이 세 개 중 하나인 행들만 필터링 → 나라 이름으로 그룹화 → 나라별로 합계금액 계산 → return (총 3개의 값을 return)
    - containing statement(포함 구문)
        - payment table 들고 옴 → 고객 id로 그룹화 → 그룹별로 amount sum
        
         → 각 그룹마다 sum 값이 서브 쿼리 결과인 세 개의 값 중 어느 하나에 대해서라도 더 크면 그룹 safe 
        
        → 그룹화 이후 필터링된 결과에서 customer_id, sum(amount) 칼럼 return 
        

### **multi column, multi row subquery**

- 여러 개의 single column subquery 사용 예제
    
    ```sql
    select fa.actor_id, fa.film_id
    from film_actor fa
    where fa.actor_id in (select actor_id from actor where last_name = 'MONROE') 
    		and fa.film_id in (select film_id from film where rating = 'PG');
    ```
    
    - 성이 Monroe인 모든 배우와 PG 등급인 모든 영화를 찾기 위해 두 개의 subquery 사용
    - containing statement(포함 구문): subquery에서 얻은 정보를 통해 Monroe라는 배우가 PG 영화에 출연한 모든 사례 검색
- 두 개의 단일 열 subquery를 하나의 multi column subquery로 병합하기
    
    ```sql
    select actor_id, film_id
    from film_actor
    where (actor_id, film_id) in (select a.actor_id, f.film_id
    														  from actor a 
    																cross join film f 
    														  where a.last_name = 'MONROE'
    														  and f.rating = 'PG');
    
    ```
    
    - cross join
        - 두 테이블의 모든 조합을 반환 → 그래서 조건 필요 없음
    - where 필터 조건에서 두 열을 괄호로 묶어 줌 : (actor_id, film_id)
        
        

## correlated subquery (상관 서브 쿼리)

- 포함 구문에 의존적,  각 후보행(최종 결과에 포함될 수 있는 행)에 대해 한번씩 실행됨
- 예-동등조건
    
    ```sql
    select c.first_name, c.last_name
    from customer c
    where 20 = (select count(*) from rental r
    			where r.customer_id = c.customer_id);
    ```
    
    - 서브쿼리 맨 끝의 c.customer_id: 포함 구문에서 가져오는 테이블 중 한 칼럼
    - 포함 쿼리는 customer 테이블에서 모든 행을 검색하고, 각 고객에 대해 한번씩 서브 쿼리를 실행해서 해당하는 고객 ID를 전달
- 예-범위조건 (모든 영화 대여에 관한 총 지불액이 180달러에서 240달러 사이인 모든 고객)
    
    ```sql
    select c.first_name, c.last_name
    from customer c
    where (select sum(p.amount) from payment p
    		where p.customer_id = c.customer_id)
            between 180 and 240;
    ```
    
    - 상관 서브쿼리가 모든 고객 행에 대해 한번씩 실행
        - c.customer_id 하나하나에 대해 sum(p.amount) 계산
        - 이 값이 180~240 사이이면, 해당 행을 살린다
        - 서브쿼리가 조건(between ~)보다 왼쪽에 있다는 점이 독특
    
    c.f. 실수 주의
    
    ```sql
    select sum(p.amount) 
    from payment p, customer c
    where p.customer_id = 12;
    ```
    

### exists 연산자

- 상관 서브쿼리로 작성할 때 가장 일반적으로 사용되는 연산자. 수량에 관계 없이 관계가 존재하는지 확인하고자 사용
- 예-특정 날짜 이전에 영화를 대여한 적이 있는 모든 고객을 찾기
    
    ```sql
    select c.first_name, c.last_name
    from customer c
    where exists(select 1 from rental r 
    						where r.customer_id = c.customer_id
    			            and date(r.rental_date) < '2005-05-25');
    ```
    
    - exists 연산자를 사용하면 0, 1, 또는 여러 개 행을 return 가능
    - where exists - 조건으로는 단순히 서브 쿼리가 하나 이상의 행을 반환했는지 여부만 확인
        - subquery에서 select 한(서브쿼리가 반환한) 데이터가 뭔지는 상관 없음
        - 포함 쿼리의 조건은 반환된 행수만 알면 됨 (0이 아닌지만)
        - 그래서 서브 쿼리의 select 절에 뭘 어떻게 넣든 상관 없음
            - 그러나 규칙은 select 1 또는 select *
- 예-R등급 영화에 출연한 적이 한 번도 없는 모든 배우 (not exists)
    
    ```sql
    select a.first_name, a.last_name
    from actor a
    where not exists (select 1 
    				  from film_actor fa
    					inner join film f on f.film_id = fa.film_id
    				  where fa.actor_id = a.actor_id
    				  and f.rating = 'R');
    ```
    
    - select 1
        - 조건에 맞는 모든 행에 대해 "1"이라는 값을 출력
        - 열 이름을 명시적으로 지정하지 않았기 때문에 SQL 표준에 따라 상수 "1"이 그대로 열 이름으로 사용됨
        - 이런 식으로 나옴
            
            ![Untitled](9%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8F%E1%85%AF%E1%84%85%E1%85%B5%20f6bf599f11694e75bd1fbdb26cb78f7d/Untitled.png)
            
    - 상관쿼리라서 포함 쿼리에서 불러온 actor a의 모든 행에 대해 괄호 안에 있는 서브 쿼리 실행
        
        → 1이 나오면 not exists 조건 만족하지 않으니까 필터링. 안나오면 결과셋에 포함시킴 
        

### 상관 서브쿼리를 이용한 데이터 조작 (update, delete)

- 상관 서브쿼리는 update, delete 문에서 자주 쓰임

```sql
UPDATE customer c
SET c.last_update = (SELECT max(r.rental_date) FROM rental r
					WHERE r.customer_id = c.customer_id);
```

- 여기서도 각 행-customer c의 모든 행-에 대해서 subquery를 한번씩 다 실행
    - 실행 순서는 원래 where → set → update인데, 여기는 where절 없음
    - 각 고객 id에서 가장 늦은 rental date를 찾은 뒤 (subquery 실행)
    - customer table의 last_update 칼럼 값을 update
    - 주의: 대여 기록이 없는 customer가 있는 경우, 서브 쿼리가 행을 반환하지 않으므로, last_update 칼럼 값이 null로 설정될 것
        - null을 허용하지 않는 칼럼이거나 해서 이런 경우 다른 값이 들어가도록 하고 싶으면 coalesce 사용하면 됨
            
            ```sql
            UPDATE customer c
            SET c.last_update = (
                SELECT COALESCE(max(r.rental_date), '1970-01-01')
                FROM rental r
                WHERE r.customer_id = c.customer_id
            );
            
            ```
            
- 예- 두 개의 상관 서브 쿼리
    
    ```sql
    update customer c
    set c.last_update = (select max(r.rental_date) from rental r
    					where r.customer_id = c.customer_id)
    where exists (select 1 from rental r
    			where r.customer_id = c.customer_id);
    ```
    
    - 두 서브쿼리는 select 부분만 빼고 동일.
    - 아까의 코드와는 다르게 set이 모든 행에 대해 다 실행되지 않음
    - where → set → update
        - 모든 행(고객 id)에 대해 빌린 기록(r table에 행)이 한번이라도 있는지 확인
        - 있는 행들만 남기도록 필터링 ← 얘네는 set을 통해 값 update 대상이 된다
        - where절 이후 남은 모든 행들에 대해 set 절에 있는 서브쿼리 실행
        - 각 행마다 얻은 값으로 last_update 칼럼 값 업데이트
- 예-delete 문
    
    ```sql
    delete from customer
    where 365 < ALL (select datediff(now(), r.rental_date) days_since_last_rental
    				from rental r
    				where r.customer_id = customer.customer_id);
    ```
    
    - mySQL의 경우 delete문 실행 시 테이블 별칭이 허용되지 않음 → where절 마지막에 customer 그대로 써줌
    - 대여 시기가 지금으로부터 1년이 넘은 기록만 갖고 있는 행 삭제

## 서브쿼리를 사용하는 경우

### 데이터 소스로서의 서브 쿼리

```sql
select c.first_name, c.last_name,
	pymnt.num_rentals, pymnt.tot_payments
from customer c
	inner join (select customer_id, count(*) num_rentals, sum(amount) tot_payments
				from payment
				group by customer_id) pymnt
	on c.customer_id = pymnt.customer_id;
```

- subquery 결과가 pymnt라는 테이블로 명명됨
- join 대상이 서브쿼리 결과라는 것 말고는 조인 조건이나 select 모두 일반 조인과 다르지 않음
- customer c 테이블 가져옴 → 서브쿼리 실행(고객 id 별로 집계 함수 실행) 결과셋은 multi row, multi row = sub-table, pymnt로 명명 → 조인 조건 맞춰서 조인 (pymnt에서 조건에 맞는 행만 customer c 테이블에 붙여준다) → select에서 호출하는 칼럼들 가져온다
- from절(inner join이 from절의 하위라서 그렇게 표현했는지 모르겠지만…)에서 사용되는 서브쿼리는 비상관 관계여야 한다
- 서브쿼리가 먼저 실행 → 포함 쿼리가 실행을 완료하기 전까지 서브쿼리 결과(뷰)는 메모리에 보관
- 데이터 구성
    - 서브쿼리를 사용해서 DB에 존재하지 않는 데이터르 생성할 수도 있음
    - 예-영화 대여 지불 금액 기준으로 고객을 그룹화하기 원하지만, DB에 저장되지 않은 새 룹 정의를 사용해야 한다고 가정
        - 단일 쿼리로 그룹 생성
            
            ```sql
            select 'Small Fry' name, 0 low_limit, 74.99 high_limit
            UNION ALL
            select 'Average Joes' name, 75 low_limit, 149.99 high_limit
            UNION ALL
            select 'Heavy Hitters' name, 150 low_limit, 99999999 hight_limit;
            ```
            
            ![Untitled](9%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8F%E1%85%AF%E1%84%85%E1%85%B5%20f6bf599f11694e75bd1fbdb26cb78f7d/Untitled%201.png)
            
        - 생성된 그룹을 또 다른 쿼리의 from 절에 넣어서 고객 그룹 생성
            
            ```sql
            select pymnt_grps.name, count(*) num_customers
            from (select customer_id, count(*) num_rentals, sum(amount) tot_payments
            		from payment
            		group by customer_id) pymnt
            	inner join (select 'Small Fry' name, 0 low_limit, 74.99 high_limit
            				UNION ALL
            				select 'Average Joes' name, 75 low_limit, 149.99 high_limit
            				UNION ALL
            				select 'Heavy Hitters' name, 150 low_limit, 99999999 hight_limit) pymnt_grps
            	on pymnt.tot_payments between pymnt_grps.low_limit and pymnt_grps.high_limit
            group by pymnt_grps.name;
            ```
            
            - from절 뒤에 있는 서브 쿼리 실행 - 고객 id별 집계 함수 → sub-table pymnt 불러와둔다
            - inner join 뒤에 있는 서브 쿼리 실행 - 그룹 구분 기준 생성
            - inner join 실행 - 조인 조건이 그동안은 동등(=)이었는데, 여기는 범위인 점 주의
                - 범위 조건에 대한 조인 실행
                    - **각 `pymnt` 행에 대해**: **`pymnt_grps`**의 모든 행을 검사하여 조인 조건을 평가합니다.
                    - **조인 조건**: **`pymnt.tot_payments`** 값이 **`pymnt_grps.low_limit`**와 **`pymnt_grps.high_limit`** 사이에 있는지 확인합니다.
                    - **조건을 만족하는 경우**: 해당 **`pymnt_grps`** 행을 가져와 **`pymnt`** 행과 결합합니다.
                - **`pymnt`** 테이블의 각 행이 **`pymnt_grps`** 테이블의 각 행과 비교되어 조건을 만족하는 행들끼리 결합
            - 범위 그룹 기준으로 그룹핑
            - 그룹화 기준 키 칼럼, 그룹별 행 수 집계한 칼럼 값 낸호기
- 태스크 지향 서브 쿼리
    - 서브쿼리를 사용해서 그룹화 메커니즘을 나머지 쿼리와 분리하는 방법
    - 예- 각 고객의 이름, 도시, 총 대여 횟수, 총 지불액을 보여주는 보고서 생성
        - 기존
            
            ```sql
            select c.first_name, c.last_name, ct.city, sum(p.amount) tot_payments, count(*) tot_rent
            from payment p
            	inner join customer c 
                on p.customer_id = c.customer_id
            	inner join address a
            	on c.address_id = a.address_id
                inner join city ct
                on a.city_id = ct.city_id
            group by c.first_name, c.last_name, ct.city; # why not c.customer_id?
            ```
            
            - customer, address, city 테이블은 결과에서 보여주는 용도로만 필요하며(?)
                - 실제 그룹화에 필요 없는 데 조인을 다 끝난 뒤에 그룹화를 하는 순서니까 쓸데없이 여러 칼럼에 대해 그룹화를 한다는 점이 비효율이었음
            - 막상 그룹화 (customer_id, amount)에 필요한 모든 데이터는 payment 테이블에 있음
            
            → 그룹 생성 작업을 서브 쿼리로 분리한 다음, 다른 세 테이블을 서브쿼리에서 생성된 테이블에 결합하면 원하는 최종 결과를 얻을 수 있다 
            
        - 변경 후
            
            ```sql
            select c.first_name, c.last_name, ct.city, sub_payment.tot_payments, sub_payment.tot_rentals
            from (select p.customer_id, sum(p.amount) tot_payments, count(*) tot_rentals
            		from payment p 
                    group by p.customer_id) sub_payment
            	inner join 	customer c 
                on sub_payment.customer_id = c.customer_id
            	inner join address a
            	on c.address_id = a.address_id
                inner join city ct
                on a.city_id = ct.city_id;
            ```
            
            - 그룹화는 from 절 뒤의 서브 쿼리에서 수행하고, 포함 구문에서는 조인만 수행하면 끝
            - 서브 쿼리에서 나온 결과는 이미 고객 id 기준으로 그룹화 된 상태
                - 집계함수도 다 완료 → 포함구문의 select 절에서는 칼럼 값을 가져오기만 하면 된다
            - 포함 구문에서 더 그룹화할 필요 없는 이유
                - sub_payment의 각 행과 조인할 테이블의 각 행을 비교해서 일치하는 걸 붙인다
                - sub_payment의 각 행은 하나의 고객 id
                - 조인할 테이블들도 잘 보면 하나의 고객 아이디에 대해 여러 데이터가 있을리가 없는 칼럼들이다
                    - 근데 만약 하나의 아이디에 대해, 불가사의한 이유로 여러 데이터가 있는 경우, 모든 행이 다 가져와진다고 함

### 공통 테이블 표현식

- CTE(common table expression)
    - 쿼리 내에서 공통적으로 사용할 수 있는 임시 테이블 형태의 표현식
    - with절 쿼리의 맨 위에 표시되는 서브쿼리, 쉼표로 구분된 여러 CTE를 포함 가능
        - **`WITH`** 절을 사용한 CTE는 한 번의 **`WITH`** 키워드로 여러 CTE를 정의할 수 있습니다. 여러 CTE를 정의할 때 각 CTE는 쉼표(,)로 구분됩니다. 이를 통해 두 번째 CTE가 첫 번째 CTE를 참조하는 형태로 작성할 수 있습니다
    - 쿼리가 더 직관적이고, 각 CTE가 동일한 with절에서 앞에 정의된 다른 CTE 참조 가능
        - 후속 쿼리에서 사용하기 위해 쿼리 결과를 저장할 목적으로 임시 테이블을 사용하지 않아도 된다는 점
- 예
    
    ```sql
    with actors_s as
    	(select actor_id, first_name, last_name
        from actor
        where last_name like 'S%')**, # 콤마 있음** 
        
      actors_s_pg as 
    	(select s.actor_id, s.first_name, s.last_name, f.film_id, f.title
        from actors_s s 
    			inner join film_actor fa
          on s.actor_id = fa.actor_id
          inner join film f
          on f.film_id = fa.film_id
    		where f.rating = 'PG')**, # 콤마 있음** 
    		
      actors_s_pg_revenue as 
        (select spg.first_name, spg.last_name, p.amount
        from actors_s_pg spg
    		inner join inventory i
            on i.film_id = spg.film_id
            inner join rental r
            on i.inventory_id = r.inventory_id
            inner join payment p
            on r.rental_id = p.rental_id
            )
            
    select spg_rev.first_name, spg_rev.last_name, 
    				sum(spg_rev.amount) tot_revenue
    from actors_s_pg_revenue spg_rev
    group by spg_rev.first_name, spg_rev.last_name
    order by 3 desc;
    ```
    
    - 첫번째 CTE: 성이 S로 시작하는 배우들 정보
    - 두번째 CTE: 첫번째 CTE를 출연 영화 정보, 영화별 정보와 결합 → 성이 S로 시작하면서 ‘PG’ 등급에 출연한 경우
    - 세번째 CTE: 두번째 CTE를 재고관리, 대여 정보, 지불 정보와 결합 → 성이 S로 시작하는 배우가 출연한 ‘PG’ 등급 영화와 영화별 대여 비용 정보 결합
    - 최종 쿼리 : 배우 이름별로 그룹화 집계 함수 실행(sum) →  select 절의 세번째 칼럼 기준으로 내림차순 정렬

### 표현식 생성기로서의 서브 쿼리

- [from절에서 서브 쿼리 사용하던 이전 쿼리](https://www.notion.so/Learning-SQL-6f5006f0a7ae4f3e8456a06a399a1456?pvs=21)를 변경
    
    ```sql
    select
    	(select c.first_name from customer c
    	where c.customer_id = p.customer_id) first_name,
    	
    	(select c.last_name from customer c
    	where c.customer_id = p.customer_id) last_name,
    	
    	(select ct.city 
    	from customer c
    		inner join address a
    		on c.address_id = a.address_id
    	    inner join city ct
    	    on a.city_id = ct.city_id
    	where c.customer_id = p.customer_id) city,
    	
    sum(p.amount) tot_payments, count(*) tot_rentals
    from payment p
    group by p.customer_id;
    ```
    
    - 차이점
        - customer, address, city 테이블을 payment에 조인하는 대신, 상관 관계가 있는 스칼라 서브쿼리를 select 절에 사용해서 고객 이름/성, 도시 조회
        - customer 테이블에는 한 번만 액세스하지 않고, 세 개의 서브쿼리에서 각각 한번씩 액세스
            - 서브 쿼리가 스칼라 서브쿼리(하나의 열, 행 반환) → 고객과 관련된 세 개의 열이 필요하면 같은 테이블에 세 개의 다른 서브 쿼리로 세 번 접근
- order by 절에 상관 스칼라 쿼리 사용하기
    
    ```sql
    select a.actor_id, a.first_name, a.last_name 
    from actor a  
    order by (select count(*) 
    					from film_actor fa     
    					where fa.actor_id = a.actor_id) DESC;
    ```
    
    - 출연 영화 편수를 기준으로 배우 id 내림차순 정렬
    - c.f. 왜 원래 썼던 이 쿼리랑은 결과가 다른가?
        
        ```sql
        select a.first_name, a.last_name, count(*) as num_movies
        from actor a 
        	inner join film_actor fa
            on a.actor_id = fa.actor_id
        group by a.first_name, a.last_name
        order by 3 desc;
        ```
        
        - 성과 이름이 같은 사람이 있는 경우, 합산되어서 그룹화 됨 → actor_id로 그룹화해야 동명이인 방지할 수 있음
- insert 문에 비상관 스칼라 쿼리
    
    ```sql
    insert into film_actor (actor_id, film_id, last_update)
    values (
    		-- actor_id column 값 
    		(select actor_id from actor 
    		where first_name = 'JENNIFER' and last_name = 'DAVIS'),
        -- film_id column 값 
        (select film_id from film
        where title = 'ACE GOLDFINGER'),
        -- last_update column 값 
        now()
        );
    ```
    
- 실습
    - 9-1
    - 서브 쿼리 사용 안한 버전
        
        ```sql
        select f.film_id, f.title
        from film f 
        	inner join film_category fc
            on f.film_id = fc.film_id
            inner join category c
            on fc.category_id = c.category_id
        where c.name = 'Action';
        ```
        
    - film 테이블의 필터 조건에 category 테이블에 대한 비상관 서브 쿼리 사용
        
        ```sql
        select f.film_id, f.title
        from film f
        	inner join film_category fc
          on f.film_id = fc.film_id
        where fc.category_id = (select category_id
        												from category
                                where name = 'Action');
        ```
        
    - 모범답안
        - 비상관 쿼리니까 서브 쿼리 먼저 실행 → 포함 구문 실행
        - 서브쿼리
            - film_category 테이블에 카테고리 id 기준으로 카테고리 결합
            - 거기서 카테고리가 액션인 행만 필터링
            - 필터링된 행의 영화 id만 선택
        - 포함 구문
            - 서브 쿼리에서 return된 값 집합 안에 없는 film_id에 대해서는 행 필터링
            - 필터링된 행에서 title 칼럼 값 return
        
        ```sql
        select title
        from film
        where film_id in (select fc.film_id
        									from film_category fc 
        										inner join category c
        										on fc.category_id = c.category_id
        									where c.name = 'Action');
        ```
        
    - 9-2
        - me
            
            ```sql
            select sub_fc.film_id
            from (select fc.film_id
            	from film_category fc
                where fc.category_id = (select c.category_id
            							from category c
            							where c.name = 'Action')) sub_fc;
            ```
            
        - 모범답안
            - 상관 쿼리라서 후보 row 모든 행에 대해 서브 쿼리 실행
            
            ```sql
            select f.title
            from film f
            where exists (select 1
            			  from film_category fc 
            					inner join category c
            					on fc.category_id = c.category_id
                    where c.name = 'Action' and fc.film_id = f.film_id);
            ```
            
            - film f의 각 row 하나마다 서브 쿼리가 실행됨
                - 그니까 서브 쿼리만 돌리면 1로 가득찬 칼럼이 나와서 이 1이 어느 행 값인지 알 수 없겠지만
                - 행마다 돌리면 당장 1이 나오냐 안나오냐만 알 수 있기 때문에 당연히 행 필터링한느데 사용될 수가 있다
    - 9-3
        - me
            
            ```sql
            select fa_grp.actor_id, fa_grp.num_roles, level_tbl.level
            from (select fa.actor_id, count(*) as num_roles
            	  from film_actor fa 
            	  group by fa.actor_id) fa_grp
            	inner join (select 'Hollywood Start' level, 30 min_roles, 99999 max_roles
            				union all
            				select 'Prolific Actor' level, 20 min_roles, 29 max_roles
            				union all
            				select 'Newcomer' level, 1 min_roles, 19 max_roles) level_tbl
            	on fa_grp.num_roles between level_tbl.min_roles and level_tbl.max_roles;
            ```
            
        - 모범답안
            
            ```sql
            select actr.actor_id, grps.level 
            from (select actor_id, count(*) as num_roles
            			from film_actor
            			group by actor_id
            			) actr 
            	inner join (select 'Hollywood Start' level, 30 min_roles, 99999 max_roles
            							union all
            							select 'Prolific Actor' level, 20 min_roles, 29 max_roles
            							union all
            							select 'Newcomer' level, 1 min_roles, 19 max_roles
            							) grps
            	on actr.num_roles between grps.min_roles and grps.max_roles;
            ```