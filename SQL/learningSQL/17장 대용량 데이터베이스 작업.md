# 17장 대용량 데이터베이스 작업

- 분할(partitioning) ❤️‍🔥
    - 테이블 행수가 몇 백만개 이상으로 증가하면 시간 오래 걸리기 시작
        - 이런 상황에서 가시적으로 시간이 오래 걸리는 작업들
            - 전체 테이블 검색이 필요한 쿼리 실행
            - 인덱스 생성/재작성
            - 데이터 보관/삭제
            - 테이블/인덱스 통계 생성
            - 테이블 재배치(relocation) (예: 다른 테이블스페이스로 이동)
            - 데이터베이스 백업
    - 테이블을 ‘처음 만들 때’ 큰 테이블을 여러 조각으로 분할
    - 관리작업은 개별 파티션에서 동시에 병렬로 수행
        - 일부 작업은 하나 이상의 파티션을 완전히 건너뛸 수도 있음
    - 개념
        - 테이블 분할 → 테이블 자체는 가상 개념. 데이터 보관은 파티션이. 모든 인덱스도 파티션 데이터에 기반을 두고 구축
            - 그러나 사용자는 테이블 분할 여부를 알지 못한 채 테이블과 상호작용 가능 (뷰와 유사)
        - 모든 파티션의 스키마 정의(열, 열 유형 등)은 동일
        - ↔ 파티션마다 서로 다를 수 있는 몇 가지 관리 기능
            - 파티션은 물리적으로 스토리지 계층을 달리하는. 다른 테이블스페이스에 저장될 수 있음
            - 다른 압축 방식을 사용하여 파티션을 압축할 수 있음
            - 일부 파티션의 경우 로컬 인덱스 사용 가능
            - 일부 파티션에서는 테이블 통계 고정하고, 다른 파티션에서는 정기적으로 update 가능
            - 개별 파티션을 메모리에 고정하거나 DB의 flash storage 계층에 저장 가능
    - 테이블 분할
        - 수평 분할
            - 전체 행을 정확히 하나의 파티션에 할당
            - 파티션 키 선택
                - 특정 파티션에 행을 할당할 때 사용하는 값이 있는 열
                - 단일 열로 구성
                - 파티션 함수가 파티션 키 칼럼에 적용 → 각 행이 어느 파티션에 있어야 하는지 결정
                    - 해쉬 함수 같은 느낌
        - 수직 분할
            - 수동으로 열 집합을 각각 다른 파티션에 할당하는 작업을 수행
    - 인덱스 분할
        - 글로벌 인덱스
            - 분할된 테이블에 인덱스가 있는 경우 글로벌 인덱스라는 특정 인덱스를 유지할지 말지 선택  가능
            - 테이블의 모든 파티션에 걸쳐 있으며 파티션 키의 값을 지정하지 않은 쿼리에 유용
                - 예-테이블이 sale_date 칼럼 기준으로 분할되어 있을 때 사용자 쿼리 실행
                    
                    ```sql
                    SELECT sum(amount) from sales where geo_region_cd = 'US'
                    ```
                    
                    - 필터 조건에 파티션 키인 sale_date 칼럼을 포함하지 않음
                    - 총 판매량을 찾기 위해 모든 파티션 검색
                    - 글로벌 인덱스가 geo_region_cd 칼럼에 구축된 경우, 서버는 이 인덱스를 사용해서 미국 매출이 포함된 모든 행을 신속하게 탐색 가능
        - 로컬 인덱스
            - 각 파티션에 자체 인덱스를 갖도록 조각으로 나눌지 여부 선택
    
    ### 분할 방식
    
    ### 범위 분할
    
    - 날짜 기간 별로 테이블 분할하는 경우가 대표적
        
        ```sql
        create table sales 
        	(sale_id int not null,
        	 cust_id int not null,
        	 store_id int not null,
        	 sale_date date not null,
        	 amount decimal(9, 2)
        	 )
        partition by range(yearweek(sale_date))
        	(partition s1 values less than (202002),
        	 partition s2 values less than (202003),
        	 partition s3 values less than (202004),
        	 partition s4 values less than (202005),
        	 partition s5 values less than (202006),
        	 partition s999 values less than (maxvalue)
        	 );
        ```
        
        - 처음 4주 동안 매주 하나씩 5개의 파티션 생성, 2020년의 5주차 이후 모든 행을 보관하는 s999라는 6번째 파티션
        - 파티션 키: sale_date
        - 파티션 함수: yearweek()
    - 분할된 테이블에 대한 메타데이터(파티션 정보) 확인
        
        ```sql
        select partition_name, partition_method, partition_expression
        from information_schema.partitions
        where table_name = 'sales'
        order by partition_ordinal_position
        ```
        
    - s999(maxvalue) 파티션에 추가되지 않도록 미래 데이터를 보관할 새 파티션 생성
        - s999: maxvalue 파티션 = 다른 파티션에 매핑되지 않는 모든 행이 들어간다
        
        ```sql
        alter table sales reorganize partition s999 into
        (partition s6 values less than (202007),
        partition s7 values less than (202008),
        partition s999 values less than (maxvalue)
        );
        ```
        
    - from + partition 하위절 → 각 파티션 행 수 계산
        
        ```sql
        select concat('# of rows in S1 = ', count(*)) partition_rowcount
        from sales partition(s1) 
        union all
        select concat('# of rows in S2 = ', count(*)) partition_rowcount
        from sales partition(s2) 
        union all
        select concat('# of rows in S3 = ', count(*)) partition_rowcount 
        from sales partition(s3) 
        union all 
        select concat('# of rows in S4= ', count(*)) partition_rowcount 
        from sales partition(s4) 
        union all
        select concat('# of rows in S5 = ', count(*)) partition_rowcount 
        from sales partition(s5) 
        union all
        select concat('# of rows in S6 = ', count(*)) partition_rowcount 
        from sales partition(s6) 
        union all
        select concat('# of rows in S7 = ', count(*)) partition_rowcount 
        from sales partition(s7) 
        union all
        select concat('# of rows in S999 = ', count(*)) partition_rowcount 
        from sales partition(s999);
        
        ```
        
    
    ### 목록 분할
    
    - 분할 키로 선택한 열에 (CA, TX, VA 등의) 상태 코드나 (USD, EUR, JPY 등의) 통화 또는 기타 열거된 값 집합이 포함된 경우, 목록 분할을 활용하여 각 파티션에 할당할 값을 지정할 수 있음
        - 목록 분할에서는 범위 분할에서처럼 maxvalue 파티션을 둘 수 없기 때문에, 없는 카테고리 값이 들어올 때마다 파티션 정의를 미리 수정해야 한다.
        - 분할 키로 선택한 열에 적은 수의 값만 포함되어야
    - 예-지리적 영역 그룹화, 각 값에 대한 파티션
        
        ```sql
        create table sales2
        (sale_id int not null,
        cust_id int not null,
        store_id int not null,
        sale_date date not null,
        geo_region_cd varchar(6) not null,
        amount decimal(9, 2)
        )
        partition by list columns (geo_region_cd)
        (partition northamerica values in ('us_ne', 'us_se', 'us_mw', 'us_nw', 'us_sw', 'can', 'mex'),
        partition europe values in ('eur_e', 'eur_w'),
        partition asia values in ('chn', 'jpn', 'ind')
        );
        ```
        
        - 파티션에 할당되지 않는 칼럼 값이 들어오는 경우
            - 예-asia 카테고리에 ‘kor’ 값이 없는데 `(3, 6, 27, '2020-03-11', 'kor', 4267.12);` row가 들어온 경우
                
                → Error Code: 1136. Column count doesn't match value count at row 1
                
        - 파티션에 카테고리 값 추가하기 = 파티션 수정(카테고리 하나만 쏙 넣는 것은 불가)
            
            ```sql
            alter table sales reorganize partition asia into
            (partition asia values in ('chn', 'jpn', 'ind', 'kor'));
            ```
            
    
    ### 해시 분할
    
    - 파티션 집합에 행을 고르게 분산하기
    - 칼럼(분할 키) 값에 해싱 함수 적용
    - 분할 키 열에 많은 고윳값이 포함된 경우(cardinality가 큰 경우) 해시 분할이 가장 잘 작동
    - 예-고객 id 칼럼 값 기준으로 해싱해서 파티션
        
        ```sql
        CREATE TABLE sales3
        	(sale_id INT NOT NULL,
            cust_id INT NOT NULL,
            store_di INT NOT NULL,
            sale_date DATE NOT NULL,
            amount DECIMAL(9, 2)
            )
        PARTITION BY HASH (cust_id)
        	PARTITIONS 4
        		(PARTITION H1,
            PARTITION H2,
            PARTITION H3,
            PARTITION H4); 
        ```
        
        - [ ]  partition 함수도 지정이 가능한가? default 함수는 뭐지?
        - 값 삽입 코드
            
            ```sql
            INSERT INTO sales3
            VALUES
            	(1, 1, 1, '2020-01-18', 1.1), 
                (2, 3, 4, '2020-02-07', 1.2),
                (3, 17, 5, '2020-01-19', 1.3),
                (4, 23, 2, '2020-02-08', 1.4),
                (5, 56, 1, '2020-01-20', 1.6),
                (6, 77, 5, '2020-02-09', 1.7),
                (7, 122, 4, '2020-01-21', 1.8),
                (8, 153, 1, '2020-02-10', 1.9),
                (9, 179, 5, '2020-01-22', 2.0),
                (10, 244, 2, '2020-02-11', 2.1),
                (11, 263, 1, '2020-01-23', 2.2),
                (12, 312, 4, '2020-02-12', 2.3),
                (13, 346, 2, '2020-01-24', 2.4),
                (14, 389, 3, '2020-02-13', 2.5),
                (15, 472, 1, '2020-01-25', 2.6),
                (16, 502, 1, '2020-02-14', 2.7);
            ```
            
    - 삽입한 값이 partition 별로 잘 분할되어 들어갔는지 확인
        
        ```sql
        SELECT concat('# of rows in H1 = ', count(*)) partition_rowcount
        FROM sales3 PARTITION (h1) UNION ALL
        SELECT concat('# of rows in H2 = ', count(*)) partition_rowcount
        FROM sales3 PARTITION (h2) UNION ALL
        SELECT concat('# of rows in H3 = ', count(*)) partition_rowcount
        FROM sales3 PARTITION (h3) UNION ALL
        SELECT concat('# of rows in H4 = ', count(*)) parittion_rowcount
        FROM sales3 PARTITION (h4);
        ```
        
    
    ### 복합 분할
    
    - 더 세밀하게 데이터 할당을 제어해야 할 때 사용하는 composite partitioning
    - 동일한 테이블에 서로 다른 두 유형의 분할 적용
    - 첫번째 분할 방법이 파티션 정의 ➜ 두번째 분할 방법이 하위 파티션 정의
    - 예-범위 분할 + 해쉬분할
        
        ```sql
        CREATE TABLE sales4 
        (sale_id INT NOT NULL,
        cust_id INT NOT NULL,
        store_id INT NOT NULL,
        sale_date DATE NOT NULL,
        amount DECIMAL(9, 2)
        )
        PARTITION BY RANGE (yearweek(sale_date))
        SUBPARTITION BY HASH (cust_id)
        (PARTITION s1 VALUES LESS THAN (202002)
            (SUBPARTITION s1_h1, 
            SUBPARTITION s1_h2,
            SUBPARTITION s1_h3,
            SUBPARTITION s1_h4),
        PARTITION s2 VALUES LESS THAN (202003)
            (SUBPARTITION s2_h1, 
            SUBPARTITION s2_h2,
            SUBPARTITION s2_h3,
            SUBPARTITION s2_h4),
        PARTITION s3 VALUES LESS THAN (202004)
            (SUBPARTITION s3_h1, 
            SUBPARTITION s3_h2,
            SUBPARTITION s3_h3,
            SUBPARTITION s3_h4),
        PARTITION s4 VALUES LESS THAN (202005)
            (SUBPARTITION s4_h1, 
            SUBPARTITION s4_h2,
            SUBPARTITION s4_h3,
            SUBPARTITION s4_h4),
        PARTITION s5 VALUES LESS THAN (202006)
            (SUBPARTITION s5_h1, 
            SUBPARTITION s5_h2,
            SUBPARTITION s5_h3,
            SUBPARTITION s5_h4),
        PARTITION s999 VALUES LESS THAN (maxvalue)
            (SUBPARTITION s999_h1, 
            SUBPARTITION s999_h2,
            SUBPARTITION s999_h3,
            SUBPARTITION s999_h4)
        );
        ```
        
        - c.f. 반복되는 sql문 python for loop으로 만들기
            
            ```python
            partitions = []
            for i in range(1, 6):  # 원하는 범위로 설정하세요
                s = f"""PARTITION s{i} VALUES LESS THAN (20200{i+1})
                (SUBPARTITION s{i}_h1, 
                SUBPARTITION s{i}_h2,
                SUBPARTITION s{i}_h3,
                SUBPARTITION s{i}_h4),"""
                partitions.append(s)
            
            result = "\n".join(partitions)
            print(result)
            ```
            
        - [해쉬분할에서 사용한 것과 같은 데이터 삽입](https://www.notion.so/Learning-SQL-6f5006f0a7ae4f3e8456a06a399a1456?pvs=21)
    - 분할 결과 확인
        - 하나의 상위 파티션 내에서 하위 파티션 분할 결과 확인
            
            ```sql
            SELECT *
            FROM sales4 PARTITION (s3);
            ```
            
        - 하나의 하위 파티션에서 데이터를 검색
            
            ```sql
            SELECT *
            FROM sales4 PARTITION (s3_h3); 
            ```
            
    - 분할 이점
        - 파티션 프루닝
            - 서버가 쿼리를 보고 테이블의 메타 데이터를 사용하여 실제로 포함되어야 하는 파티션을 결정
            - 전체 테이블이 아니라 파티션과 상호작영 하면 됨
        - 파티션 와이즈 조인
            - 분할된 테이블에 대해 조인이 포함된 쿼리를 실행하고, 쿼리에 분할열 조건이 포함된 경우
                - 서버는 쿼리와 관련된 데이터를 포함하지 않는 모든 파티션을 제외
        - 더 이상 필요하지 않은 데이터를 신속하게 삭제 가능
            - where절로 행 일일이 검색하는 것보다 파티션 drop 하는게 훨씬 빠름
        - 여러 파티션에서 동시에 업데이트 수행 가능
- 군집화
    - 수천명의 동시 사용자를 처리하거나 야간에 수만건의 보고서 생성해야 할 때
    - 데이터 스토리지가 충분해도 단일 서버 내에 cpu, 메모리, 네트워크 대역폭이 충분하지 않을 ㅅ ㅜ있음
    - 군집화 → 여러 서버가 단일 데이터 베이스 역할을 함
    - 여러 군집화 아키텍쳐가 ㅗㄴ재
    - 공유 디스크/공유 캐시 구성
        - 클러스터의 모든 서버가 모든 디스크에 액세스 가능
        - 클러스터의 다른 서버가 하나의 서버에 캐시된 데이터에 액세스 가능
        - app 서버는 클러스터에 있는 db 서버 중 하나에 연결
        - 장애가 발생할 경우 그 커넥션이 클러스터의 다른 서버로 자동 failover
        - 오라클이 이 분야의 선두 주자. 엑사데이터 플랫폼
- 샤딩
    - 예상 사용자 수 약 10억명, 각 사용자는 하루 평균 3.7개의 메시지 생성, 데이터는 무한정 사용할 수 있어야 → 계산해봤더니 사용 가능한 대규모 RDBMS를 1년 이내 모두 소진할 것으로 판단
    - 샤딩
        - 개별 테이블 뿐만 아니라 전체 데이터베이스를 분할
        - 개별 파티션은 shadd라고 함
        - 1000만명의 사용자에 대한 데이터를 호스팅하는 100개의 개별 DB 구현 가능
    - 샤딩 관련 주요 이슈
        - 연결할 DB를 결정할 때 필요한 값인 샤딩 키 선택
        - 큰 테이블은 조각으로 분할. 하나의 shadd에 개별 행이 할당
            - 더 작은 참조 테이블을 모든 샤드에 복제해야 할 수 있음
        - 기준 데이터를 수정하고 변경 사항을 모든 샤드에 전파하는 방법에 관한 전략 정의
        - 개별 샤드가 너무 커지면 더 많은 샤드 추가, 샤드 전체에 데이터 재분배
        - 스키마를 변경하는 경우 모든 스키마가 동기화되도록 모든 샤드에 변경 사항 배포 전략 필요
        - app 로직에서 둘 이상의 샤드에 저장된 데이터에 액세스해야 하는 경우, 여러 DB를 통해 쿼리하는 방법과 여러 DB에 걸쳐 트랜잭션 구현하는 방법에 대한 전략 필요
- 빅데이터
    - volume(수십억~수조), 속도(velocity), 종류(variety)
    - 하둡
        - 에코시스템
        - HDFS: 하둡 분산 파일 시스템. 수많은 서버에서 파일을 관리할 수 있도록 지원
        - 맵리듀스: 작업을 여러 서버에서 병렬로 실행할 수 있는 여러 개의 작은 조각으로 나누어 대량의 정형, 비정형 데이터를 처리
            - 맵리듀스를 사용하여 데이터를 쿼리하려면 하이브, 임팔라, 드릴 등을 포함한 여러 SQL 이터페이스 사용
        - 얀(yarn): HDFS용 리소스 관리자 및 작업 스케줄러
    - NoSQL과 문서 데이터베이스
        - 관계형 데이터 베이스
            - 숫자, 문자열, 날짜 등을 포함하는 열로 이루어진 테이블로 구성된 사전 정의된 스키마를 따라야
        - 데이터 구조를 미리 알 수 없거나, 자주 변경되는 경우
            - XML, JSON과 같은 형식을 사용해서 데이터와 스키마 정의를 문서로 결합
            - 문서를 데이터에 저장
            - 스키마 수정 없이 다양한 유형의 데이터를 동일한 DB에 저장 가능
            - 대신 문서에 저장된 데이터를 이해하는 쿼리 및 분석 도구의 부담이 커짐
        - 문서 DB
            - 간단한 키 값 메커니즘을 사용하여 데이터를 저장하는 NoSQL 데이터베이스의 서브셋
            - 예-몽고 DB 사용하면 고객 ID를 고객의 모든 데이터가 포함된 JSON 문서로 저장하는 키로 활용 가능
                - [ ]  오빠한테 보여달라고 해야지
                - 다른 사용자는 문서 내에 스키마를 읽고 저장된 데이터를 이해할 수 있음
    - 클라우드 컴퓨팅
        - 데이터센터를 AWS, 애저, 클라우드와 같은 플랫폼에 아웃소싱
            - 즉각적인 확장성 - 서비스 실행에 필요한 컴퓨팅 성능을 신속하게 향상/축소 가능
            - 서버, 스토리지, 네트워크, 소프트웨어 라이센스에 비용을 들이지 않고도 코드를 작성할 수 있으므로 선호
        - AWS의 DB 및 분석 제품
            - 관계형 DB(MySQL, PostgreSQL, MariaDB, 오라클 및 SQL 서버)
            - 인메모리 DB(ElastiCache)
            - 데이터 웨어하우징 DB(Redshift)
            - NoSQL DB(DynamoDB)
            - 문서 DB(DocumentDB)
            - 그래프 DB(Neptune)
            - 시계열 DB(TimeStream)
            - 하둡(EMR)
            - 데이터 레이크(Lake Formation)