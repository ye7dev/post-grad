# 15장 메타 데이터

- DB object(테이블, 뷰, 인덱스 등) 관련 정보 저장
- 메타 데이터의 저장 방법, 저장 위치, 접근 방법, 활용안
- 데이터에 관한 데이터
    - 데이터 딕셔너리, 시스템 카탈로그
        - 테이블 이름
        - 테이블 스토리지 정보(테이블 스페이스, 초기 크기 등)
        - 스토리지 엔진
        - 열 이름
        - 열 데이터 자료형
        - 기본 열 값
        - not null 열 제약 조건
        - 기본 키 열
        - 기본 키 이름
        - 기본 키 인덱스의 이름
        - 인덱스 이름
        - 인덱스 유형(b-tree, bitmap)
        - 인덱스 열
        - 인덱스 열 정렬 순서(오름차순, 내림차순)
        - 인덱스 스토리지 정보
        - 외래 키 이름
        - 외래 키 열
        - 외래 키 관련 테이블/열
- 정보 스키마
    - information_schema
        - mySQL에서 메타데이터를 게시하는 특수 데이터 베이스
        - 사용 가능한 모든 객체는 뷰 - 이 뷰를 쿼리해서 프로그래밍 방식으로 사용 가능
    - 예-샤키라 데이터 베이스의 **모든 테이블, 뷰** 이름을 검색
        
        ```sql
        select table_name, table_type
        from information_schema.tables /* 뷰 */
        where table_schema = 'sakila'
        order by 1;
        ```
        
        - information_schema.tables
            - 테이블과 뷰 모두 포함. 뷰를 제외하려면 where 절에 조건 추가
                
                `where table_schema = 'sakila' and TABLE_TYPE='BASE TABLE'`
                
            - 뷰만 관심 있을 경우
                
                ```sql
                select table_name, is_updatable /* table_type 칼럼은 없다 */
                from information_schema.views /* 테이블이 아니라 뷰 */
                where table_schema = 'sakila' 
                order by 1;
                ```
                
    - 예-film table에 대한 **칼럼** 정보 검색
        
        ```sql
        select column_name, data_type, character_maximum_length char_max_len, numeric_precision num_prcsn, numeric_scale num_scale
        from information_schema.columns /* 뷰 */
        where table_schema = 'sakila' and table_name = 'film'
        order by ordinal_position; /* 테이블에 추가된 순서대로 열을 검색 */
        ```
        
    - 예-rental table의 **인덱스** 정보 검색
        
        ```sql
        select index_name, non_unique, seq_in_index, column_name
        from information_schema.statistics /* 뷰 */
        where table_schema = 'sakila' and table_name = 'rental'
        order by 1, 3;
        ```
        
    - 예-스키마 내의 **제약 조건** 검색
        
        ```sql
        select constraint_name, table_name, constraint_type
        from information_schema.table_constraints /* 뷰 */
        where table_schema='sakila'
        order by 3, 1;
        ```
        
    - 정보 스키마에 있는 모든 뷰를 보고 싶으면
        
        ```sql
        SHOW TABLES FROM INFORMATION_SCHEMA;
        ```
        
        - 표 15-1 정보 스키마 뷰
            
            ![1000011492.jpg](15%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%90%E1%85%A1%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20bc296780ee9b44b9a34c0c0cf97f9dcf/1000011492.jpg)
            
- 메타 데이터로 작업하기
    - 스키마 생성 스크립트
        - 예-카테고리 테이블 생성하는 스크립트
            
            ```sql
            create table category(
            	category_id tinyint unsigned not null auto_increment,
                name varchar(25) not null,
                last_update timestamp not null default current_timestamp
            		on update current_timestamp,
            	primary key (category_id)
                ) engine=InnoDB default charset=utf8;
            ```
            
            - 위의 스크립트를 치지 않고 존재하는 정보를 검색해서 같은 설정의 테이블 만들기 (근데 이렇게 하는게 코드가 더 길다;;)
                - information_schema.columns 테이블을 쿼리해서 테이블의 칼럼에 대한 정보 검색
                    
                    ```sql
                    SELECT 'create table category (' create_table_statement 
                    UNION ALL SELECT 
                        cols.txt
                    FROM
                        (SELECT 
                            CONCAT('  ', column_name, ' ', column_type, CASE
                                    WHEN is_nullable = 'NO' THEN ' not null'
                                    ELSE ''
                                END, CASE
                                    WHEN
                                        extra IS NOT NULL
                                            AND extra LIKE 'default_generated%'
                                    THEN
                                        CONCAT(' default ', column_default, SUBSTR(extra, 18))
                                    WHEN extra IS NOT NULL THEN CONCAT(' ', extra)
                                    ELSE ''
                                END, ',') txt
                        FROM
                            information_schema.columns
                        WHERE
                            table_schema = 'sakila'
                                AND table_name = 'category'
                        ORDER BY ordinal_position) cols 
                    UNION ALL SELECT ')'
                    ```
                    
            - 기본 키 제약조건에 대한 정보를 검색
                - table_constraint, key_column_usage 뷰에 대한 쿼리 추가
                    
                    ```sql
                    SELECT 'create table category (' create_table_statement 
                    UNION ALL SELECT 
                        cols.txt
                    FROM
                        (SELECT 
                            CONCAT('  ', column_name, ' ', column_type, CASE
                                    WHEN is_nullable = 'NO' THEN ' not null'
                                    ELSE ''
                                END, CASE
                                    WHEN
                                        extra IS NOT NULL
                                            AND extra LIKE 'default_generated%'
                                    THEN
                                        CONCAT(' default ', column_default, SUBSTR(extra, 18))
                                    WHEN extra IS NOT NULL THEN CONCAT(' ', extra)
                                    ELSE ''
                                END, ',') txt
                        FROM
                            information_schema.columns
                        WHERE
                            table_schema = 'sakila'
                                AND table_name = 'category'
                        ORDER BY ordinal_position) cols 
                    UNION ALL SELECT 
                        CONCAT('   constraint primary key (')
                    FROM
                        information_schema.table_constraints
                    WHERE
                        table_schema = 'sakila'
                            AND table_name = 'category'
                            AND constraint_type = 'PRIMARY KEY' 
                    UNION ALL SELECT 
                        cols.txt
                    FROM
                        (SELECT 
                            CONCAT(CASE
                                    WHEN ordinal_position > 1 THEN '    , '
                                    ELSE '     '
                                END, column_name) txt
                        FROM
                            information_schema.key_column_usage
                        WHERE
                            table_schema = 'sakila'
                                AND table_name = 'category'
                                AND constraint_name = 'primary'
                        ORDER BY ordinal_position) cols 
                    UNION ALL SELECT '  )' 
                    UNION ALL SELECT ')'
                    ```
                    
                    - 위의 스크립트의 결과물을 가지고 table 생성 할 수 있음
                        
                        ```sql
                        create table category (
                          category_id tinyint unsigned not null auto_increment,
                          name varchar(25) not null ,
                          last_update timestamp not null default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP,
                           constraint primary key (
                             category_id
                          )
                        )
                        ```
                        
    - 배포 확인
        - 배포 전후에 검증 스크립트 실행, 두 결과셋 차이 확인
            - 새 스키마 개체가 적절한 열, 인덱스, 기본 키 등을 가지고 있는지 확인
            
            ```sql
            select tbl.table_name,
            # 열
            (select count(*) from information_schema.columns clm
            	where clm.table_schema = tbl.table_schema
            	and clm.table_name = tbl.table_name) num_columns,
            # 인덱스 
            (select count(*) from information_schema.statistics sta
            	where sta.table_schema = tbl.table_schema
                and sta.table_name = tbl.table_name) num_indexes,
            # 기본 키 
            (select count(*) from information_schema.table_constraints tc
            	where tc.table_schema = tbl.table_schema
                and tc.table_name = tbl.table_name
                and tc.constraint_type = 'PRIMARY KEY') num_primary_keys
            from information_schema.tables tbl
            # sakila 스키마에서 view가 아니라 table만 취함 
            where tbl.table_schema = 'sakila' and tbl.table_type = 'BASE TABLE'
            order by 1;
            ```
            
- 동적 SQL 생성
    - 자바와 같은 다른 언어에는 관계형 DB와의 인터페이스 기능이 포함되지만, 문법 자체에 SQL문을  포함하지는 않음
        - 자바 키워드나 문법으로 SQL 기능을 수행하는 코드를 작성할 수는 없지만, string으로 SQL을 받아서 인터페이스에 보낼 순 있고, 인터페이스는 이렇게 받은 문자열을 SQL문으로 읽어서 실행
    - 동적 SQL 실행
        - SQL 인터페이스를 사용하지 않고 DB 엔진에 문자열을 전송하는 것
        - mySQL은 동적 실행을 위한 prepare, execute, deallocate 제공
            
            ```sql
            # qry 변수에 문자열 할당 
            set @qry = 'select customer_id, first_name, last_name from customer
            ;
            
            # 준비 구문 -> 구문 분석, 보안 검사 및 최적화를 위해 DB 엔진에 제출 
            prepare dynsql1 from @qry;
            
            # 명령문 실행 
            execute dynsql1;
            
            # 구문 닫아서 DB 리소스 해제 
            deallocate prepare dynsql1;
            ```
            
        - 런타임 시 조건을 지정할 수 있도록 자리 표시자가 포함된 쿼리
            
            ```sql
            set @qry='select customer_id, first_name, last_name from customer where customer_id = ?';
            
            prepare dynsql2 from @qry;
            
            set @custid=9;
            
            execute dynsql2 **using** @custid;
            
            set @custid=145;
            
            execute dynsql2 using @custid;
            
            deallocate prepare dynsql2;
            ```
            
        - view에서 열 이름 검색
            - 왜 ordinal_position=1 조건에 max가 들어가냐?
                
                ```sql
                SELECT max(case when ordinal_position=1 then column_name else null end)
                from information_schema.columns
                where table_schema = 'sakila' and table_name= 'customer'
                group by table_name
                ```
                
                - group by table_name을 했기 때문에 max라는 집계 함수를 넣어준 듯
                    - 굳이 group by와 max를 사용한 이유는 모르겠지만
                        - 왜냐면 customer라는 이름의 table도 하나고, 거기서 ordinal_position=1인 칼럼(제일 처음으로 오는 칼럼)도 하나기 때문에…
                - 아래 쿼리랑 동일한 결과를 줄 뿐
                    
                    ```sql
                    SELECT column_name
                    FROM information_schema.columns
                    WHERE table_schema = 'sakila' AND table_name = 'customer' AND ordinal_position = 1;
                    ```
                    
            - qry 변수 생성
                
                ```sql
                select concat('select ', 
                		concat_ws(',', cols.col1, cols.col2, cols.col3, cols.col4, cols.col5, cols.col6, cols.col7, cols.col8, cols.col9),
                        ' from customer where customer_id = ?')
                into @qry
                from
                	(select
                		max(case when ordinal_position=1 then column_name else null end) col1,
                    max(Case when ordinal_position=2 then column_name else null end) col2, 
                    max(Case when ordinal_position=3 then column_name else null end) col3, 
                    max(Case when ordinal_position=4 then column_name else null end) col4, 
                    max(Case when ordinal_position=5 then column_name else null end) col5, 
                    max(Case when ordinal_position=6 then column_name else null end) col6, 
                    max(Case when ordinal_position=7 then column_name else null end) col7, 
                    max(Case when ordinal_position=8 then column_name else null end) col8, 
                    max(Case when ordinal_position=9 then column_name else null end) col9
                	from information_schema.columns
                    where table_schema = 'sakila' and table_name = 'customer'
                    group by table_name ) cols
                        
                ```
                
                - 결과 (select @qry)
                    
                    select customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update from customer where customer_id = ?
                    
            - resource 할당(prepare) → 대입 변수 설정 (set) → 대입해서 실행 (execute) → resource 놓기(deallocate)
                
                ```sql
                prepare dynsql3 from @qry;
                set @custid = 45;
                execute dynsql3 using @custid;
                deallocate prepare dynsql3;
                ```
                
- 실습
    - 1
        
        ```sql
        select distinct table_name, index_name
        from information_schema.statistics
        where table_schema = 'sakila'
        ```
        
        - select 뒤에 distinct를 붙여야 중복 row가 나오지 않는다
            - distinct 없는 상황에서 한 row는 하나의 table에 있는 index 하나를 나타냄
            - 근데 index 하나는 여러 칼럼에 대해 지정되었을 수 있음
            - 이 경우 각 컬럼마다 별도의 행이 존재하기 때문에 중복된 것처럼 보이는 행이 생김
    - 2 ❤️‍🔥
        - 목표: sakila.customer 테이블의 모든 인덱스를 만들 때 사용할 수 있는 출력을 생성하는 쿼리
        - mine(택도 없다 😅)
            
            ```sql
            set @qry= 'alter table table_name = ? add index index_name = ? (column_list=?)'
            
            prepare dynsql4 from @qry
            
            set @col_list = 'select table_name, index_name
            from information_schema.statistics
            where table_schema = 'sakila''
            
            execute dynsql4 using @col_list
            deallocate prepare dynsql4
            ```
            
        - [with 절 revisited](https://www.notion.so/Learning-SQL-6f5006f0a7ae4f3e8456a06a399a1456?pvs=21)
            - 간단 예시
                
                ```sql
                WITH cte AS (
                    SELECT column1, column2
                    FROM some_table
                    WHERE condition
                )
                SELECT *
                FROM cte
                WHERE another_condition;
                ```
                
                - 이걸 with 절 사용하지 않으면 temporary table 별도로 생성해야 해서 쿼리가 길어짐
                    
                    ```sql
                    CREATE TEMPORARY TABLE temp_table AS
                    SELECT column1, column2
                    FROM some_table
                    WHERE condition;
                    
                    SELECT *
                    FROM temp_table
                    WHERE another_condition;
                    
                    DROP TABLE temp_table;
                    ```
                    
        
        ```sql
        /* CTE */
        with idx_info as 
        	(select s1.table_name, s1.index_name, s1.column_name, s1.seq_in_index,
        		(select max(s2.seq_in_index)
                 from information_schema.statistics s2
                 where s2.table_schema = s1.table_schema
        						and s2.table_name = s1.table_name
                    and s2.index_name = s1.index_name) num_columns
        	from information_schema.statistics s1
            where s1.table_schema = 'sakila'
        		and s1.table_name = 'customer')
        		
        /* main query */
        select concat(case when seq_in_index = 1 
        				then concat('alter table ', table_name, ' add index ', index_name, ' (', column_name)
                        else concat('   , ', column_name) end,
        			  case when seq_in_index = num_columns then ');'
        				else '' end) index_creation_statement
        from idx_info
        order by index_name, seq_in_index;
        ```
        
        - CTE 부분
            - information_schema.statistics
                - 데이터베이스의 인덱스에 대한 포괄적인 정보를 제공
                    - 각 테이블의 인덱스 구성, 컬럼 순서, 고유성, 카디널리티, 정렬 순서 등의 상세 정보를 조회
            - seq_in_index 칼럼
                - 인덱스가 여러 개의 컬럼으로 구성된 경우, `seq_in_index`는 해당 컬럼이 인덱스에서 몇 번째 위치에 있는지를 표시합니다.
                
                ### 예제 설명
                
                ```sql
                SELECT table_name, index_name, column_name, seq_in_index
                FROM information_schema.statistics
                WHERE table_name = 'my_table';
                ```
                
                | table_name | index_name | column_name | seq_in_index |
                | --- | --- | --- | --- |
                | my_table | idx_example | column1 | 1 |
                | my_table | idx_example | column2 | 2 |
                
                ### 의미
                
                - `seq_in_index = 1`: 이 인덱스에서 `column1`이 첫 번째 위치에 있습니다.
                - `seq_in_index = 2`: 이 인덱스에서 `column2`가 두 번째 위치에 있습니다.
                
                이 값은 인덱스의 검색 및 정렬 순서를 결정하는 데 중요한 역할을 합니다. 인덱스가 여러 컬럼으로 구성된 경우, `seq_in_index`의 값이 작은 컬럼부터 먼저 사용됩니다.
                
                따라서, `seq_in_index`는 인덱스의 구조를 이해하고 성능 최적화를 위해 중요한 정보를 제공합니다.
                
            - CTE에서 왜 굳이 같은 테이블에 상관 서브쿼리를 만드는가
                
                ![Untitled](15%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%90%E1%85%A1%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20bc296780ee9b44b9a34c0c0cf97f9dcf/Untitled.png)
                
                - 마지막 num_columns 칼럼 보면 각 칼럼이 속한 인덱스의 최대 칼럼 수가 같이 나와 있음. 이건 취합 정보라서 단순 열 추가로는 얻기 어려운 정보
        - main query
            - 큰 틀은 CTE에서 각 행에 대해 index_creation_statement를 만드는 것
                
                ![Untitled](15%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%90%E1%85%A1%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20bc296780ee9b44b9a34c0c0cf97f9dcf/Untitled%201.png)
                
            - 조건문 분기
                - 한 인덱스에 한 칼럼만 들어 있거나, 여러 칼럼이 들어 있는 인덱스의 첫번째 칼럼인 경우 (seq_in_index = 1)
                    - `alter table 테이블 이름 add index 인덱스 이름 (인덱스에 넣을 칼럼 하나`
                    - 왼쪽 괄호는 안 넣음
                - 여러 칼럼이 한 인덱스를 만들 때, 이 중 중간 칼럼의 경우
                    - 중간에 오는 칼럼은 `, 칼럼 이름` 만 생성
                - 한 인덱스에 한 칼럼만 들어 있거나, 여러 칼럼이 들어 있는 인덱스의 마지막 칼럼인 경우 (seq_in_index = num_columns)
                    - 맨 위에서 안 넣었던 `)` 오른쪽 괄호 넣어줌
            - 위의 예시에서 보면 index `idx_full_name` 의 경우 두 개의 칼럼이 하나의 인덱스를 구성
                - 이 중 두번째 칼럼인 first_name은 다음 줄에 와있지만, 앞의 statement에 이어지는 내용이라 `,` 로 시작. 마지막 칼럼이라 `)` 도 들어가 있음