# 13장 인덱스와 제약 조건

### 인덱스

- 역할
    - 테이블 스캔
        - 쿼리에 응답하기 위해 테이블의 모든 행을 검사
            - 행이 3백만 개 정도로 엄청 많으면 시간이 너무 오래 걸린다
    - 인덱스를 사용하여 테이블에서 행 찾기
        - 특정 순서로 유지되는 특수 테이블
        - 모든 데이터가 아니라, 행이 실제로 존재하는 위치에 대한 정보와 함께 데이터 테이블에서 필요한 열만 포함
        - 모든 행을 확인할 필요 없이 테이블의 행과 열의 서브셋을 쉽게 검색하게 해줌
- 인덱스 생성 (+제거)
    - 이미 만들어진 테이블에 인덱스 생성
        
        ```sql
        alter table customer
        add index idx_email (email);
        ```
        
    - email 열의 값을 사용하는 쿼리나 update, delete 연산 처리 속도 향상
    - 특정 테이블의 모든 인덱스 확인하기
        
        ```sql
        show index from customer;
        ```
        
    - 테이블 생성 시에 인덱스도 같이 생성
        
        ```sql
        create table customer (
        	...,
        	primary key (customer_id),
        	key idx_fk_store_id (store_id),
        	key idx_fk_address_id (address_id),
        	key idx_last_name (last_name),
        	...)
        ```
        
        - 기본 키 열 (customer_id)에 인덱스를 자동으로 생성하고, primary라는 이름을 부여
    - 인덱스 제거
        
        ```sql
        alter table customer
        drop index idx_email;
        ```
        
- 인덱스 종류 (고유, 다중 열)
    - 고유 인덱스 (unique index)
        
        ```sql
        alter table customer
        add unique idx_email (email);
        ```
        
        - 일반 인덱스 + 특정 칼럼에 대해 중복 값을 허용하지 않는 제약 적용
        - 행이 삽입되거나 인덱스 칼럼이 수정될 때마다, DB가 고유 인덱스 확인하여 테이블의 다른 행에 값이 이미 있는지 확인
        - 이 인덱스가 추가된 열에 이미 존재하는 값을 추가하면 다음의 에러 발생
            - Error Code: 1136. Column count doesn't match value count at row 1
        - primary key는 이미 고유성 확인 대상인 칼럼이라 이 칼럼에 고유 인덱스 생성하면 안됨
    - 다중 열 인덱스
        
        ```sql
        alter table customer
        add index idx_full_name (last_name, first_name);
        ```
        
        - 하나의 칼럼이 아니라 여러 개에 대해 하나의 인덱스 생성 가능
    
- 인덱스 유형
    - B-트리 인덱스
        - balanced-tree index
        - branch node: 트리 탐색에 사용
        - leaf node: 실제 값과 위치 정보를 가짐
        - 행의 삽입, 업데이트, 삭제에 따라 루트 노드 한 쪽에 있는 가지/잎 노드가 다른 쪽보다 훨씬 많아 지지 않도록 트리의 균형을 유지하려 함
    - 비트맵 인덱스
        - B-tree 인덱스는 다양한 값이 포함된 열을 처리하는 데 좋지만, 반대로 cardinality가 작은 칼럼에 대해서는 통제하기 어려울 수 있음
            - 예- binary 값만 존재하는 경우. 0과 1 중 어느 한 쪽의 값으로 치우치면 균형 잡힌 B-tree 유지하기 어려움
            - 영업 분기(1~4), 지리적 지역(8도), 제품, 영업 사원 등에 인덱스 생성
        - 오라클 DB에서는 bitmap 인덱스 사용 가능
            - 열에 저장된 각 값에 대한 비트맵 생성
    - 텍스트 인덱스
        - 문서에 대한 특수 인덱싱과 검색 메커니즘
- 인덱스 사용 방법
    - 특정 테이블에서 행을 빨리 찾기 위해 사용
    - 예
        
        ```sql
        select customer_id, first_name, last_name
        from customer
        where first_name like 'S%' and last_name like 'P%';
        ```
        
        - 서버가 선택 가능한 전략
            - customer 테이블의 모든 행 스캔
            - last_name 칼럼의 인덱스를 사용해서 성이 P로 시작하는 모든 고객 탐색 + customer 테이블의 각 행을 읽어서 이름이 S로 시작하는 행만 탐색
            - last_name과 first_name 열의 인덱스를 사용해서 성이 P로 시작하고 이름이 S로 시작하는 모든 고객 찾기
    - 쿼리 옵티마이저의 쿼리 실행 계획을 확인하는 방법
        - 쿼리 앞에 explain을 붙인다
        - 위의 쿼리에 붙이면 다음의 결과 나옴
            
            
            | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |
            | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
            | 1 | SIMPLE | customer | NULL | range | idx_last_name,idx_full_name | idx_full_name | 364 | NULL | 28 | 11.11 | Using where; Using index |
            - possible keys: 서버가 사용할 수 있는 인덱스를 보여줌
            - key: 실제 실행에 선택된 인덱스
                - 하나의 행을 검색하는 대신 인덱스에서 값의 범위를 탐색
            - type: 범위 스캔이 사용될 것
        
        c.f. 쿼리 튜닝
        
        - SQL 문 수정, DB 리소스 조정 등
- 인덱스 단점
    - 테이블에서 행을 추가/삭제할 때마다 해당 테이블의 모든 인덱스를 수정해야
    - 행이 update 되면 영향을 받는 열의 인덱스도 수정해야
    - 인덱스가 많을 수록 서버가 모든 스키마를 최신 상태로 유지하기 위해 더 많은 작업을 수행해야 해서 속도가 느려짐
    - 보통은 그 때 그 때 특정 목적으로 인덱스 생성한 뒤, 루틴 실행이나 보고서 작성 한 후에 인덱스 삭제하는 게 관행
    - 필요한 인덱스의 결정하는 rule of thumb
        - 기본 키 열에 인덱스가 만들어져 있는 지 확인
            - 다중열 기본키 경우에는 기본 키 열의 서브셋, 모든 기본 키 열에 대해 기본 키 제약 조건 정의와 다른 순서로 추가 인덱스 생성 고려
        - 외래 키 제약 조건에서 참조되는 모든 열에 대해 인덱스 작성
            - 서버는 부모(외래 키가 존재하는 원래 테이블) 행이 삭제 될 때 자식(외래 키를 참조하는 테이블) 행이 없는지 확인
            - 열에 인덱스가 없다면 전체 테이블을 스캔 해야
        - 데이터 검색에 자주 사용되는 열을 인덱싱
            - 대부분의 날짜 열은 2~50자의 짧은 문자열 열과 함께 인덱스로 사용하기 좋은 후보

### 제약조건

- 개념
    - 제약: 테이블의 하나 이상의 열에 적용되는 제한 사항
    - 유형
        - 기본 키: 테이블 내에서 고유성을 보장하는 열을 식별
            - 고유 키 제약 조건의 하위 집합인데 테이블 내에서 하나만 존재할 수 있고, null 값을 불허한다는 차이가 있음
        - 외래 키: 다른 테이블의 기본 키 열에 있는 값만 포함하도록 하나 이상의 열을 제한
        - 고유 키: 테이블 내에서 고유한 값을 포함하도록 하나 이상의 열을 제한
        - 체크 제약조건:열에 허용되는 값을 제한
    - 기능
        - DB 일관성
        - 예- 기본 키와 외래 키 제약 조건이 없으면
            - 서버가 rental tbl에서 동일한 고객 id를 변경하지 않고 customer tbl에서만 고객 id를 변경하는 일을 허용
            - rental tbl에 고아 행(parent table에 상응하는 행이 없음) 발생
        
        c.f. mySQL에서 외래 키 제약조건 사용하려면 테이블을 inno DB 스토리지 엔진으로 사용해야 
        
- 제약조건 생성
    - 보통 create table로 테이블과 동시에 생성
        
        ```sql
        create table customer (...
        	primary key (customer_id), 
        	...
        	constraint fk_customer_address foreign key (address_id)
        		references address (address_id) on delete restrict on update cascade,
        	constraint fk_customer_store foreign key (store_id)
        		references store (store_id) on delete restrict on update cascade 
        		)engine=InnoDB default charset=utf8;
        ```
        
    - 테이블 생성 이후에 추가하기
        
        ```sql
        alter table customer 
        add constraint fk_customer_address foreign key (address_id)
        references address (address_id) on delete restrict on update cascade,
        ```
        
        - `on delete restrict`
            - 자식 table(customer)에서 참조되는 부모 table(address)에서 행을 삭제하면 서버에서 오류 발생
            - 부모 테이블에서 행이 삭제되어 고아 행이 발생하는 것을 방지
        - `on update cascade`
            - 서버가 부모 테이블(address)의 기본 키 값에 대한 변경 사항을 자식 테이블(customer)로 전파
            - 부모 테이블에서 기본 키 값이 수정될 때 고아 행이 발생하는 것을 방지
    - 외래 키 제약조건 정의할 때 선택할 수 있는 옵션
        - on delete restrict
        - on delete cascade
        - on delete set null
        - on update restrict
        - on update cascade
        - on update set null
- 실습
    - 1
        
        ```sql
        alter table rental
        add constraint fk_rental_customer_id foreign key (customer_id)
        references customer (customer_id) on delete restrict;
        ```
        
    - 2
        
        ```sql
        alter table payment
        add index multi_col_idx (payment_date, amount); 
        ```