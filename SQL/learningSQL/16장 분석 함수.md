# 16장 분석 함수

- reporting(집계) 함수 vs. analytic 함수 vs. window 함수
    1. **리포팅 함수(집계 함수)**:
        - 데이터를 그룹화하여 각 그룹에 대해 단일 결과를 반환.
        - GROUP BY 절과 함께 사용.
        - 예: SUM(), COUNT(), AVG()
    2. **분석 함수(애널리틱 함수)**:
        - 각 행에 대해 집계 결과를 제공.
        - OVER() 절과 함께 사용.
        - 예: SUM() OVER(), AVG() OVER(), RANK() OVER()
    3. **윈도우 함수**:
        - 분석 함수의 일종으로, 데이터의 특정 범위 내에서 계산을 수행.
        - PARTITION BY와 ORDER BY를 포함하는 OVER() 절을 사용하여 윈도우를 정의.
        - 예: RANK(), ROW_NUMBER(), LAG(), LEAD()
- 분석 함수의 개념 (데이터 윈도우)
    - DB 서버가 조인, 필터링, 그룹화, 정렬을 끝내고 결과셋이 완성되어서 반환되기 직전
        - 쿼리 실행을 일시 중지하고 메모리에 저장된 결과 살펴보기
        - 예-영업 사원 실적 순위,  지역 판매액별 순위, 동기간대 전년 대비 백분율 차이, 각 보고서의 섹션별 소계, 최종 섹션의 총계 등
    
    ### 데이터 윈도우
    
    - 일정 기간 동안의 월별 판매 총계 생성
        - 예-2005년 5~8월까지의 영화 대여에 관한 월별 지불액 요약
            
            ```sql
            select quarter(payment_date) quarter,
            	monthname(payment_date) month_nm,
                sum(amount) monthly_sales
            from payment
            where year(payment_date) = 2005
            group by quarter(payment_date), monthname(payment_date);
            ```
            
            - 결과
                
                ![Untitled](16%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20dd200389011e4e70a9f62b9cc40e318a/Untitled.png)
                
                - 총 4개월 전체로 보면 7월의 월간 합계가 가장 높고, 2분기 내로 보면 6월이 가장높은 월간 합계 보임
    - 분기당 최댓값 및 전체 기간에 대한 최댓값을 표시하는 열을 각 행에 추가하기
        
        ```sql
        select quarter(payment_date) quarter,
        	monthname(payment_date) month_nm,
            sum(amount) monthly_sales, # group by 
        	  # over 뒤에 빈 괄호라서 전체 행에 대해 적용 
            max(sum(amount))
        		over () max_overall_sales, 
        		# over 뒤에 partition 기준 제시 - 각 조각(쿼터) 당 한번의 윈도우 함수 적용 
        		max(sum(amount))
        		over (partition by quarter(payment_date)) max_qrtr_sales
        from payment 
        where year(payment_date) = 2005
        # 그룹화가 끝나면 각 행은 분기별, 월별 데이터가 되어 있음 
        group by quarter(payment_date), monthname(payment_date)   
        ```
        
        - **전체 행을** 두 개의 집합으로 그룹화
            - 그룹1: 같은 분기의 모든 행 포함
                - partition by. 윈도우 함수가 한번에 적용되는 범위를 쪼개는 기준. group by와 다르게 원본 행 수가 줄어들지 않음
            - 그룹2: 전체 모든 행 포함
    - 윈도우 함수(Window Function)
        - 테이블의 행을 그룹으로 나누어 각 그룹 내에서 특정 연산을 수행하는 기능을 제공
        - 일반적으로 OVER 절과 함께 사용되며, 그룹화된 데이터 내에서 순위, 합계, 평균 등의 연산을 수행
            - `window_function()` `OVER` (`PARTITION BY` column_name ) AS `window_column`
        - [ ]  추가 내용
            - (확실) partition by는 select 절 단계에서 실행된다
            - (확실) select 절은 group by 절이 실행된 다음에 실행된다
            - (불확실) partition by는 group by 로 그룹화되기 이전의 전체 행에 대해 실행된다
                - ?
    
    ### 로컬 정렬
    
    - 예-판매량이 가장 높은 달에 값 1이 주어지는 각 월의 순위 번호(rank)를 정의
        
        ```sql
        select quarter(payment_date) quarter,
        			 monthname(payment_date) month_nm,
        	     sum(amount) monthly_sales,
        	     rank() over (order by sum(amount) desc) sales_rank
        from payment
        where year(payment_date) = 2005
        group by quarter(payment_date), monthname(payment_date), month(payment_date)
        order by 1, month(payment_date);
        ```
        
        - 다중 order by
            1. 쿼리 끝에서 결과셋 정렬 (order by 1, month(payment_date))
            2. 순위 함수를 사용하여 순위를 할당 (rank() over (order by sum(amount) desc) sales_rank)
        - `rank() over (order by sum(amount) desc) sales_rank`
            1. 그룹화 
                1. 데이터 변환: 각 행에 대해 분기와 월이 계산됨 
                2. 분기, 월 가능한 모든 조합에 대해 그룹이 생성  
                3. 집계 함수 실행 - 각 그룹에 대해 sum amount 
            2. 정렬 
                1. 분기-월 그룹별 합계 값을 기준으로 내림차순 정렬 
            3. 순위 부여
                1. 합계 값을 기준으로 동일한 값에 대해 동일한 순위 부여 
                    - 동일한 순위가 부여된 후에는 다음 순위가 건너뛰어 매겨짐
    - rank 함수에 paritition by, order by 하위절이 모두 사용되는 경우 ❤️‍🔥
        - 전체 결과셋에서 단일 순위 대신 분기별 순위를 제공하도록
            
            ```sql
            select quarter(payment_date) quarter,
            	monthname(payment_date) month_nm,
                sum(amount) monthly_sales,
                rank() over (partition by quarter(payment_date)
            				 order by sum(amount) desc) qtr_sales_rank
            from payment
            where year(payment_date) = 2005
            group by quarter(payment_date), monthname(payment_date), month(payment_date)
            order by 1, month(payment_date);
            ```
            
            1. 그룹화
                1. 데이터 변환: 각 행에 대해 분기, 월 구한다
                2. 그룹화: 같은 분기-월 조합에 대해 그룹으로 묶는다  
            2. 파티셔닝
                - quarter 값에 따라 행을 여러 그룹으로 나눈다
                - 이후의 동작은 매 그룹마다 실행됨
            3. 집계 함수 실행
                - 하나의 그룹 안의 각 행에 대해 sum(amount) 실행
                - 그룹화 지나면 같은 분기 안에서는 월별로 데이터가 그룹화된 상태
                - 서로 다른 날짜라도 같은 월이면 하나로 집계됨
                - 월별 sum()을 구한다
                - 헷갈리지만 그냥 하나의 분기 안에서 sum(amount) 한다고 생각하면 됨
            4. 정렬
                - 하나의 그룹(분기) 안에서 월별 합계 수치를 기준으로 내림차순 정렬
    
- 순위 ❤️‍🔥
    - 순위 함수
        - `row_number` : 동점일 경우 순위가 임의 지정. 각 행마다 고유 번호
            - 동점이라도 rank가 같은 행 없음
        - `rank` : 동점일 경우 순위에 차이가 있는 동일한 순위를 반환
            - 동점인 행 수를 더해서 다음 순위가 정해짐. 3등이 2명이면 다음 등수는 5
        - `dense_rank` : 동점일 경우 순위에 차이가 없는 동일한 순위 반환
            - 동점은 동점대로 같은 순위 주고, 이어서 다음 등수. 3등이 몇 명이든 다음 등수는 4
    - 예-상위10명의 고객 파악
        
        ```sql
        select customer_id, count(*) num_rentals,
        	row_number() over (order by count(*) desc) row_number_rank,
            rank() over (order by count(*) desc) Rank_rank,
            dense_rank() over (order by count(*) desc) dense_rank_rank
        from rental
        group by customer_id
        order by 2 desc;
        ```
        
        ![Untitled](16%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20dd200389011e4e70a9f62b9cc40e318a/Untitled%201.png)
        
        - row_number(): 정확히 10명을 가져다주지만, 점수로 봤을 때 10위 고객과 동일한 대여 횟수가 있는 11위+a 고객이 10명에 들지 못해 제외된다는 단점
        - rank(): 점수도 공정하고, 정확히 10명을 가져올 수 있음
            - 중간에 있는 동점자는 다음 순위에서 다 count가 됨
            - 마지막 등수는 10이 아니지만 11위 바로 앞에서 끊으면 10명이 채워짐
                
                ![Untitled](16%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20dd200389011e4e70a9f62b9cc40e318a/Untitled%202.png)
                
            - 대부분의 경우 best
            - 근데 얘를 들어 1 1 1 1 1 5 5 5에서 5위까지 끊는다고 하면 8명이 들어가긴 함
        - dense_rank(): 점수로 상위 10위를 끊을 수 있지만, 사람 수는 10명이 훨씬 넘는다
    - 다양한 순위 생성
        - 동일한 결과셋에서 여러 순위 집합 생성
            - 예-매월 상위 5명의 고객을 찾기
                
                ```sql
                select customer_id, rental_month, num_rentals, rank_rnk ranking
                from (select customer_id, 
                				monthname(rental_date) rental_month,
                        count(*) num_rentals,
                        rank() over (partition by monthname(rental_date) order by count(*) desc) rank_rnk
                			from rental
                	    group by customer_id, monthname(rental_date)
                	    ) cust_rankings
                where rank_rnk <= 5
                order by rental_month, num_rentals desc, rank_rnk;
                ```
                
                - 분석 함수는 select 절에서만 사용할 수 있으므로, 쿼리 중첩하는 경우가 종종 있음
                1. from 절부터 해서 cust_rankings 불러 온다고 하면 
                    1. rental 테이블 들고 오기
                    2. 아이디랑 달 이름으로 그룹화 - 고객별 월별 이용합계 금액 나옴 ❤️‍🔥
                        - group by만 한 상태
                            
                            ![Untitled](16%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20dd200389011e4e70a9f62b9cc40e318a/Untitled%203.png)
                            
                            - 월별 이용 기록이 있는 customer_id랑 rental_month가 나와있음
                                - 같은 조합이 여러 개 행으로 존재하지만, 그룹의 대표값(unique 조합)으로 aggregate
                        - count(*) 집계함수 추가한 상태
                            
                            ![Untitled](16%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20dd200389011e4e70a9f62b9cc40e318a/Untitled%204.png)
                            
                            - 전체 테이블에서 하나의 조합에 대해 몇 개의 행이 존재하는지 count
                                - 하나의 조합을 갖는 행이 여러 번 등장한 것을 하나의 숫자로 aggregate
                        - 헷갈렸던 부분
                            
                            **1. 데이터 그룹화**
                            
                            GROUP BY 절이 실행되면, 데이터베이스 엔진은 지정된 열을 기준으로 데이터를 그룹화합니다. 각 그룹은 해당 그룹의 키(예: customer_id와 monthname(rental_date) 조합)를 기준으로 식별됩니다.
                            
                            **2. 임시 저장소**
                            
                            각 그룹 내의 행들은 데이터베이스 엔진의 메모리나 디스크 기반의 임시 테이블에 저장됩니다. 이 임시 저장소는 각 그룹 내의 모든 행을 포함하며, 나중에 집계 함수가 이 데이터를 기반으로 계산을 수행합니다.
                            
                            **3. 집계 함수 계산**
                            
                            집계 함수는 각 그룹 내의 행들을 순회하면서 계산을 수행합니다. 예를 들어, count(*) 함수는 각 그룹 내의 행 수를 셉니다. 다른 집계 함수(예: SUM(), AVG(), MAX(), MIN())도 각 그룹 내의 데이터를 기반으로 계산을 수행합니다.
                            
                    3. 그룹화 기준이었던 칼럼 그대로 select로 들고 오고 
                    4. 윈도우 함수 시작 
                        1. 달 이름으로 partitioning
                        2. 하나의 달 안에서 id-월 이름 조합이 몇 개씩 나왔는지 count
                            
                            =  특정 고객의 월별 이용횟수가 나옴 
                            
                        3. b 값을 기준으로 내림차순 정렬 
                        4. c 값을 기준으로순위 부여 
                2. where 절 실행 
                    - cust_rankings의 rank_rnk 칼럼 값이 5보다 큰 행 제외
                3. select 절에 있는 칼럼 들고 오기
                4. order by 여러 개 기준 순차적으로 정렬
                    1. rental_month를 기준으로 오름차순 정렬
                    2. 동일한 rental_month 내에서 num_rentals를 기준으로 내림차순 정렬
                    3. num_rentals가 동일한 경우, rank_rnk를 기준으로 오름차순 정렬합니다.
                    
- 리포팅 함수 ❤️‍🔥
    - 예-지불 금액이 10달러 이상인 모든 행에 대해 월별 및 전체 총계를 생성
        
        ```sql
        select monthname(payment_date) payment_month,
        	amount, 
        	sum(amount) over (partition by monthname(payment_date)) monthly_total,
        	sum(amount) over () grand_total
        from payment
        where amount >= 10
        order by 1;
        ```
        
        1. payment table 들고 온다
        2. where 절에서 amount 칼럼 값이 10보다 작은 행들 제외 
        3. select 에 언급된 칼럼 들고 온다
            1. payment_date → month로 데이터 변환
            2. amount 금액 그대로
            3. 윈도우 함수 실행 
                1. 월별로 파티셔닝 
                2. 각 월에 속한 모든 행의 amount 칼럼 수치 합계 
                
                = 특정 지불 날짜에 대해, 그 날짜가 속한 달의 총 지불 금액을 옆에 같이 보여줌 
                
            4. 윈도우 함수 실행
                1. 모든 행에 대해 amount 칼럼 전체 합계 금액 표시 
                
                = 월간 지불 금액 칼럼 옆에 전체 지불 금액 칼럼 보여줌 
                
        4. payment_month 칼럼 기준으로 정렬 
            
            
        
    - 예-전체 지불 금액 중 월간 총 지불 금액의 share 계산  ❤️‍🔥
        
        ```sql
        select monthname(payment_date) payment_month, 
        	sum(amount) month_total,
            round(sum(amount) / sum(sum(amount)) over () * 100, 2) month_share
        from payment
        group by monthname(payment_date)
        ```
        
        - ROUND() 함수가 포함된 라인 계산 과정
            1. **SUM(amount)**:
            - 이 함수는 각 payment_month에 대한 amount 값의 합계를 계산합니다.
            - 예를 들어, payment_month가 ‘January’인 경우, 해당 월의 모든 amount 값을 더합니다.
            1. **SUM(SUM(amount)) OVER ()**:
            - 이 함수는 전체 데이터셋에 대해 amount 값의 합계를 계산합니다.
            - SUM(amount)는 GROUP BY 절에 따라 각 월별 합계로 계산된 후, SUM(SUM(amount)) OVER ()는 이 월별 합계를 다시 합산하여 전체 합계를 계산합니다.
            - 예를 들어, 각 월의 SUM(amount) 값이 계산된 후, 이 값들을 다시 모두 합산합니다.
            
    - 예-월 총계가 최대, 최소 또는 중간에 있는지 여부 판별
        
        ```sql
        select monthname(payment_date) payment_month,
        sum(amount) month_total,
        case sum(amount)
        	when max(sum(amount)) over () then 'Highest'
            when min(sum(amount)) over () then 'Lowest'
            else 'Middle'
            end
        amount_level # quasi-ranking
        from payment
        group by monthname(payment_date) # 비교 용도 
        ```
        
    - 윈도우 프레임
        - 분석함수에 대한 데이터 윈도우는 partition by 절을 사용하여 정의 → 공통 값 별로 행을 그룹화
        - 데이터 윈도우에 포함할 행을 더 세밀하게 제어하려면?
            - 예-연초부터 현재 행까지 누적 합계 생성 → 데이터 윈도우에 포함할 행을 정의하기 위해 frame 하위절 포함
        - 예-매주 지불액을 합산하고 롤링 합계를 계산하는 리포팅 함수를 포함하는 쿼리 ❤️‍🔥
            
            ```sql
            select yearweek(payment_date) as payment_week, sum(amount) as week_sum, 
            		sum(sum(amount)) 
            				over (order by yearweek(payment_date) 
            								rows unbounded preceding) rolling_sum
            from payment
            group by yearweek(payment_date)
            ```
            
        - 예-매주 지불액을 합산하고 3주치 롤링 평균을 계산
            
            ```sql
            select yearweek(payment_date) as payment_week, sum(amount) as week_sum, 
            		avg(sum(amount)) 
            			over (order by yearweek(payment_date) 
            					rows between 1 preceding and 1 following) rolling_3wk_avg
            from payment
            group by yearweek(payment_date)
            ```
            
            - 전주, 금주, 다음주 세 주의 평균을 구하기
                - 첫주는 전주가 없으므로 제외, 마지막 주는 다음주가 없으므로 제외
        - 예-전 3일 + 금일 + 후 3일 = 총 7일에 대한 롤링 평균 구하기 ❤️‍🔥
            - 주간 데이터 공백이 있는 경우 - payment table에는 2005년 23주에 대한 데이터가 없음
                - 날짜 간격을 지정하는 게 더 정교하다
            
            ```sql
            select date(payment_date), sum(amount),
            avg(sum(amount)) 
            over 
            (order by date(payment_date)
            range between interval 3 day preceding and interval 3 day following) 7_day_avg
            from payment
            where payment_date between '2005-07-01' and '2005-09-01'
            group by date(payment_date)
            order by 1;
            ```
            
            1. payment table 가져온다 (from)
            2. 날짜로 행 필터링 (where)
            3. 날짜 string → date type으로 데이터 변환 및 그룹화 (group by)
            4. 그룹화 기준, 집계(일별 합산 금액) 칼럼 가져온 뒤 윈도우 함수 실행 
                1. 날짜 기준으로 정렬 (order by date)
                2. range 설정 → 정렬된 각 행의 payment_date에 앞뒤 3일 붙여서 총 7일 
                3. 집계 함수 실행: 날짜별 amount sum을 구한다 
                4. 분석 함수 실행: 해당 범위(7일)의 평균을 구한다 
        - ++ rank 함수가 아닌데 왜 over 뒤에 order by가 필요?
            - 계산 순서가 중요한 경우 - 예: 누적 합. 날짜가 섞이면 안된다. 위에서부터 차곡차곡
                
                ```sql
                SELECT 
                    payment_date, 
                    amount, 
                    SUM(amount) OVER (ORDER BY payment_date) AS cumulative_sum
                FROM 
                    payments;
                ```
                
            - 특정 범위에 있어서도 날짜별로 정렬이 먼저 되어야 앞뒤로 몇 일씩 가져온다가 말이 됨
                - 뒤죽박죽이면 현재 행 앞뒤로 가져와도 날짜 상으로는 원하는 범위가 아닐 수 있음
    - lag() 함수와 lead() 함수
        - 한 행의 값을 다른 행과 비교
            - 예- 월별 판매 총계 생성시 이전달과의 백분율 차이 표시
                - 이전 행에서 월별 판매 총계를 검색하는 방법 필요
        - lag 함수: 결과셋의 이전 행에서 열 값을 검색
        - lead 함수: 결과셋의 다음 행에서 열 값을 검색
        - 예-직전 주, 바로 다음 주와의 주간 합계 금액 나란히 표시하기
            
            ```sql
            select yearweek(payment_date) payment_week,
            		sum(amount) week_total,
            		lag(sum(amount), 1) over (order by yearweek(payment_date)) prev_wk_tot,
                lead(sum(amount), 1) over (order by yearweek(payment_date)) next_wk_tot
            from payment
            group by yearweek(payment_date)
            order by 1;
            ```
            
            1. (from) payment table 들고 온다
            2. (group by) payment_date 칼럼의 값들을 yearweek로 변환한 뒤, 같은 대표값끼리 그룹화한다 
            3. (select)
                1. 그룹화 기준 칼럼 들고 온다
                2. 그룹별 집계 함수 (aggregation) 적용한 칼럼 들고 온다
                3. 윈도우 함수 실행 
                    1. lag
                        1. over 뒤에 있는 구문 실행 : yearweek 기준으로 정렬
                            - 여기서도 정렬 먼저 하는게 중요하다. 그래야 offset 적용했을 때 원하는 대로 전주의 데이터를 얻을 수 있기 때문
                            - select는 order by보다 먼저 실행되기 때문에 데이터가 아직 정렬이 안되어 있는 상태일수도. 거기서 offset 적용하면 왠 쌩뚱 맞은 행을 들고 올 수도
                        2. offset 체크: 현재 행(어떤 yearweek) 기준으로 1만큼 이전 행 = 바로 전 yearweek
                        3. 가져올 값 체크: 이전 행의 sum(amount), 즉 이전 yearweek 그룹의 합계 금액을 들고 온다 
                    2. lead
                        - lag랑 비슷하지만 이전행이 아니라 다음 행인 차이가 있다
            4. (order by) yearweek 칼럼 값 기준으로 정렬 
        - 예-전주와의 백분율 차이 생성 ❤️‍🔥
            - 전주와의 차를 구한 뒤, 그 차이가 전주 수치 대비 얼마나 되는지
            
            ```sql
            select yearweek(payment_date) payment_week,
            				sum(amount) week_total,
                    round((sum(amount)-lag(sum(amount), 1) over (order by yearweek(payment_date)))/ lag(sum(amount), 1) over (order by yearweek(payment_date)) * 100, 1) pct_diff
            from payment
            group by yearweek(payment_date)
            order by 1;
            
            ```
            
            - 계산 시에 사칙연산 우선순위 고려해서 괄호를 적절하게 넣어줘야 하는 점 주의
    - group_concat() 함수
        - 열 값 집합을 하나의 구분된 문자열로 피벗하는 데 사용
            - XML, JSON 문서를 생성하기 위해 결과셋을 변별하는 편리한 방법
        - 예-영화 제목별로 그룹화하고 정확히 세 명의 배우가 나오는 영화만 포함
            
            ```sql
            select f.title,
            	group_concat(a.last_name order by a.last_name separator ', ') actors
            from actor a 
            	inner join film_actor fa
                on a.actor_id = fa.actor_id
                inner join film f
                on fa.film_id = f.film_id
            group by f.title
            having count(*)=3;
            ```
            
            1. from ➜ actor table 가져온다 
            2. join 
                
                ➜ actor_id 기준으로 film_actor table과 조인한다 
                
                ➜ film_id 기준으로 film table과 조인한다 
                
                ⇒ actor 칼럼들 | film_actor 칼럼들 | film 칼럼들 
                
            3. group by ➜ 영화 제목 기준으로 그룹화한다 
                - 영화 제목 기준으로 여러 배우 행이 하나의 그룹에 속하게 될 것
            4. having ➜ 집계 함수 count 실행 → 그룹별 행 수로 aggregate → 이 수가 3 넘는 그룹 필터링 
                - 배우가 딱 세 명만 출연한 영화만 남을 것
            5. select 
                1. 그룹화 기준 칼럼 가져오기 
                2. group_concat() 실행 
                    - 영화 제목 기준으로 여러 배우들이 그룹화 된 상태
                        - 한 그룹 당 세 행만 존재
                    1. 하나의 그룹 안에서 영화 배우 성 기준으로 정렬
                    2. 세 배우의 last name을 구분자를 가지고 결합 
                    
                    → 한 그룹은 하나의 행으로 표현됨 
                    
            
- 실습
    - 1
        - [x]  모든 행을 검색하는 쿼리
            - partition이 없다는 뜻인 듯
            - 아님 모든 row가 unique 그룹을 형성하게끔 그룹화 기준을 칼럼 조합으로 만들라는 뜻이거나
            
            ```sql
            select year(year_no), month(month_no), tot_sales, 
            				row_number() over (order by tot_sales)
            from Sales_Fact
            group by year(year_no), month(month_no)
            ```
            
        - 모범답안
            - 모든 행을 검색하는 쿼리 = group by 애초에 할 필요가 없다는 뜻이었음.
            
            ```sql
            select year_no, month_no, tot_sales, 
            				rank() over (order by tot_sales desc)
            from Sales_Fact
            ```
            
    - 2
        - [x]  두 순위 집합
            - 연 별로 1~12를 각각 만들라는 뜻인듯
                
                ```sql
                select year(year_no), month(month_no), tot_sales, 
                				row_number() over (partition by year(year_no) order by tot_sales)
                from Sales_Fact
                group by year(year_no), month(month_no)
                ```
                
        - 모범답안
            
            ```sql
            select year_no, month_no, tot_sales, 
            				rank() over (partition by year_no order by tot_sales desc) sales_rank
            from Sales_Fact
            ```
            
    - 3
        - 내 답안
            
            ```sql
            select year(year_no), month(month_no), tot_sales as this_month, 
            			lag(tot_sales, -1) over (order by month(month_no)) as last_month
            from Sales_Fact
            where year(year_no) = 2020
            group by month(month_no)
            ```
            
        - 모범답안
            
            ```sql
            select year_no, month_no, tot_sales as this_month, 
            			lag(tot_sales) over (order by month(month_no)) as last_month
            from Sales_Fact
            where year(year_no) = 2020
            ```
            
            - 이미 연,월은 알맞은 포맷이라 수정할 필요 없음
            - lag, lead 함수 offset 기본값은 1
                - lag 함수에서는 이전 행에 대한 offset이더라도 양수 쓰면 된다
                - offset으로 음수는 안된다고 함