# 7장 데이터 생성, 조작과 변환

- 문자열 데이터 처리
    - CHAR
        - 지정한 크기보다 문자열이 작으면 나머지 공간을 공백으로 채워주는 고정 길이 문자열 자료형
        - 최대 255자
    - varchar
        - 가변 길이 문자열 자료형 - 최대 65,535자 허용
    - text
        - 매우 큰 가변 길이 문자열 (문서) 저장
        - 최대 4GB 크기의 문서를 저장하는 다양한 text 자료형 있음
            - tinytext, text, mediumtext, longtext
    - 해당 칼럼 최대 크기를 초과할 때, 예외 발생하지 말고 문자열을 자동으로 잘라내도록 설정
        
        ```sql
        SELECT @@session.sql_mode;
        # 'ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION'
        # -> STRICT_TRANS_TABLES가 예외 발생 시키는 모드 
        SET sql_mode = 'ansi';
        # 위에처럼 모드 바꾸고 나서 보면 STRICT 어쩌구 사라져 있음 
        ```
        
    - 작은 따옴표 포함
        
        ```sql
        UPDATE string_tbl
        SET text_fld = 'This string doesn't work';
        # doesn't의 아포스트로피가 문자열의 끝을 표시한다고 판단하므로 문자열 삽입 불가 
        # -> escape 추가해야 함 
        UPDATE string_tbl
        SET text_fld = 'This string doesn''t work';
        # 또는 
        UPDATE string_tbl
        SET text_fld = 'This string doesn\'t work';
        ```
        
        - `quote()`
            - 화면 또는 보고서에서 문자열을 검색하는 경우 - 전체 문자열을 따옴표로 묶고 문자열 내의 작은 따옴표 또는 아포스트로피에 이스케이프 추가
            
            ```sql
            SELECT quote(text_fld)
            FROM string_tbl;
            
            ```
            
    - 특수 문자 포함
        - `char()`
            - 프랑스어 악센트 같은 거
            - char(97) = a, char(130) = é
        - `concat()`
            - 특수 문자랑 아닌 문자랑 합치기
            
            ```sql
            SELECT CONCAT('danke sch', CHAR(148), 'n');
            ```
            
            → 당케숀이 안나와서 확인해보니…
            
            c.f. table 스키마 확인하는 법
            
            ```sql
            SELECT TABLE_SCHEMA
            FROM INFORMATION_SCHEMA.TABLES
            WHERE TABLE_NAME = 'test_char';
            ```
            
            - 이유를 알수 없지만 126까지만 특수문자가 나오고(ASCII 범위) 그 이상으로는 안나와서 그냥 넘어간다…
    - 테이블 생성, 데이터 추가 복습
        
        ```sql
        CREATE TABLE string_tbl 
        (char_fld CHAR(30),
        vchar_fld VARCHAR(30),
        text_fld TEXT);
        
        INSERT INTO string_tbl(char_fld, vchar_fld, text_fld)
        VALUES ('This string is 28 characters', 
        	'This string is 28 characters', 
        	'This string is 28 characters');
        ```
        
        - 길이 반환 코드
            - 공백은 제외한 길이 반환
            
            ```sql
            SELECT LENGTH(char_fld) char_length,
            LENGTH(vchar_fld) varchar_length,
            LENGTH(text_fld) text_length
            FROM string_tbl;
            ```
            
        - `position(문자열 IN 칼럼이름)`
            - 문자열 내에서 부분 문자열의 위치를 찾아주는 함수
            - 없으면 0 return
        - `locate(문자열, 칼럼이름, 시작하려는 위치)`
            - 첫번째 문자가 아닌 특정 위치의 문자부터 검색
        - `strcmp(a, b)`
            - string compare
            - a, b는 모두 문자열
            - 정렬 순서에서 a가 b 앞에 오는 경우: -1
            - a == b: 0
            - a가 b 뒤에 오는 경우: 1
            
            ```sql
            select strcmp('abcd', 'xyz') abcd_xyz, #-1
            			 strcmp('abcd', 'abcd') same, #0
                   strcmp('xyz', 'abcd') xyz_abcd; #1
            ```
            
        - like 연산자 사용
            
            ```sql
            select name, name LIKE '%y' ends_in_y
            from category;
            ```
            
        - regexp 정규표현식 사용해서 더 복잡한 패턴 일치
            
            ```sql
            select name, name REGEXP 'y$' ends_in_y
            from category;
            ```
            
        
        c.f. safe mode에서 마이벤치 모드 변경 없이 row 삭제하는 방법
        
        ```sql
        SET SQL_SAFE_UPDATES = 0;
        DELETE FROM string_tbl;
        SET SQL_SAFE_UPDATES = 1;
        ```
        
        - 기존 문자열에 텍스트 추가
            
            ```sql
            update string_tbl 
            set text_fld = concat(text_fld, ', but now it is longer')
            ```
            
            - 보기 좋게 각 고객 정보 나타내기
                
                ```sql
                select concat(first_name, ' ', last_name,
                ' has been a customer since ', date(create_date)) cust_narrative
                from customer;
                ```
                
        - `insert()`
            - 파라미터: 원래 문자열, 시작 위치, 대체할 문자 개수, 대체 문자열
            - 예제
                
                ```sql
                select insert('goodbye world', 9, 0, 'cruel ') string;
                ```
                
                - 9번째 문자: w 부터 시작하는 모든 문자가 오른쪽으로 밀리고, ‘cruel ‘이 삽입
                    
                    → goodbye cruel world 
                    
                
                ```sql
                select insert('goodbye world', 1, 7, 'hello') string;
                ```
                
                - 첫번째 문자: g로 시작해서 7번째 문자까지를 hello로 대체
        - `substring()`
            - 문자열에서 부분 문자열 추출
                - 파라미터: string, 시작 위치, 추출할 문자 수
            - 예제
                
                ```sql
                select substring('goodbye cruel world', 9, 5);
                ```
                
                - 9번째 문자인 c부터 시작해서 5개 추출하면 ‘cruel’
            - 심화 예제
            
            ```sql
            SELECT employee_id,
                   SUBSTRING(employee_name, 
            					       1, 
            					       POSITION(' ' IN employee_name) - 1) 
            		   AS first_name, email
            FROM employees;
            ```
            
- 숫자 데이터 처리
    - 내장 산술 함수
        - exp(x), ln(x), sqrt(x) 등 (삼각함수도 다 가능)
        - mod(10, 4), pow(2, 8)
    - 숫자 자릿수 관리
        - ceil(), floor(), round(), truncate()
            - ceil은 무조건 올림(0.5미만이라도) ↔ floor 무조건 내림(0.5보다 커도)
            - round() 우리가 아는 식의 중간점에서 반올림/내림
                - round(숫자, 남기려는 소수점 수)
                    - 반올림 자체는 남기려는 소수점 하나 뒤에서 이루어짐
            - truncate(숫자, 남기려는 소수점 수)
                - 원치 않는 숫자 버리기
                - truncate(72.0909, 2) → 72.09
            - round, truncate 두번째 파라미터에 모두 음수 값도 가능
                - 소수점 왼쪽에 있는 숫자가 잘리거나 반올림
                - 예) round(17, -1) → 20, truncate(17, -1) → 10
    - 부호 관련
        - int 자료형 지정하면 기본적으로 signed (양수, 음수, 0 다 가능)
        - 양수만 사용하려면 unsigned 키워드 지정해줘야 하고, 주로 not null auto increment랑 같이 사용
            
            ```sql
            CREATE TABLE 'Example' (
                          'id' INT(10) UNSIGNED NOT NULL AUTO_INCREMENT
                )
            ```
            
        - `sign(column이름)`
            - 각 (row, col)에 있는 값의 부호를 반환. 0이면 0.
        - abs(column)
            - 절대값 반환
- 시간 데이터 처리
    - 시간대 처리
        - GMT: 그리니치 표준시. 영국 그리치니 시간대. 다른 모든 시간대는 GMT와의 시간 차이로 나타낼 수 있음
            - 동부 표준시: GMT -5:00 (GMT 보다 5시간 빠른 시간)
        - UTC: 협정 세계표준시
            - `utc_timestemp()`
            
            c.f. UTC와 GMT는 초의 소숫점 단위에서만 차이가 나기 때문에 일상에서는 혼용되어 사용되며 기술적인 표기에서는 UTC가 사용됩니다.
            
        - 데이터베이스 세션 시간대 확인
            
            ```sql
            select @@global.time_zone, @@session.time_zone;
            # system: DB가 설치된 서버의 표준 시간대 
            ```
            
            - 시간대 설정 바꾸기
                
                ```sql
                set time_zone = 'Europe/Zurich';
                ```
                
    - 시간 데이터 생성
        - 날짜 형식의 구성 요소
            - YYYY, MM, DD, HH, HHH(어떤 작업 개시 후 경과된 시간 같은 걸 표현할 때 24 넘어가는 경우 더 큰 수를 표현하기 위해 사용, -838~838 숫자 작성 가능), MI(분), SS(초)
        - 필수 날짜 구성 요소
            
            
            | 자료형 | 기본 형식 |
            | --- | --- |
            | date | YYYY-MM-DD |
            | datetime | YYYY-MM-DD HH:MI:SS |
            | timestamp | YYYY-MM-DD HH:MI:SS |
            | time | HHH:MI:SS |
            
            c.f. datetime vs. timestamp 
            
            | 특성 | DATETIME | TIMESTAMP |
            | --- | --- | --- |
            | 시간대 처리 | 시간대 변환 없음 | UTC 기준으로 저장 및 변환 |
            | 유효 범위 | 1000-01-01 ~ 9999-12-31 | 1970-01-01 ~ 2038-01-19 |
            | 저장 공간 | 5~8바이트 (초의 분수 포함 시 추가) | 4바이트 |
            | 사용 사례 | 시간대에 독립적인 데이터 저장 필요 시 사용 | 글로벌 애플리케이션, 로그 기록 등 |
            | 시간대 변화 의존성 | 시간대 설정에 의존하지 않음 | 서버 시간대 설정에 따라 자동 변환 |
        - 문자열을 날짜로 변환
            
            ```sql
            select cast('2019-09-17 15:30:00' AS DATETIME);
            ```
            
        - 날짜 생성함수
            - 문자열이 cast 함수를 사용하기에 적절한 형식이 아닐 경우
            - `str_to_date()`
                
                ```sql
                UPDATE rental
                SET return_date = STR_TO_DATE('September 17, 2019', ['%M %d, %Y'](https://www.notion.so/Learning-SQL-6f5006f0a7ae4f3e8456a06a399a1456?pvs=21))
                WHERE rental_id = 99999;
                ```
                
                - 알아서 input 문자열 보고 %H,%i, %s만 포함하는 경우는 time 값을 반환
            - 현재 날짜, 시간 생성
                
                ```sql
                select current_date(), current_time(), current_timestamp();
                ```
                
    - 시간 데이터 조작
        - 파라미터를 날짜로 받아서 거기에 연산 하는 함수
            - date_add(기준 날짜, 키워드, 원하는 수량 및 기간)
                
                ```sql
                select date_add(current_date(), interval 5 day);
                select date_add(current_date(), interval '3:24:11' HOUR_SECOND);
                ```
                
                - 기간에 들어갈 수 있는 이름들
                    - second, minute, hour, day, month, year, minute_second(분:초), hour_second(시:분:초), year_month(연-월)
        - 특정 날짜가 속한 월의 마지막 날을 알려주는 함수
            - 윤달 체크할 때 유용
            
            ```sql
            select last_day('2024-05-01'); # '2024-05-31'
            ```
            
        - 문자열을 return 하는 시간 함수
            - 날짜, 시간의 일부 추출
                
                ```sql
                select dayname('2024-05-10'); # Friday
                ```
                
            - `extract([기간 자료형](https://www.notion.so/Learning-SQL-6f5006f0a7ae4f3e8456a06a399a1456?pvs=21) FROM timestamp)`
                
                ```sql
                select extract(year from CURRENT_DATE());
                ```
                
        - 숫자를 return 하는 시간 함수
            - 두 개의 날짜 값을 가져와 두 날짜 사이의 기간 계산
                - 앞에서 뒤의 날짜를 빼기 때문에 순서를 반대로 하면 음수가 나온다
                
                ```sql
                select datediff(CURRENT_DATE(), '2020-03-09'); # 1523
                ```
                
- 변환 함수
    - `cast(문자열 AS 자료형)`
        - 전체 문자열을 왼쪽에서 오른쪽으로 변환하려 하는데, 중간에 숫자가 아닌 문자가 있으면 변환 중지, 오류는 발생하지 않음)
            
            ```sql
            	select cast('999ABC111' AS UNSIGNED INTEGER); # 999까지만 변환 
            ```
            
- 실습
    1. SELECT substring('Please find the substring in this string', 17, 9);
    2. select abs(-25.76823) abs, sign(-25.76823) sign, round(-25.76823, 2) round;
    3. s~~elect date(CURRENT_TIME(), '%m');~~ 
        
        ```sql
        select extract(month from current_date());
        ```