# 12장 트랜잭션

<aside>
<img src="https://www.notion.so/icons/checkmark_gray.svg" alt="https://www.notion.so/icons/checkmark_gray.svg" width="40px" /> 여기서부터는 semi-colon 어디다가 찍어주는지 중요하다 주의!

</aside>

- 트랜잭션
    - 모든 SQL 문이 성공하거나 성공하지 않도록 SQL 문 집합을 그룹화할 때 사용하는 메커니즘(진작에 이렇게 가르쳐 주지;; 아오)
- 다중 사용자 데이터 베이스
    - 데이터 웨어하우스에 다수 사용자가 동시에 데이터를 추가/수정하는 경우
        - 서버는 훨씬 더 많은 bookkeeping 처리해야
    - 예-이번 주의 영화 대여 내역을 요약하는 보고서 생성
        - 보고서가 실행되는 동안에도 여러 사용자가 데이터를 수정
            - 예-고객이 영화를 대여, 반납일 이후 영화를 반납하고 연체료 지불, 5편의 새로운 영화가 재고에 추가
        - 보고서에는 어떤 숫자(현재 update되고 있는 숫자? 아님 만든 시점의 숫자?)가 표시되어야 할까? → locking
            - 서버에서 versioning 사용하는 경우 → 보고서(쿼리)가 시작될 때의 DB 상태 반영
            - 서버가 읽기, 쓰기 잠금을 모두 사용하는 경우 → 서버가 보고서 앱에서 읽기 잠금 실행 할 때의 DB 상태 반영
- Locking
    - DB 서버가 데이터 자원의 동시 사용을 제어하는데 사용하는 메커니즘
        - DB 일부가 잠기면 해당 데이터를 수정하거나 읽으려는 다른 사용자는 잠금이 해제될 때까지 기다려야
    - 가장 흔한 두 가지 방식
        - <1> 읽기-쓰기 잠금 모두 사용
            - ms sql 서버, MySQL(스토리지 엔진 선택)
            - 방식
                - DB writer는 데이터를 수정하기 위해 write lock 서버에 요청 및 수신
                - DB reader는 데이터를 조회하기 위해 서버에 read lock 요청하고 수신
                - 여러 사용자가 동시에 데이터를 읽을 수 있지만,
                    - 각 테이블에 대해 한 번에 하나의 쓰기 잠금만 제공
                    - 쓰기 잠금이 해제될 때까지는 읽기 요청이 차단
            - 단점
                - 동시 읽기와 쓰기 요청이 많으면 대기 시간이 길어질 수 있음
        - <2> 버전 관리 방식
            - 오라클 DB, MySQL(스토리지 엔진 선택)
            - 방식
                - DB writer는 데이터를 수정하기 위해 쓰기 잠금을 서버에 요청 및 수신
                - DB reader가 데이터를 조회할 때는 어떤 유형의 잠금도 필요하지 않음
                - versioning (버전 관리 방식)
                    - 쿼리가 시작될 때부터 완료될 때까지 reader에게 데이터에 대한 일관된 보기를 제공
                    - 다른 사용자가 수정하더라도 데이터는 동일하게 보임
            - 단점
                - 데이터를 수정하는 동안 오래 실행되는 쿼리가 있으면 문제가 될 수 있음
        - c.f. 실무에서 이런 경우가 있을 수도 있다고 함
            
            회사에서 데이터 웨어하우스로 작업하는 동안 **locking** 때문에 대기해야 하는 경우도 발생할 수 있습니다. 특히, 데이터 웨어하우스에서 대규모 데이터 작업을 수행하는 경우에는 트랜잭션이나 쿼리 경쟁으로 인해 잠금이 발생할 수 있습니다. 하지만 데이터 웨어하우스 시스템은 이러한 문제를 최소화하기 위해 다양한 전략과 기술을 사용합니다.
            
            **Locking 문제와 해결 방법**
            
            1.	**잠금 경쟁 최소화**:
            
            •	**읽기 전용 작업**: 데이터 웨어하우스에서는 주로 읽기 작업이 많습니다. 많은 데이터 웨어하우스 솔루션은 읽기 작업에서 잠금을 거의 사용하지 않도록 설계되어 있습니다.
            
            •	**스냅샷 격리**: 데이터베이스가 특정 시점의 데이터 스냅샷을 사용하여 작업을 수행하도록 하여, 다른 작업의 영향을 받지 않도록 합니다.
            
            2.	**사용 시간 조정**:
            
            •	**작업 시간 분산**: 대규모 데이터 로딩이나 분석 작업을 비업무 시간대에 수행하도록 스케줄링하여, 업무 시간 동안의 경쟁을 줄입니다.
            
            •	**작업 예약**: 작업 스케줄러를 사용하여 대규모 작업을 자동으로 예약하고 분산시켜 경쟁을 피합니다.
            
            3.	**병렬 처리 및 분산 처리**:
            
            •	**병렬 처리**: 많은 데이터 웨어하우스는 병렬 처리를 통해 여러 작업을 동시에 처리하여 잠금 문제를 최소화합니다.
            
            •	**분산 처리**: 클라우드 기반 데이터 웨어하우스는 여러 노드에 데이터를 분산시켜 처리하여 잠금 문제를 줄입니다.
            
- Locking Granularity
    - table locks
        - 여러 사용자가 동일한 테이블의 데이터를 동시에 수정하지 못하도록
        - bookkeeping 적지만 사용자 수가 증가함에 따라 대기 시간이 빠르게 증가
    - page locks
        - 여러 사용자가 테이블의 동일한 페이지(한 페이지는 보통 2~16kb 범위의 메모리 세그먼트)의 데이터를 동시에 수정하지 못하도록 합니다.
    - row locks
        - 여러 사용자가 테이블에서 동일한 행을 동시에 수정하지 못하도록
        - 훨씬 더 많은 bookkeeping 필요하지만 많은 사용자가 각자 다른 행에 대해 작업하면 동일한 테이블 수정 가능
    - MS SQL 서버: 페이지, 행, 테이블 잠금 사용
        - 특정 상황에서 행 → 페이지, 페이지 → 테이블로 locking escalation 하기도
    - 오라클 DB: 행 잠금만 사용
        - 잠금 에스컬레이션 없음
    - My SQL: 테이블, 페이지 또는 행 잠금 사용(스토리지 엔진에 따라 다름)
    
- 트랜잭션
    - 여러 SQL 문을 함께 그룹화해서 모든 구문이 성공하거나 성공하지 않도록 하는 장치(atomicity)
    - 트랜잭션 시작 → SQL문 실행
        - 모든 과정이 성공하면 commit
        - 예상치 못한 일이 발생하면 rollback 명령어 실행해서 트랜잭션이 시작된 이후의 모든 변경 사항 취소
            
            ```sql
            START TRANSACTION;
            
            /* 첫번째 계좌에서 돈을 출금, 잔고가 충분한지 확인 */
            UPDATE account SET avail_balance = avail_balance - 500
            WHERE account_id = 9988 AND avail_balance > 500;
            
            IF /* 정확히 한 개의 행이 이전 구문에 의해 업데이트 됨 */ THEN
            /* 두번째 계좌로 입금 */
            UPDATE account SET avail_balance = avail_balance + 500
            WHERE account_id = 9989;
            
            IF /* 정확히 한 개의 행이 이전 구문에 의해 업데이트 됨 */ THEN
            /* 모두 처리되었다면, 변경 사항을 영구적으로 적용  */
            COMMIT;
            ELSE /* 문제가 발생하면, 이 거래의 모든 변경 사항을 취소 */
            ROLLBACK;
            
            END IF;
            
            ELSE
            /* 자금 부족 또는 업데이트 중 오류 발생 */
            ROLLBACK;
            END IF;
            ```
            
            - 트랜잭션의 커밋/롤백 여부와 관계 없이 트랜잭션 실행 중 획득한 모든 리소스(예-쓰기 잠금) 등은 트랜잭션이 완료될 때까지 해제
        - Durability
            - 프로그램이 트랜잭션을 완료하고 commit을 실행했지만
                - 변경 사항이 영구 스토리지에 적용되기 전에 서버가 종료되는 경우
                    
                    = 수정된 데이터가 메모리에 있지만 디스크에 플러시되지 않은 경우 
                    
            - DB 서버는 서버가 다시 시작될 때 트랜잭션의 변경 사항을 다시 적용
- 트랜잭션 시작
    - 방법 1
        - 활성 트랜잭션은 항상 DB 세션과 연결 - 명시적으로 트랜잭션을 시작할 필요나 방법 없음
        - 현재 트랜잭션이 종료되면 서버는 자동으로 세션에 대한 새 트랜잭션 시작
        - 오라클 DB
        - 단일 SQL만 실행 하더라도 마음에 들지 않거나 마음이 바뀌면 변경 사항 롤백 가능
    - 방법 2
        - 자동 커밋 모드 - 명시적으로 트랜잭션을 시작하지 않는 한 개별 SQL문은 서로 독립적으로 자동 커밋
            - 자동 커밋 모드 해제하고 싶으면 `SET AUTOCOMMIT=0`
        - 트랜잭션 시작하려면 시작 명령어 실행 (start transaction)
        - SQL 서버, mySQL
        - 엔터 누르면 SQL문의 변경 사항이 영구 적용
- 트랜잭션 종료
    - commit/rollback 명령어 실행 아니고 트랜잭션 종료될 수 있는 시나리오
        - 서버 종료, 재시작 → 트랜잭션이 자동으로 롤백
        - trx 현재 진행 중에 alter table과 같은 SQL 스키마문 실행 → 현재 트랜잭션 커밋, 자동으로 새로운 트랜잭션 시작
            - 새 테이블이나 인덱스 추가, 테이블에서 열 삭제와 같은 DB 변경은 롤백 불가능
            - 스키마를 변경하는 명령어는 trx 외부에서 수행되어야
            - 명령문 작성 시 주의 - 중간이 스키마문 끼워넣어서 - 서버에 의해 실수로 trx가 여러 개로 분할되지 않도록
        - 다른 start transaction 명령어 실행 → 이전 trx 커밋
        - 서버 deadlock 교착 상태 감지
            - 두 개의 서로 다른 trx가 다른 trx이 현재 보유하고 있는 리소스를 대기할 때 발생
                - 예
                    - trx A가 방금 account table을 업데이트하고, transaction 테이블에 대한 쓰기 잠금을 기다리고 있는 반면
                    - trx B는 transaction 테이블에 행을 삽입하고, account 테이블에 대한 쓰기 잠금을 기다리고 있는 경우
                - 두 trx가 동일한 페이지나 행을 수정할 경우, 각 trx는 다른 trx이 완료되고 필요한 리소스를 확보할 때까지 영원히 기다림
            - 해당 trx 가 원인이라고 판단되면 서버가 조기 종료시킴
                - 어떤 trx를 끝낼지는 임의 또는 일부 기준
            - trx는 롤백되고 오류 메시지 표시
                - Message: Deadlock found when trying to get lock; try restarting transaction
            - 교착 상태가 자주 발생하면, DB에 접근하는 앱을 수정해야 할 수도
                - 거래 데이터 삽입 전 계좌 데이터 수정하듯이 데이터 리소스가 항상 동일한 순서로 접근하도록 함
- 트랜잭션 세이브 포인트
    - 모든 savepoint는 이름이 지정되므로, 단일 trx 내에서 여러 개 생성 가능
        
        `SAVEPOINT my_savepoint;`
        
    - 특정 savepoint로 롤백
        
        `ROLLBACK TO SAVEPOINT my_savepoint;`
        
    - 예
        
        ```sql
        START TRANSACTION;
        
        UPDATE product 
        SET date_retired = CURRENT_TIMESTAMP()
        WHERE product_cd = 'XYZ';
        
        SAVEPOINT before_close_accounts;
        
        /* 이 부분은 최종 커밋 되지 못함 */
        UPDATE account
        SET status='CLOSED', close_date=CURRENT_TIMESTAMP(),
        	last_activity_date = CURRENT_TIMESTAMP()
        WHERE product_cd = 'XYZ';
        
        /* savepoint로 복귀 */ 
        ROLLBACK TO SAVEPOINT before_close_accounts;
        COMMIT;
        ```
        
    - 이름을 지정했음에도 savepoint 생성하면 아무것도 저장되지 않음
        - 트랜잭션을 영구화하려면 commit 무조건 실행해야 함
    - 세이브포인트의 이름을 지정하지 않고 rollback을 실행하면 트랜잭션 내의 모든 세이브포인트가 무시되고, 전체 트랜잭션이 실행 취소 됨
- c.f. 스토리지 엔진 선택
    - 오라클이나 SQL 서버 사용할 때 단일 코드 집합은 기본 키 값을 기반으로 테이블에서 특정행을 조회하는 등 낮은 수준의 DB 작업을 담당
    - MySQL 서버는 리소스 잠금, 트랜잭션 관리를 포함한 낮은 수준의 DB 기능을 제공하기 위해 여러 스토리지 엔진을 활용할 수 있도록 설계
        - MyISAM: 테이블 잠금을 사용하는 nontransaction 엔진
        - MEMORY: 인메모리 테이블에 사용되는 nontransaction 엔진
        - CSV: 데이터를 쉼표로 구분해서 파일에 저장하는 트랜잭션 엔진
        - InnoDB: 행 수준 잠금을 사용하는 transaction 엔진
        - Merge: 여러 개의 MyISAM 테이블을 단일 테이블로 표시하는 특수 엔진(테이블 분할)
        - Archive: 주로 보관 목적으로 대량의 인덱싱되지 않은 데이터를 저장하는 특수 엔진
    - MySQL은 DB 별이 아니라 테이블별로도 스토리지 엔진 선택 가능
        - 트랜잭션을 사용하는 테이블의 경우엔느 행 수준 잠금과 버전 관리를 제공하며, 최고 수준의 동시성을 제공하는 InnoDB 엔진 선택해야
        - 테이블에 지정된 스토리지 엔진 확인
            
            `show table status like 'customer';`
            
        - 테이블을 생성할 때 스토리지 엔진을 명시적으로 지정하거나 기존 테이블을 변경해서 다른 스토리지 엔진을 사용하게 할 수도 있음
            
            `ALTER TABLE customer ENGINE = INNODB;`
            
        
- 실습
    - insert 구문 사용 방법 기억이 안남
        
        ```sql
        INSERT INTO 테이블 이름 (열 이름1, 열 이름2)
        VALUE (값1, 값2);
        ```
        
    - update 구문도 기억 안남
        
        ```sql
        UPDATE product
        SET name = 'Certificate of Deposit'
        WHERE product_cd = 'CD';
        ```
        
    - trial
    
    ```sql
    start transaction;
    
    insert into Transaction 
    	(txn_id, txn_date, account_id, txn_typ_cd, amount)
    values 
    	(1003, current_date(), 123, D, 50);
    insert into Transaction 
    	(txn_id, txn_date, account_id, txn_typ_cd, amount)
    values (1004, current_date(), 789, C, 50);
    
    UPDATE Account
    SET avail_balance = avail_balance - 50, 
    		last_activity_date = current_timestamp()
    WHERE account_id = 123;
    
    UPDATE Account
    SET avail_balance = avail_balance + 50, 
    		last_activity_date = current_timestamp()
    WHERE account_id = 789;
    
    commit;
    ```
    
    - 놓친 점
        - insert와 테이블 이름 사이에는 into가 와야 한다
        - transaction id가 increment 해야 한다
        - 450을 값 자체로 넣어주는게 아니라 식으로 표현 (avail_balance - 50)
        - `now()` 라는 간단한 명령어로 current_timestamp()와 동일한 초 단위 시간 얻을 수 있음
        - set으로 칼럼 value 여러 개 업데이트 해야 하는 경우는 콤마로 이어주기만 하면 된다