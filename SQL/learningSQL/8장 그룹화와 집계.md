# 8장 그룹화와 집계

<aside>
<img src="https://www.notion.so/icons/checkmark_gray.svg" alt="https://www.notion.so/icons/checkmark_gray.svg" width="40px" /> SQL에서 GROUP BY를 사용할 때는, SELECT 절에 포함된 모든 컬럼이 반드시 GROUP BY 절에 포함되거나(그룹화 기준) 집계 함수(SUM, COUNT, AVG, MAX, MIN)로 감싸져야 합니다

</aside>

- 데이터는 보통 DB 사용자가 원하는 가장 작은 단위로 저장
- 집계함수 사용
    
    ```sql
    SELECT customer_id, **count(*)** # *: 모든 행수 
    FROM rental
    GROUP BY customer_id
    ORDER BY 2 DESC;
    ```
    
    - 데이터 그룹 기반으로 데이터 필터링 해야 하는 경우
        - where 절 뒤에 그룹을 넣으면 에러 발생. where절 적용 뒤에 group by 절이 실행되므로
            
            ```sql
            # 🚨 쿼리 수행 순서
            FROM - 가장 먼저 실행되며, 데이터를 어떤 테이블에서 가져올지 결정합니다.
            JOIN - FROM 절 다음에 실행되어 여러 테이블을 결합합니다.
            WHERE - FROM과 JOIN 이후에 실행되어 결과 행을 필터링합니다.
            GROUP BY - 필터링된 결과에 대해 그룹화를 수행합니다.
            HAVING - GROUP BY를 통해 생성된 그룹에 조건을 적용하여 그룹을 필터링합니다.
            SELECT - 이제 최종적으로 선택할 컬럼들을 지정하고, 필요한 계산을 수행합니다.
            ORDER BY - 선택된 결과를 정렬합니다.
            ```
            
            → 그룹 필터 조건은 having에 넣어야 함 
            
    - 집계 함수 종류
        - 집계함수는 그룹의 모든 행에 대해 특정 연산 수행
        - max, min, avg, sum, count
            
            ```sql
            select max(amount) max_amt, min(amount) min_amt,
            			 avg(amount) avg_amt, sum(amount) tot_amt, 
            			 count(*) num_payments
            from payment;
            ```
            
- 명시적 그룹과 암시적 그룹
    - group by 절이 없는 상황에서 집계 함수 → 하나의 암시적 그룹화 (예-payment 테이블의 모든 행)
    - 집계함수로 생성한 열(예-count(*))과 추가적인 열을 함께 검색
        - 예-모든 고객이 아닌 각 고객에 대해 동일한 5개의 집계 함수를 실행하도록 쿼리를 확장하는 경우
            
            ```sql
            select customer_id, max(amount) max_amt, 
            				min(amount) min_amt, avg(amount) avg_amt, 
            				sum(amount) tot_amt, count(*) num_payments
            from payment
            group by customer_id;
            ```
            
            - customer_id 값이 동일한 행들을 그룹화한 다음, 5개의 집계함수를 599개의 각 그룹에 적용
- 고유한 값 계산
    
    ```sql
    select count(customer_id) num_rows, count(distinct customer_id) num_customers
    from payment;
    ```
    
    - num_rows: 모든 customer_id를 중복 포함해서 카운트
    - num_customers: 중복 되지 않은 customer_id만 계산
- 표현식 사용
    - 예-대여 후 반납까지 가장 오래 걸린 일수
        
        ```sql
        select max(datediff(return_date, rental_date))
        from rental;
        ```
        
- null처리 방법
    - 집계 함수들은 null 값을 만나면 무시하기 때문에, sum,max,avg 값은 null row를 추가하기 전후가 다르지 않다
    - 그러나 count(*) 함수는 전체 행 수를 세기 때문에 null 값 row가 추가되면 같이 증가한다 ↔ count(val←행 이름))은 그렇지 않다
- 그룹 생성
    - 용례
        - 전체 유럽 판매량 등 특정 지역에 대한 총계 생성
        - 2020년 최고 영업사원 등의 특정 값 찾기
        - 매월 대여한 영화 수 등의 빈도 계산
    - 단일 열 그룹화
        
        ```sql
        # 각 배우와 관련된 영화의 수 
        select actor_id, count(*)
        from film_actor
        group by actor_id;
        ```
        
    - 다중 열 그룹화
        - rating 열은 select 절과 group by 절에도 모두 추가된다
            - 얘는 집계 함수로 생성되지 않고 테이블에서 검색되기 때문
        
        ```sql
        # 1) 영화 id 기준으로 출연 배우, 영화 정보 join 
        # 2) 출연 배우, 영화 등급 기준으로 그룹핑 
        select fa.actor_id, f.rating, count(*)
        from film_actor fa
        	inner join film f
            on fa.film_id = f.film_id
        group by fa.actor_id, f.rating
        # `ORDER BY`에서 칼럼 인덱스를 사용할 때, `SELECT` 절에 나타나는 첫 칼럼의 인덱스는 1
        order by 1, 2;
        ```
        
    - 그룹화와 표현식
        - from → extract (그룹화 기준 설정)→ group by → 다시 extract(혹은 group by에서 실행한 구문 재사용) → 보여줄 칼럼 선택
        
        ```sql
        select extract(year from rental_date) year, count(*) how_many
        from rental
        group by extract(year from rental_date);
        ```
        
    - 롤업 생성
        - `with rollup` group by 결과로 출력된 항목들의 합계를 나타내는 방법
            
            ```sql
            select fa.actor_id, f.rating, count(*)
            from film_actor fa
            	inner join film f
                on fa.film_id = f.film_id
            group by fa.actor_id, f.rating with rollup
            order by 1, 2;
            ```
            
            - with rollup 없을 때 대비 201개의 행이 늘어났음
                - actor id가 null인 것까지 포함(1) + 200명의 각 개별 배우에 대한 각 영화 등급별 합계를 계산한 행
                    - 예-actor_id=1인 경우
                        
                        '1',NULL,'19' ← roll up 행. 19 = 4 + 5 + 6 + 1 + 3 
                        
                        - 아래는 모두 각 영화 등급에 대한 count 
                        '1','G','4'
                        '1','NC-17','5'
                        '1','PG','6'
                        '1','PG-13','1'
                        '1','R','3'
                - 제일 첫번째 행의 경우 : null, null, 5462
                    - actor_id도 전체, rating도 전체 대상이라 null로 표시
                    - 5462는 film_actor table 행 수와 같음 (전체 영화 배우가 출연한 영화 편수의 총합)
- 그룹 필터 조건
    - having에 필터 조건 주면 됨
        - where절 조건은 그룹화 되기 전에 (raw)데이터에 적용 → 그룹 생성 → having절 조건은 grouped data에 적용
        
        ```sql
        select fa.actor_id, f.rating, count(*)
        from film_actor fa
        	inner join film f
            on fa.film_id = f.film_id
        where f.rating in ('G', 'PG')
        group by fa.actor_id, f.rating
        having count(*) > 9;
        ```
        
- 실습
    - 8-1
        
        ```sql
        select count(*)
        from payment;
        ```
        
    - 8-2
        - Trial & Error
            
            ```sql
            select customer_id, amount, count(*)
            from payment
            group by customer_id;
            ```
            
            → Error Code: 1055. Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'sakila.payment.amount' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
            
            ➜ SQL의 표준 규칙에 따르면, **`SELECT`** 절에서 사용되는 모든 열은 **`GROUP BY`** 절에 나열되거나 집계 함수(예: **`COUNT()`**, **`MAX()`**, **`SUM()`** 등) 안에 포함되어야 합니다.
            
        
        ```sql
        select customer_id, sum(amount), count(*)
        from payment
        group by customer_id;
        ```
        
    - 8-3
        
        ```sql
        select customer_id, sum(amount), count(*)
        from payment
        group by customer_id
        having count(*) >= 40;
        ```