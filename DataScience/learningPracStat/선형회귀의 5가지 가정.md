# 선형회귀의 5가지 가정

- 정의
    1. **선형성 (Linearity)**: 독립 변수와 종속 변수 간의 관계가 선형이어야 합니다.
    2. **독립성 (Independence)**: 관측치들이 서로 독립적이어야 합니다.
    3. **정규성 (Normality)**: 오차 항이 정규 분포를 따라야 합니다.
    4. **등분산성 (Homoscedasticity)**: 오차의 분산이 모든 수준의 독립 변수에서 일정해야 합니다.
    5. **다중공선성 (Multicollinearity) 없음**: 독립 변수들 간에 높은 상관관계가 없어야 합니다.
- 검증
    1. **선형성 (Linearity)**
        - **방법**: 잔차(Residual) vs. 적합값(Fitted values) 플롯을 확인합니다.
        - **설명**: 이 그래프에서 잔차가 무작위로 분포되어 있으면 선형성을 만족합니다.
    2. **독립성 (Independence)**
        - **방법**: 잔차의 자기상관을 확인하기 위해 Durbin-Watson 검정을 사용할 수 있습니다.
        - **설명**: Durbin-Watson 통계량이 2에 가까우면 독립성 가정을 만족합니다.
    3. **정규성 (Normality)**
        - **방법**: Q-Q 플롯(Quantile-Quantile plot) 또는 Shapiro-Wilk 검정을 사용합니다.
        - **설명**: Q-Q 플롯에서 점들이 직선에 가까울수록 잔차가 정규 분포를 따릅니다.
    4. **등분산성 (Homoscedasticity)**
        - **방법**: 잔차 vs. 적합값 플롯을 확인하거나 Breusch-Pagan 검정을 사용할 수 있습니다.
        - **설명**: 이 플롯에서 잔차가 일정한 패턴 없이 분포되어 있으면 등분산성을 만족합니다.
    5. **다중공선성 (Multicollinearity) 없음**
        - **방법**: VIF(Variance Inflation Factor)를 계산합니다.
        - **설명**: VIF 값이 10을 넘지 않으면 다중공선성 문제가 없다고 간주할 수 있습니다.
- 구현
    
    ```python
    import statsmodels.api as sm
    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt
    from statsmodels.stats.outliers_influence import variance_inflation_factor
    from statsmodels.stats.diagnostic import het_breuschpagan
    
    # 예시 데이터
    np.random.seed(0)
    X = np.random.rand(100, 2)
    y = 3 * X[:, 0] + 2 * X[:, 1] + np.random.randn(100)
    
    # 회귀 모델 적합
    X = sm.add_constant(X)
    model = sm.OLS(y, X).fit()
    predictions = model.predict(X)
    
    # 1. 선형성 검증 (잔차 vs. 적합값 플롯)
    plt.scatter(predictions, model.resid)
    plt.axhline(y=0, color='r', linestyle='--')
    plt.xlabel('Fitted values')
    plt.ylabel('Residuals')
    plt.title('Residuals vs. Fitted values')
    plt.show()
    
    # 2. 독립성 검증 (Durbin-Watson 검정)
    from statsmodels.stats.stattools import durbin_watson
    dw_statistic = durbin_watson(model.resid)
    print('Durbin-Watson statistic:', dw_statistic)
    
    # 3. 정규성 검증 (Q-Q 플롯 및 Shapiro-Wilk 검정)
    sm.qqplot(model.resid, line='45')
    plt.title('Q-Q plot')
    plt.show()
    
    from scipy.stats import shapiro
    shapiro_test = shapiro(model.resid)
    print('Shapiro-Wilk test:', shapiro_test)
    
    # 4. 등분산성 검증 (잔차 vs. 적합값 플롯 및 Breusch-Pagan 검정)
    plt.scatter(predictions, model.resid)
    plt.axhline(y=0, color='r', linestyle='--')
    plt.xlabel('Fitted values')
    plt.ylabel('Residuals')
    plt.title('Residuals vs. Fitted values')
    plt.show()
    
    bp_test = het_breuschpagan(model.resid, X)
    print('Breusch-Pagan test:', bp_test)
    
    # 5. 다중공선성 검증 (VIF 계산)
    vif_data = pd.DataFrame()
    vif_data["feature"] = ['const'] + ['x1', 'x2']
    vif_data["VIF"] = [variance_inflation_factor(X, i) for i in range(X.shape[1])]
    print(vif_data)
    ```
    
    1. **선형성 검증**: 잔차 vs. 적합값 플롯을 통해 잔차가 무작위로 분포되어 있는지 확인합니다.
    2. **독립성 검증**: Durbin-Watson 통계량을 계산하여 잔차의 자기상관을 평가합니다.
    3. **정규성 검증**: Q-Q 플롯과 Shapiro-Wilk 검정을 통해 잔차가 정규 분포를 따르는지 확인합니다.
    4. **등분산성 검증**: 잔차 vs. 적합값 플롯과 Breusch-Pagan 검정을 통해 잔차의 분산이 일정한지 확인합니다.
    5. **다중공선성 검증**: VIF 값을 계산하여 독립 변수 간의 다중공선성을 평가합니다.
- chatGPT에 따르면…
    1. **실용성**: 빅데이터를 다루는 경우, 데이터의 크기와 복잡성으로 인해 모든 가정을 확인하고 검증하는 것이 비현실적일 수 있습니다. 대신, 더 실용적이고 빠르게 적용 가능한 방법이 선호됩니다.
    2. **복잡한 모델**: 빅데이터 환경에서는 선형 회귀 외에도 랜덤 포레스트, 그라디언트 부스팅 머신(GBM), 신경망 등 복잡한 모델이 많이 사용됩니다. 이러한 모델들은 기본적인 통계 가정에 크게 의존하지 않습니다.
    3. **부트스트랩의 유용성**: 부트스트랩 방법은 데이터를 반복적으로 샘플링하여 다양한 통계적 추정치를 계산하는 비모수적 방법입니다. 이를 통해 예측구간을 구할 때 데이터의 분포에 대한 특정 가정 없이도 신뢰할 수 있는 구간을 얻을 수 있습니다. 이는 데이터의 분포가 복잡하거나 잘 알려져 있지 않을 때 특히 유용합니다.